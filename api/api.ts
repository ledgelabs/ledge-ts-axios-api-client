/* tslint:disable */
/* eslint-disable */
/**
 * @ledge/api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const AccessStatus = {
    Active: 'ACTIVE',
    Disabled: 'DISABLED'
} as const;

export type AccessStatus = typeof AccessStatus[keyof typeof AccessStatus];


/**
 * 
 * @export
 * @interface Activity
 */
export interface Activity {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'userId': string;
    /**
     * 
     * @type {ActivityType}
     * @memberof Activity
     */
    'type': ActivityType;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'objectId': string;
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    'count': number;
    /**
     * 
     * @type {User}
     * @memberof Activity
     */
    'user'?: User | null;
    /**
     * 
     * @type {boolean}
     * @memberof Activity
     */
    'processed': boolean;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'occurrence': string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ActivityType = {
    UserSignUp: 'USER_SIGN_UP',
    Referral: 'REFERRAL',
    ExternalMilestone: 'EXTERNAL_MILESTONE',
    ExternalCumulative: 'EXTERNAL_CUMULATIVE',
    EmailSocialAuth: 'EMAIL_SOCIAL_AUTH',
    XSocialAuth: 'X_SOCIAL_AUTH',
    DiscordSocialAuth: 'DISCORD_SOCIAL_AUTH',
    XSocialOpenlink: 'X_SOCIAL_OPENLINK',
    XSocialLike: 'X_SOCIAL_LIKE',
    XSocialFollow: 'X_SOCIAL_FOLLOW',
    XSocialShare: 'X_SOCIAL_SHARE',
    XSocialHashtag: 'X_SOCIAL_HASHTAG',
    XSocialRetweet: 'X_SOCIAL_RETWEET',
    DiscordSocialJoinServer: 'DISCORD_SOCIAL_JOIN_SERVER',
    OpenLink: 'OPEN_LINK'
} as const;

export type ActivityType = typeof ActivityType[keyof typeof ActivityType];


/**
 * 
 * @export
 * @interface Announcement
 */
export interface Announcement {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Announcement
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Announcement
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Announcement
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Announcement
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof Announcement
     */
    'status': boolean;
}
/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'expireAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'gameId': string;
    /**
     * 
     * @type {Game}
     * @memberof ApiKey
     */
    'game'?: Game;
    /**
     * 
     * @type {AccessStatus}
     * @memberof ApiKey
     */
    'status': AccessStatus;
}


/**
 * 
 * @export
 * @interface Banner
 */
export interface Banner {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'alt': string | null;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'startTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'endTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'logoText': string | null;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'logoUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'desktopImageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'mobileImageUrl': string;
    /**
     * 
     * @type {BannerLocation}
     * @memberof Banner
     */
    'bannerLocation': BannerLocation;
    /**
     * 
     * @type {string}
     * @memberof Banner
     */
    'eventId': string;
    /**
     * 
     * @type {Event}
     * @memberof Banner
     */
    'event'?: Event;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const BannerLocation = {
    HomePage: 'HOME_PAGE',
    EventPage: 'EVENT_PAGE'
} as const;

export type BannerLocation = typeof BannerLocation[keyof typeof BannerLocation];


/**
 * 
 * @export
 * @interface BaseRaffleRewardsArgs
 */
export interface BaseRaffleRewardsArgs {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof BaseRaffleRewardsArgs
     */
    'numberOfWinners': number;
    /**
     * 
     * @type {PrizeType}
     * @memberof BaseRaffleRewardsArgs
     */
    'prizeType': PrizeType;
    /**
     * 
     * @type {string}
     * @memberof BaseRaffleRewardsArgs
     */
    'productId'?: string;
}


/**
 * Batch Payload for updateMany & deleteMany & createMany
 * @export
 * @interface BatchPayload
 */
export interface BatchPayload {
    /**
     * 
     * @type {number}
     * @memberof BatchPayload
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface Blacklist
 */
export interface Blacklist {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Blacklist
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Blacklist
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Blacklist
     */
    'updatedAt': string;
    /**
     * 
     * @type {BlacklistSeverity}
     * @memberof Blacklist
     */
    'severity': BlacklistSeverity;
    /**
     * 
     * @type {string}
     * @memberof Blacklist
     */
    'userId': string;
    /**
     * 
     * @type {User}
     * @memberof Blacklist
     */
    'user'?: User;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const BlacklistAction = {
    Ban: 'BAN',
    Unban: 'UNBAN'
} as const;

export type BlacklistAction = typeof BlacklistAction[keyof typeof BlacklistAction];


/**
 * 
 * @export
 * @interface BlacklistHistory
 */
export interface BlacklistHistory {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof BlacklistHistory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BlacklistHistory
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BlacklistHistory
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof BlacklistHistory
     */
    'apiKeyId': string;
    /**
     * 
     * @type {BlacklistAction}
     * @memberof BlacklistHistory
     */
    'action': BlacklistAction;
    /**
     * 
     * @type {BlacklistSeverity}
     * @memberof BlacklistHistory
     */
    'severity': BlacklistSeverity | null;
    /**
     * 
     * @type {string}
     * @memberof BlacklistHistory
     */
    'notes': string | null;
    /**
     * 
     * @type {string}
     * @memberof BlacklistHistory
     */
    'userId': string;
    /**
     * 
     * @type {User}
     * @memberof BlacklistHistory
     */
    'user'?: User;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const BlacklistSeverity = {
    Game: 'GAME'
} as const;

export type BlacklistSeverity = typeof BlacklistSeverity[keyof typeof BlacklistSeverity];


/**
 * 
 * @export
 * @interface ClaimPrizeRequest
 */
export interface ClaimPrizeRequest {
    /**
     * 
     * @type {string}
     * @memberof ClaimPrizeRequest
     */
    'notificationId': string;
}
/**
 * 
 * @export
 * @interface ClaimPrizeResponse
 */
export interface ClaimPrizeResponse {
    /**
     * 
     * @type {TransactionNew}
     * @memberof ClaimPrizeResponse
     */
    'transaction': TransactionNew | null;
    /**
     * 
     * @type {Notification}
     * @memberof ClaimPrizeResponse
     */
    'notification': Notification | null;
}
/**
 * 
 * @export
 * @interface CompleteSocialQuestRequest
 */
export interface CompleteSocialQuestRequest {
    /**
     * 
     * @type {string}
     * @memberof CompleteSocialQuestRequest
     */
    'eventId': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteSocialQuestRequest
     */
    'questScheduleId': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteSocialQuestRequest
     */
    'goalId': string;
}
/**
 * 
 * @export
 * @interface CompleteSocialQuestRequestNew
 */
export interface CompleteSocialQuestRequestNew {
    /**
     * 
     * @type {string}
     * @memberof CompleteSocialQuestRequestNew
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteSocialQuestRequestNew
     */
    'questId': string;
}
/**
 * 
 * @export
 * @interface CompleteSocialQuestResponse
 */
export interface CompleteSocialQuestResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CompleteSocialQuestResponse
     */
    'isComplete': boolean | null;
    /**
     * 
     * @type {number}
     * @memberof CompleteSocialQuestResponse
     */
    'progress': number | null;
    /**
     * 
     * @type {boolean}
     * @memberof CompleteSocialQuestResponse
     */
    'isPendingVerification': boolean;
    /**
     * 
     * @type {string}
     * @memberof CompleteSocialQuestResponse
     */
    'questScheduleId': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteSocialQuestResponse
     */
    'goalId': string;
    /**
     * 
     * @type {string}
     * @memberof CompleteSocialQuestResponse
     */
    'progressId': string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ConnectionType = {
    Discord: 'discord',
    X: 'x',
    Email: 'email',
    Google: 'google'
} as const;

export type ConnectionType = typeof ConnectionType[keyof typeof ConnectionType];


/**
 * 
 * @export
 * @interface CreateAppToken200Response
 */
export interface CreateAppToken200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateAppToken200Response
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAppToken200Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface CreateBannerArgs
 */
export interface CreateBannerArgs {
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof CreateBannerArgs
     */
    'startTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {BannerLocation}
     * @memberof CreateBannerArgs
     */
    'bannerLocation': BannerLocation;
    /**
     * 
     * @type {string}
     * @memberof CreateBannerArgs
     */
    'eventId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBannerArgs
     */
    'desktopImageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBannerArgs
     */
    'mobileImageUrl': string;
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof CreateBannerArgs
     */
    'endTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {string}
     * @memberof CreateBannerArgs
     */
    'logoUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateBannerArgs
     */
    'alt'?: string | null;
}


/**
 * 
 * @export
 * @interface CreateEventArgs
 */
export interface CreateEventArgs {
    /**
     * 
     * @type {string}
     * @memberof CreateEventArgs
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventArgs
     */
    'subtitle': string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventArgs
     */
    'gameId': string;
    /**
     * 
     * @type {EventStatus}
     * @memberof CreateEventArgs
     */
    'status'?: EventStatus;
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof CreateEventArgs
     */
    'startTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof CreateEventArgs
     */
    'endTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {string}
     * @memberof CreateEventArgs
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateEventArgs
     */
    'imageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateEventArgs
     */
    'mapCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateEventArgs
     */
    'youtubeId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateEventArgs
     */
    'videoUrl'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CreateEventGameAccess = {
    Hidden: 'HIDDEN',
    Creator: 'CREATOR'
} as const;

export type CreateEventGameAccess = typeof CreateEventGameAccess[keyof typeof CreateEventGameAccess];


/**
 * 
 * @export
 * @interface CreateGameArgs
 */
export interface CreateGameArgs {
    /**
     * 
     * @type {string}
     * @memberof CreateGameArgs
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGameArgs
     */
    'studioId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGameArgs
     */
    'iconUrl': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGameArgs
     */
    'description'?: string | null;
    /**
     * 
     * @type {CreateEventGameAccess}
     * @memberof CreateGameArgs
     */
    'createAccess'?: CreateEventGameAccess;
    /**
     * 
     * @type {string}
     * @memberof CreateGameArgs
     */
    'createEventImageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGameArgs
     */
    'clientId'?: string | null;
}


/**
 * 
 * @export
 * @interface CreateGameQuestArgs
 */
export interface CreateGameQuestArgs {
    [key: string]: any;

    /**
     * 
     * @type {Array<string>}
     * @memberof CreateGameQuestArgs
     */
    'gameQuestTemplateIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateGameQuestArgs
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGameQuestArgs
     */
    'endTime': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGameQuestArgs
     */
    'existingScheduleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGameQuestArgs
     */
    'existingQuestSetId'?: string;
}
/**
 * 
 * @export
 * @interface CreateGoalArgs
 */
export interface CreateGoalArgs {
    /**
     * 
     * @type {string}
     * @memberof CreateGoalArgs
     */
    'bannerUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGoalArgs
     */
    'openUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGoalArgs
     */
    'objectId': string | null;
    /**
     * 
     * @type {ActivityType}
     * @memberof CreateGoalArgs
     */
    'activity': ActivityType;
    /**
     * 
     * @type {number}
     * @memberof CreateGoalArgs
     */
    'target': number;
    /**
     * 
     * @type {string}
     * @memberof CreateGoalArgs
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateGoalArgs
     */
    'title': string;
}


/**
 * 
 * @export
 * @interface CreateLeaderboardArgs
 */
export interface CreateLeaderboardArgs {
    /**
     * 
     * @type {LeaderboardDisplay}
     * @memberof CreateLeaderboardArgs
     */
    'leaderboardDisplay': LeaderboardDisplay;
    /**
     * 
     * @type {string}
     * @memberof CreateLeaderboardArgs
     */
    'gameId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLeaderboardArgs
     */
    'eventId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLeaderboardArgs
     */
    'scoreTextAlias': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLeaderboardArgs
     */
    'title': string;
}


/**
 * 
 * @export
 * @interface CreateLeaderboardResponse
 */
export interface CreateLeaderboardResponse {
    /**
     * 
     * @type {LeaderboardDisplay}
     * @memberof CreateLeaderboardResponse
     */
    'leaderboardDisplay': LeaderboardDisplay | null;
    /**
     * 
     * @type {string}
     * @memberof CreateLeaderboardResponse
     */
    'gameId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLeaderboardResponse
     */
    'eventId': string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateLeaderboardResponse
     */
    'scoreTextAlias': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLeaderboardResponse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLeaderboardResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLeaderboardResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLeaderboardResponse
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface CreateLeaderboardRewardArgs
 */
export interface CreateLeaderboardRewardArgs {
    [key: string]: any;

    /**
     * 
     * @type {CreateLeaderboardRewardArgsCashPrize}
     * @memberof CreateLeaderboardRewardArgs
     */
    'cashPrize'?: CreateLeaderboardRewardArgsCashPrize;
}
/**
 * 
 * @export
 * @interface CreateLeaderboardRewardArgsCashPrize
 */
export interface CreateLeaderboardRewardArgsCashPrize {
    /**
     * 
     * @type {string}
     * @memberof CreateLeaderboardRewardArgsCashPrize
     */
    'productId'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateLeaderboardRewardArgsCashPrize
     */
    'topNPlayers': CreateLeaderboardRewardArgsCashPrizeTopNPlayersEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateLeaderboardRewardArgsCashPrize
     */
    'prizePoolQuantity': number;
}

export const CreateLeaderboardRewardArgsCashPrizeTopNPlayersEnum = {
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_10: 10
} as const;

export type CreateLeaderboardRewardArgsCashPrizeTopNPlayersEnum = typeof CreateLeaderboardRewardArgsCashPrizeTopNPlayersEnum[keyof typeof CreateLeaderboardRewardArgsCashPrizeTopNPlayersEnum];

/**
 * 
 * @export
 * @interface CreateLeaderboardRewardsArgs
 */
export interface CreateLeaderboardRewardsArgs {
    /**
     * 
     * @type {string}
     * @memberof CreateLeaderboardRewardsArgs
     */
    'leaderboardScheduleId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLeaderboardRewardsArgs
     */
    'productId': string;
    /**
     * 
     * @type {number}
     * @memberof CreateLeaderboardRewardsArgs
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof CreateLeaderboardRewardsArgs
     */
    'endingPlace'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateLeaderboardRewardsArgs
     */
    'startingPlace': number;
}
/**
 * 
 * @export
 * @interface CreatePrizeDeliveredNotification200Response
 */
export interface CreatePrizeDeliveredNotification200Response {
}
/**
 * 
 * @export
 * @interface CreatePrizeDeliveredNotificationRequest
 */
export interface CreatePrizeDeliveredNotificationRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePrizeDeliveredNotificationRequest
     */
    'prizeText': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePrizeDeliveredNotificationRequest
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface CreateProductArgs
 */
export interface CreateProductArgs {
    /**
     * 
     * @type {string}
     * @memberof CreateProductArgs
     */
    'title': string;
    /**
     * 
     * @type {ProductType}
     * @memberof CreateProductArgs
     */
    'type': ProductType;
    /**
     * 
     * @type {string}
     * @memberof CreateProductArgs
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateProductArgs
     */
    'gameId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateProductArgs
     */
    'iconUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateProductArgs
     */
    'subTitle'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreateProductArgs
     */
    'initialQuantity'?: number;
}


/**
 * 
 * @export
 * @interface CreateQuestArgs
 */
export interface CreateQuestArgs {
    /**
     * 
     * @type {QuestType}
     * @memberof CreateQuestArgs
     */
    'type': QuestType;
}


/**
 * 
 * @export
 * @interface CreateQuestGoalArgs
 */
export interface CreateQuestGoalArgs {
    /**
     * 
     * @type {QuestType}
     * @memberof CreateQuestGoalArgs
     */
    'type': QuestType;
    /**
     * 
     * @type {string}
     * @memberof CreateQuestGoalArgs
     */
    'bannerUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateQuestGoalArgs
     */
    'openUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateQuestGoalArgs
     */
    'objectId': string | null;
    /**
     * 
     * @type {ActivityType}
     * @memberof CreateQuestGoalArgs
     */
    'activity': ActivityType;
    /**
     * 
     * @type {number}
     * @memberof CreateQuestGoalArgs
     */
    'target': number;
    /**
     * 
     * @type {string}
     * @memberof CreateQuestGoalArgs
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateQuestGoalArgs
     */
    'title': string;
}


/**
 * 
 * @export
 * @interface CreateQuestResponse
 */
export interface CreateQuestResponse {
    /**
     * 
     * @type {Goal}
     * @memberof CreateQuestResponse
     */
    'goal': Goal;
    /**
     * 
     * @type {Quest}
     * @memberof CreateQuestResponse
     */
    'quest': Quest;
}
/**
 * 
 * @export
 * @interface CreateQuestRewardArgs
 */
export interface CreateQuestRewardArgs {
    /**
     * 
     * @type {string}
     * @memberof CreateQuestRewardArgs
     */
    'goalId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateQuestRewardArgs
     */
    'productId': string;
    /**
     * 
     * @type {number}
     * @memberof CreateQuestRewardArgs
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface CreateQuestScheduleArgs
 */
export interface CreateQuestScheduleArgs {
    /**
     * 
     * @type {string}
     * @memberof CreateQuestScheduleArgs
     */
    'endTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateQuestScheduleArgs
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof CreateQuestScheduleArgs
     */
    'questId': string;
}
/**
 * 
 * @export
 * @interface CreateRaffleArgsBaseRaffleRewardsArgs
 */
export interface CreateRaffleArgsBaseRaffleRewardsArgs {
    [key: string]: any;

    /**
     * 
     * @type {PrizeType}
     * @memberof CreateRaffleArgsBaseRaffleRewardsArgs
     */
    'rewardDistributionMethod': PrizeType;
    /**
     * 
     * @type {BaseRaffleRewardsArgs}
     * @memberof CreateRaffleArgsBaseRaffleRewardsArgs
     */
    'rewardDistribution': BaseRaffleRewardsArgs;
    /**
     * 
     * @type {string}
     * @memberof CreateRaffleArgsBaseRaffleRewardsArgs
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaffleArgsBaseRaffleRewardsArgs
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaffleArgsBaseRaffleRewardsArgs
     */
    'endTime': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaffleArgsBaseRaffleRewardsArgs
     */
    'eventId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaffleArgsBaseRaffleRewardsArgs
     */
    'raffleTicketId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaffleArgsBaseRaffleRewardsArgs
     */
    'existingScheduleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRaffleArgsBaseRaffleRewardsArgs
     */
    'expiredTicketID'?: string;
}


/**
 * 
 * @export
 * @interface CreateSocialQuestArgs
 */
export interface CreateSocialQuestArgs {
    [key: string]: any;

    /**
     * 
     * @type {Array<CreateSocialQuestArgsSocialQuestInner>}
     * @memberof CreateSocialQuestArgs
     */
    'socialQuest': Array<CreateSocialQuestArgsSocialQuestInner>;
    /**
     * 
     * @type {string}
     * @memberof CreateSocialQuestArgs
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSocialQuestArgs
     */
    'endTime': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSocialQuestArgs
     */
    'existingScheduleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateSocialQuestArgs
     */
    'existingQuestSetId'?: string;
}
/**
 * 
 * @export
 * @interface CreateSocialQuestArgsSocialQuestInner
 */
export interface CreateSocialQuestArgsSocialQuestInner {
    /**
     * 
     * @type {number}
     * @memberof CreateSocialQuestArgsSocialQuestInner
     */
    'rewardQuantity': number;
    /**
     * 
     * @type {string}
     * @memberof CreateSocialQuestArgsSocialQuestInner
     */
    'socialQuestTemplateId': string;
}
/**
 * 
 * @export
 * @interface CreateUserConnectionRequest
 */
export interface CreateUserConnectionRequest {
    /**
     * 
     * @type {ConnectionType}
     * @memberof CreateUserConnectionRequest
     */
    'socialConnectionType': ConnectionType;
    /**
     * 
     * @type {string}
     * @memberof CreateUserConnectionRequest
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserConnectionRequest
     */
    'sub'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserConnectionRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserConnectionRequest
     */
    'email'?: string;
}


/**
 * 
 * @export
 * @interface CreateUserConnectionResponse
 */
export interface CreateUserConnectionResponse {
    /**
     * 
     * @type {ConnectionType}
     * @memberof CreateUserConnectionResponse
     */
    'socialConnectionType': ConnectionType;
    /**
     * 
     * @type {string}
     * @memberof CreateUserConnectionResponse
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserConnectionResponse
     */
    'sub': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserConnectionResponse
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserConnectionResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserConnectionResponse
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface DeleteAnnouncement200Response
 */
export interface DeleteAnnouncement200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteAnnouncement200Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface Draw
 */
export interface Draw {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Draw
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Draw
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Draw
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Draw
     */
    'objectId': string;
    /**
     * 
     * @type {string}
     * @memberof Draw
     */
    'ticketId': string;
    /**
     * 
     * @type {string}
     * @memberof Draw
     */
    'expiredTicketId': string | null;
    /**
     * 
     * @type {string}
     * @memberof Draw
     */
    'title': string | null;
    /**
     * 
     * @type {string}
     * @memberof Draw
     */
    'eventId': string | null;
    /**
     * 
     * @type {QuestOrientation}
     * @memberof Draw
     */
    'questOrientation': QuestOrientation;
    /**
     * 
     * @type {string}
     * @memberof Draw
     */
    'imageUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof Draw
     */
    'imageBigUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof Draw
     */
    'markdown': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Draw
     */
    'excludePreviousWinners': boolean;
    /**
     * 
     * @type {Product}
     * @memberof Draw
     */
    'ticket'?: Product | null;
    /**
     * 
     * @type {Product}
     * @memberof Draw
     */
    'expiredTicket'?: Product | null;
    /**
     * 
     * @type {Array<DrawProduct>}
     * @memberof Draw
     */
    'drawProducts'?: Array<DrawProduct>;
    /**
     * 
     * @type {Array<DrawSchedule>}
     * @memberof Draw
     */
    'drawSchedules'?: Array<DrawSchedule>;
    /**
     * 
     * @type {Event}
     * @memberof Draw
     */
    'event'?: Event | null;
}


/**
 * 
 * @export
 * @interface DrawDetailed
 */
export interface DrawDetailed {
    /**
     * 
     * @type {string}
     * @memberof DrawDetailed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DrawDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DrawDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof DrawDetailed
     */
    'objectId': string;
    /**
     * 
     * @type {string}
     * @memberof DrawDetailed
     */
    'ticketId': string;
    /**
     * 
     * @type {string}
     * @memberof DrawDetailed
     */
    'expiredTicketId': string | null;
    /**
     * 
     * @type {string}
     * @memberof DrawDetailed
     */
    'title': string | null;
    /**
     * 
     * @type {string}
     * @memberof DrawDetailed
     */
    'eventId': string | null;
    /**
     * 
     * @type {QuestOrientation}
     * @memberof DrawDetailed
     */
    'questOrientation': QuestOrientation;
    /**
     * 
     * @type {string}
     * @memberof DrawDetailed
     */
    'imageUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof DrawDetailed
     */
    'imageBigUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof DrawDetailed
     */
    'markdown': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DrawDetailed
     */
    'excludePreviousWinners': boolean;
    /**
     * 
     * @type {Product}
     * @memberof DrawDetailed
     */
    'ticket'?: Product | null;
    /**
     * 
     * @type {Product}
     * @memberof DrawDetailed
     */
    'expiredTicket': Product | null;
    /**
     * 
     * @type {Array<DrawProductDetailed>}
     * @memberof DrawDetailed
     */
    'drawProducts': Array<DrawProductDetailed>;
    /**
     * 
     * @type {Array<DrawSchedule>}
     * @memberof DrawDetailed
     */
    'drawSchedules'?: Array<DrawSchedule>;
    /**
     * 
     * @type {Event}
     * @memberof DrawDetailed
     */
    'event': Event | null;
}


/**
 * 
 * @export
 * @interface DrawProduct
 */
export interface DrawProduct {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof DrawProduct
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DrawProduct
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DrawProduct
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof DrawProduct
     */
    'qty': number;
    /**
     * 
     * @type {string}
     * @memberof DrawProduct
     */
    'drawId': string;
    /**
     * 
     * @type {string}
     * @memberof DrawProduct
     */
    'productId': string;
    /**
     * 
     * @type {Draw}
     * @memberof DrawProduct
     */
    'draw'?: Draw | null;
    /**
     * 
     * @type {Product}
     * @memberof DrawProduct
     */
    'product'?: Product | null;
    /**
     * 
     * @type {Array<UserDraw>}
     * @memberof DrawProduct
     */
    'userDraws'?: Array<UserDraw>;
}
/**
 * 
 * @export
 * @interface DrawProductDetailed
 */
export interface DrawProductDetailed {
    /**
     * 
     * @type {string}
     * @memberof DrawProductDetailed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DrawProductDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DrawProductDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof DrawProductDetailed
     */
    'qty': number;
    /**
     * 
     * @type {string}
     * @memberof DrawProductDetailed
     */
    'drawId': string;
    /**
     * 
     * @type {string}
     * @memberof DrawProductDetailed
     */
    'productId': string;
    /**
     * 
     * @type {Draw}
     * @memberof DrawProductDetailed
     */
    'draw'?: Draw | null;
    /**
     * 
     * @type {Product}
     * @memberof DrawProductDetailed
     */
    'product': Product | null;
    /**
     * 
     * @type {Array<UserDraw>}
     * @memberof DrawProductDetailed
     */
    'userDraws'?: Array<UserDraw>;
}
/**
 * 
 * @export
 * @interface DrawSchedule
 */
export interface DrawSchedule {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof DrawSchedule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DrawSchedule
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DrawSchedule
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof DrawSchedule
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof DrawSchedule
     */
    'endTime': string;
    /**
     * 
     * @type {boolean}
     * @memberof DrawSchedule
     */
    'recurring': boolean;
    /**
     * 
     * @type {string}
     * @memberof DrawSchedule
     */
    'drawId': string;
    /**
     * 
     * @type {boolean}
     * @memberof DrawSchedule
     */
    'processed': boolean;
    /**
     * 
     * @type {Draw}
     * @memberof DrawSchedule
     */
    'draw'?: Draw | null;
    /**
     * 
     * @type {Array<UserDraw>}
     * @memberof DrawSchedule
     */
    'userDraws'?: Array<UserDraw>;
}
/**
 * 
 * @export
 * @interface DrawScheduleDetailed
 */
export interface DrawScheduleDetailed {
    /**
     * 
     * @type {string}
     * @memberof DrawScheduleDetailed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DrawScheduleDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof DrawScheduleDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof DrawScheduleDetailed
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof DrawScheduleDetailed
     */
    'endTime': string;
    /**
     * 
     * @type {boolean}
     * @memberof DrawScheduleDetailed
     */
    'recurring': boolean;
    /**
     * 
     * @type {string}
     * @memberof DrawScheduleDetailed
     */
    'drawId': string;
    /**
     * 
     * @type {boolean}
     * @memberof DrawScheduleDetailed
     */
    'processed': boolean;
    /**
     * 
     * @type {DrawDetailed}
     * @memberof DrawScheduleDetailed
     */
    'draw': DrawDetailed | null;
    /**
     * 
     * @type {Array<UserDraw>}
     * @memberof DrawScheduleDetailed
     */
    'userDraws'?: Array<UserDraw>;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'code': number;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'startTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'endTime': string | null;
    /**
     * 
     * @type {EventStatus}
     * @memberof Event
     */
    'status': EventStatus;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'subtitle': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'imageUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'mapCode': string | null;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'youtubeId': string | null;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'videoUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'gameId': string;
    /**
     * 
     * @type {Game}
     * @memberof Event
     */
    'game'?: Game;
    /**
     * 
     * @type {Array<Draw>}
     * @memberof Event
     */
    'draws'?: Array<Draw>;
    /**
     * 
     * @type {Array<Leaderboard>}
     * @memberof Event
     */
    'leaderboards'?: Array<Leaderboard>;
    /**
     * 
     * @type {Array<GameCode>}
     * @memberof Event
     */
    'gameCodes'?: Array<GameCode>;
    /**
     * 
     * @type {Array<Participant>}
     * @memberof Event
     */
    'participants'?: Array<Participant>;
    /**
     * 
     * @type {Array<Quest>}
     * @memberof Event
     */
    'quest'?: Array<Quest>;
    /**
     * 
     * @type {Array<Banner>}
     * @memberof Event
     */
    'banners'?: Array<Banner>;
}


/**
 * 
 * @export
 * @interface EventChangeHistoryNew
 */
export interface EventChangeHistoryNew {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof EventChangeHistoryNew
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventChangeHistoryNew
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EventChangeHistoryNew
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof EventChangeHistoryNew
     */
    'timeChange': string;
    /**
     * 
     * @type {string}
     * @memberof EventChangeHistoryNew
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof EventChangeHistoryNew
     */
    'logMessage': string;
    /**
     * 
     * @type {string}
     * @memberof EventChangeHistoryNew
     */
    'authorUserId': string;
    /**
     * 
     * @type {string}
     * @memberof EventChangeHistoryNew
     */
    'eventId': string;
    /**
     * 
     * @type {EventNew}
     * @memberof EventChangeHistoryNew
     */
    'event'?: EventNew;
}
/**
 * 
 * @export
 * @interface EventGame
 */
export interface EventGame {
    /**
     * 
     * @type {string}
     * @memberof EventGame
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventGame
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EventGame
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof EventGame
     */
    'studioId': string;
    /**
     * 
     * @type {string}
     * @memberof EventGame
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof EventGame
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof EventGame
     */
    'iconUrl': string;
    /**
     * 
     * @type {string}
     * @memberof EventGame
     */
    'clientId': string | null;
    /**
     * 
     * @type {CreateEventGameAccess}
     * @memberof EventGame
     */
    'createAccess': CreateEventGameAccess;
    /**
     * 
     * @type {string}
     * @memberof EventGame
     */
    'createEventImageUrl': string | null;
    /**
     * 
     * @type {Array<ApiKey>}
     * @memberof EventGame
     */
    'apiKeys'?: Array<ApiKey>;
    /**
     * 
     * @type {Array<Leaderboard>}
     * @memberof EventGame
     */
    'leaderboards'?: Array<Leaderboard>;
    /**
     * 
     * @type {Array<UserInstalledGames>}
     * @memberof EventGame
     */
    'userInstalledGames'?: Array<UserInstalledGames>;
    /**
     * 
     * @type {Array<Quest>}
     * @memberof EventGame
     */
    'quests'?: Array<Quest>;
    /**
     * 
     * @type {Array<GameCode>}
     * @memberof EventGame
     */
    'gameCode'?: Array<GameCode>;
    /**
     * 
     * @type {Array<Event>}
     * @memberof EventGame
     */
    'events'?: Array<Event>;
    /**
     * 
     * @type {Array<GameLinks>}
     * @memberof EventGame
     */
    'links'?: Array<GameLinks>;
    /**
     * 
     * @type {Array<EventNew>}
     * @memberof EventGame
     */
    'eventNew'?: Array<EventNew>;
    /**
     * 
     * @type {Array<GameMode>}
     * @memberof EventGame
     */
    'gameModes': Array<GameMode>;
    /**
     * 
     * @type {Array<GameQuestTemplate>}
     * @memberof EventGame
     */
    'gameQuestTemplates'?: Array<GameQuestTemplate>;
}


/**
 * 
 * @export
 * @interface EventNew
 */
export interface EventNew {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof EventNew
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventNew
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EventNew
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof EventNew
     */
    'title': string | null;
    /**
     * 
     * @type {string}
     * @memberof EventNew
     */
    'startTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof EventNew
     */
    'endTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof EventNew
     */
    'thumbnailUrl': string | null;
    /**
     * 
     * @type {number}
     * @memberof EventNew
     */
    'maxPlayers': number | null;
    /**
     * 
     * @type {number}
     * @memberof EventNew
     */
    'minPlayers': number | null;
    /**
     * 
     * @type {number}
     * @memberof EventNew
     */
    'entryFee': number;
    /**
     * 
     * @type {EventStatus}
     * @memberof EventNew
     */
    'status': EventStatus;
    /**
     * 
     * @type {string}
     * @memberof EventNew
     */
    'mapCode': string | null;
    /**
     * 
     * @type {string}
     * @memberof EventNew
     */
    'eventAuthorId': string;
    /**
     * 
     * @type {User}
     * @memberof EventNew
     */
    'eventAuthor'?: User;
    /**
     * 
     * @type {string}
     * @memberof EventNew
     */
    'gameId': string | null;
    /**
     * 
     * @type {Game}
     * @memberof EventNew
     */
    'game'?: Game | null;
    /**
     * 
     * @type {Array<EventChangeHistoryNew>}
     * @memberof EventNew
     */
    'eventChangeHistory'?: Array<EventChangeHistoryNew>;
    /**
     * 
     * @type {Array<LeaderboardNew>}
     * @memberof EventNew
     */
    'leaderboardNew'?: Array<LeaderboardNew>;
    /**
     * 
     * @type {Array<ParticipantNew>}
     * @memberof EventNew
     */
    'participants'?: Array<ParticipantNew>;
    /**
     * 
     * @type {Array<RaffleNew>}
     * @memberof EventNew
     */
    'raffleNew'?: Array<RaffleNew>;
    /**
     * 
     * @type {Array<QuestSet>}
     * @memberof EventNew
     */
    'questSet'?: Array<QuestSet>;
    /**
     * 
     * @type {number}
     * @memberof EventNew
     */
    'hostCut': number | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const EventStatus = {
    Live: 'LIVE',
    Ended: 'ENDED',
    Tba: 'TBA',
    Starting: 'STARTING',
    Locked: 'LOCKED',
    Draft: 'DRAFT'
} as const;

export type EventStatus = typeof EventStatus[keyof typeof EventStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const Frequency = {
    Once: 'ONCE',
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Yearly: 'YEARLY'
} as const;

export type Frequency = typeof Frequency[keyof typeof Frequency];


/**
 * 
 * @export
 * @interface Game
 */
export interface Game {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Game
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Game
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Game
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Game
     */
    'studioId': string;
    /**
     * 
     * @type {string}
     * @memberof Game
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Game
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof Game
     */
    'iconUrl': string;
    /**
     * 
     * @type {string}
     * @memberof Game
     */
    'clientId': string | null;
    /**
     * 
     * @type {CreateEventGameAccess}
     * @memberof Game
     */
    'createAccess': CreateEventGameAccess;
    /**
     * 
     * @type {string}
     * @memberof Game
     */
    'createEventImageUrl': string | null;
    /**
     * 
     * @type {Array<ApiKey>}
     * @memberof Game
     */
    'apiKeys'?: Array<ApiKey>;
    /**
     * 
     * @type {Array<Leaderboard>}
     * @memberof Game
     */
    'leaderboards'?: Array<Leaderboard>;
    /**
     * 
     * @type {Array<UserInstalledGames>}
     * @memberof Game
     */
    'userInstalledGames'?: Array<UserInstalledGames>;
    /**
     * 
     * @type {Array<Quest>}
     * @memberof Game
     */
    'quests'?: Array<Quest>;
    /**
     * 
     * @type {Array<GameCode>}
     * @memberof Game
     */
    'gameCode'?: Array<GameCode>;
    /**
     * 
     * @type {Array<Event>}
     * @memberof Game
     */
    'events'?: Array<Event>;
    /**
     * 
     * @type {Array<GameLinks>}
     * @memberof Game
     */
    'links'?: Array<GameLinks>;
    /**
     * 
     * @type {Array<EventNew>}
     * @memberof Game
     */
    'eventNew'?: Array<EventNew>;
    /**
     * 
     * @type {Array<GameMode>}
     * @memberof Game
     */
    'gameModes'?: Array<GameMode>;
    /**
     * 
     * @type {Array<GameQuestTemplate>}
     * @memberof Game
     */
    'gameQuestTemplates'?: Array<GameQuestTemplate>;
}


/**
 * 
 * @export
 * @interface GameCode
 */
export interface GameCode {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof GameCode
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GameCode
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GameCode
     */
    'updatedAt': string;
    /**
     * 
     * @type {GameCodeType}
     * @memberof GameCode
     */
    'type': GameCodeType;
    /**
     * 
     * @type {GameCodeStatus}
     * @memberof GameCode
     */
    'status': GameCodeStatus;
    /**
     * 
     * @type {string}
     * @memberof GameCode
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof GameCode
     */
    'usedDate': string | null;
    /**
     * 
     * @type {string}
     * @memberof GameCode
     */
    'userId': string | null;
    /**
     * 
     * @type {User}
     * @memberof GameCode
     */
    'user'?: User | null;
    /**
     * 
     * @type {string}
     * @memberof GameCode
     */
    'eventId': string | null;
    /**
     * 
     * @type {Event}
     * @memberof GameCode
     */
    'event'?: Event | null;
    /**
     * 
     * @type {string}
     * @memberof GameCode
     */
    'gameId': string;
    /**
     * 
     * @type {Game}
     * @memberof GameCode
     */
    'game'?: Game;
}


/**
 * 
 * @export
 * @interface GameCodeDetailed
 */
export interface GameCodeDetailed {
    /**
     * 
     * @type {string}
     * @memberof GameCodeDetailed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GameCodeDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GameCodeDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {GameCodeType}
     * @memberof GameCodeDetailed
     */
    'type': GameCodeType;
    /**
     * 
     * @type {GameCodeStatus}
     * @memberof GameCodeDetailed
     */
    'status': GameCodeStatus;
    /**
     * 
     * @type {string}
     * @memberof GameCodeDetailed
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof GameCodeDetailed
     */
    'usedDate': string | null;
    /**
     * 
     * @type {string}
     * @memberof GameCodeDetailed
     */
    'userId': string | null;
    /**
     * 
     * @type {User}
     * @memberof GameCodeDetailed
     */
    'user'?: User | null;
    /**
     * 
     * @type {string}
     * @memberof GameCodeDetailed
     */
    'eventId': string | null;
    /**
     * 
     * @type {Event}
     * @memberof GameCodeDetailed
     */
    'event'?: Event;
    /**
     * 
     * @type {string}
     * @memberof GameCodeDetailed
     */
    'gameId': string;
    /**
     * 
     * @type {Game}
     * @memberof GameCodeDetailed
     */
    'game'?: Game;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const GameCodeStatus = {
    Used: 'USED',
    NotUsed: 'NOT_USED'
} as const;

export type GameCodeStatus = typeof GameCodeStatus[keyof typeof GameCodeStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const GameCodeType = {
    Linking: 'LINKING',
    LeaderboardWin: 'LEADERBOARD_WIN'
} as const;

export type GameCodeType = typeof GameCodeType[keyof typeof GameCodeType];


/**
 * 
 * @export
 * @interface GameDetailed
 */
export interface GameDetailed {
    /**
     * 
     * @type {string}
     * @memberof GameDetailed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GameDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GameDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GameDetailed
     */
    'studioId': string;
    /**
     * 
     * @type {string}
     * @memberof GameDetailed
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GameDetailed
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof GameDetailed
     */
    'iconUrl': string;
    /**
     * 
     * @type {string}
     * @memberof GameDetailed
     */
    'clientId': string | null;
    /**
     * 
     * @type {CreateEventGameAccess}
     * @memberof GameDetailed
     */
    'createAccess': CreateEventGameAccess;
    /**
     * 
     * @type {string}
     * @memberof GameDetailed
     */
    'createEventImageUrl': string | null;
    /**
     * 
     * @type {Array<ApiKey>}
     * @memberof GameDetailed
     */
    'apiKeys'?: Array<ApiKey>;
    /**
     * 
     * @type {Array<Leaderboard>}
     * @memberof GameDetailed
     */
    'leaderboards'?: Array<Leaderboard>;
    /**
     * 
     * @type {Array<UserInstalledGames>}
     * @memberof GameDetailed
     */
    'userInstalledGames'?: Array<UserInstalledGames>;
    /**
     * 
     * @type {Array<Quest>}
     * @memberof GameDetailed
     */
    'quests'?: Array<Quest>;
    /**
     * 
     * @type {Array<GameCode>}
     * @memberof GameDetailed
     */
    'gameCode'?: Array<GameCode>;
    /**
     * 
     * @type {Array<Event>}
     * @memberof GameDetailed
     */
    'events'?: Array<Event>;
    /**
     * 
     * @type {Array<SocialLink>}
     * @memberof GameDetailed
     */
    'links': Array<SocialLink>;
    /**
     * 
     * @type {Array<EventNew>}
     * @memberof GameDetailed
     */
    'eventNew'?: Array<EventNew>;
    /**
     * 
     * @type {Array<GameMode>}
     * @memberof GameDetailed
     */
    'gameModes'?: Array<GameMode>;
    /**
     * 
     * @type {Array<GameQuestTemplate>}
     * @memberof GameDetailed
     */
    'gameQuestTemplates'?: Array<GameQuestTemplate>;
    /**
     * 
     * @type {Array<Banner>}
     * @memberof GameDetailed
     */
    'banners': Array<Banner>;
}


/**
 * 
 * @export
 * @interface GameLinks
 */
export interface GameLinks {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof GameLinks
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GameLinks
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GameLinks
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GameLinks
     */
    'gameId': string;
    /**
     * 
     * @type {Game}
     * @memberof GameLinks
     */
    'game'?: Game | null;
    /**
     * 
     * @type {LinkType}
     * @memberof GameLinks
     */
    'linkType': LinkType;
    /**
     * 
     * @type {string}
     * @memberof GameLinks
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof GameLinks
     */
    'order': number;
    /**
     * 
     * @type {AccessStatus}
     * @memberof GameLinks
     */
    'status': AccessStatus;
}


/**
 * 
 * @export
 * @interface GameMode
 */
export interface GameMode {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof GameMode
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GameMode
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GameMode
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GameMode
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GameMode
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GameMode
     */
    'imageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof GameMode
     */
    'mappingId': string;
    /**
     * 
     * @type {string}
     * @memberof GameMode
     */
    'scoreTextAlias': string;
    /**
     * 
     * @type {string}
     * @memberof GameMode
     */
    'altScoreTextAlias': string | null;
    /**
     * 
     * @type {string}
     * @memberof GameMode
     */
    'gameId': string;
    /**
     * 
     * @type {Game}
     * @memberof GameMode
     */
    'game'?: Game | null;
    /**
     * 
     * @type {Array<LeaderboardFactorNew>}
     * @memberof GameMode
     */
    'leaderboardFactors'?: Array<LeaderboardFactorNew>;
}
/**
 * 
 * @export
 * @interface GameQuestTemplate
 */
export interface GameQuestTemplate {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof GameQuestTemplate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GameQuestTemplate
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GameQuestTemplate
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GameQuestTemplate
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GameQuestTemplate
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GameQuestTemplate
     */
    'imageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof GameQuestTemplate
     */
    'mappingId': string;
    /**
     * 
     * @type {ActivityType}
     * @memberof GameQuestTemplate
     */
    'activityType': ActivityType;
    /**
     * 
     * @type {QuestType}
     * @memberof GameQuestTemplate
     */
    'questType': QuestType;
    /**
     * 
     * @type {number}
     * @memberof GameQuestTemplate
     */
    'target': number;
    /**
     * 
     * @type {QuestDifficulty}
     * @memberof GameQuestTemplate
     */
    'difficulty': QuestDifficulty;
    /**
     * 
     * @type {string}
     * @memberof GameQuestTemplate
     */
    'gameId': string;
    /**
     * 
     * @type {Game}
     * @memberof GameQuestTemplate
     */
    'game'?: Game;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const Gender = {
    Male: 'male',
    Female: 'female',
    Other: 'other',
    Unknown: 'unknown'
} as const;

export type Gender = typeof Gender[keyof typeof Gender];


/**
 * numOfCodes: the number of codes to generate, eventId: the id of the event to generate codes for
 * @export
 * @interface GenerateLeaderboardWinCodesRequest
 */
export interface GenerateLeaderboardWinCodesRequest {
    /**
     * 
     * @type {string}
     * @memberof GenerateLeaderboardWinCodesRequest
     */
    'eventId': string;
    /**
     * 
     * @type {number}
     * @memberof GenerateLeaderboardWinCodesRequest
     */
    'numOfCodes': number;
}
/**
 * 
 * @export
 * @interface GetEventDetailedResponse
 */
export interface GetEventDetailedResponse {
    /**
     * 
     * @type {Array<GetQuestResponse>}
     * @memberof GetEventDetailedResponse
     */
    'socialQuests': Array<GetQuestResponse>;
    /**
     * 
     * @type {Array<GetQuestResponse>}
     * @memberof GetEventDetailedResponse
     */
    'gameQuests': Array<GetQuestResponse>;
    /**
     * 
     * @type {GetEventDetailedResponseLeaderboard}
     * @memberof GetEventDetailedResponse
     */
    'leaderboard': GetEventDetailedResponseLeaderboard;
    /**
     * 
     * @type {Array<GetEventDetailedResponseRaffleInner>}
     * @memberof GetEventDetailedResponse
     */
    'raffle': Array<GetEventDetailedResponseRaffleInner>;
    /**
     * 
     * @type {Array<PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt>}
     * @memberof GetEventDetailedResponse
     */
    'banners': Array<PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt>;
    /**
     * 
     * @type {PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId}
     * @memberof GetEventDetailedResponse
     */
    'event': PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId;
}
/**
 * 
 * @export
 * @interface GetEventDetailedResponseLeaderboard
 */
export interface GetEventDetailedResponseLeaderboard {
    /**
     * 
     * @type {Array<GetEventDetailedResponseLeaderboardRewardsInner>}
     * @memberof GetEventDetailedResponseLeaderboard
     */
    'rewards': Array<GetEventDetailedResponseLeaderboardRewardsInner>;
    /**
     * 
     * @type {boolean}
     * @memberof GetEventDetailedResponseLeaderboard
     */
    'rewardsProcessed': boolean | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseLeaderboard
     */
    'endTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseLeaderboard
     */
    'startTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseLeaderboard
     */
    'scheduleId': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseLeaderboard
     */
    'objectId': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseLeaderboard
     */
    'type': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseLeaderboard
     */
    'factorId': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseLeaderboard
     */
    'scoreTextAlias': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseLeaderboard
     */
    'id': string | null;
}
/**
 * 
 * @export
 * @interface GetEventDetailedResponseLeaderboardRewardsInner
 */
export interface GetEventDetailedResponseLeaderboardRewardsInner {
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseLeaderboardRewardsInner
     */
    'productType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseLeaderboardRewardsInner
     */
    'productImageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseLeaderboardRewardsInner
     */
    'productSubtitle'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseLeaderboardRewardsInner
     */
    'productTitle'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetEventDetailedResponseLeaderboardRewardsInner
     */
    'rewardPlace': number;
    /**
     * 
     * @type {number}
     * @memberof GetEventDetailedResponseLeaderboardRewardsInner
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseLeaderboardRewardsInner
     */
    'productId': string;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseLeaderboardRewardsInner
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetEventDetailedResponseRaffleInner
 */
export interface GetEventDetailedResponseRaffleInner {
    /**
     * 
     * @type {Array<GetEventDetailedResponseRaffleInnerRewardsInner>}
     * @memberof GetEventDetailedResponseRaffleInner
     */
    'rewards': Array<GetEventDetailedResponseRaffleInnerRewardsInner>;
    /**
     * 
     * @type {boolean}
     * @memberof GetEventDetailedResponseRaffleInner
     */
    'shouldExcludePreviousWinners': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseRaffleInner
     */
    'raffleTicketProductId': string;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseRaffleInner
     */
    'endTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseRaffleInner
     */
    'startTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseRaffleInner
     */
    'scheduleId': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseRaffleInner
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetEventDetailedResponseRaffleInnerRewardsInner
 */
export interface GetEventDetailedResponseRaffleInnerRewardsInner {
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseRaffleInnerRewardsInner
     */
    'productType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseRaffleInnerRewardsInner
     */
    'productImageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseRaffleInnerRewardsInner
     */
    'productSubtitle'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseRaffleInnerRewardsInner
     */
    'productTitle'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetEventDetailedResponseRaffleInnerRewardsInner
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseRaffleInnerRewardsInner
     */
    'prizeProductId': string;
    /**
     * 
     * @type {string}
     * @memberof GetEventDetailedResponseRaffleInnerRewardsInner
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetEventWithLobbyDetailsResponse
 */
export interface GetEventWithLobbyDetailsResponse {
    /**
     * 
     * @type {number}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'joiningFee': number;
    /**
     * 
     * @type {string}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'statusText'?: string;
    /**
     * 
     * @type {Array<LobbyItems>}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'lobbyItems': Array<LobbyItems>;
    /**
     * 
     * @type {Array<LobbyPrize>}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'lobbyPrizes': Array<LobbyPrize>;
    /**
     * 
     * @type {Array<SocialLink>}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'gameLinks': Array<SocialLink>;
    /**
     * 
     * @type {Array<Banner>}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'banners': Array<Banner>;
    /**
     * 
     * @type {Array<Quest>}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'quest': Array<Quest>;
    /**
     * 
     * @type {Array<Leaderboard>}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'leaderboards': Array<Leaderboard>;
    /**
     * 
     * @type {Array<Draw>}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'draws': Array<Draw>;
    /**
     * 
     * @type {Game}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'game': Game;
    /**
     * 
     * @type {string}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'gameId': string;
    /**
     * 
     * @type {string}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'videoUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'youtubeId': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'mapCode': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'imageUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'subtitle': string;
    /**
     * 
     * @type {string}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'title': string;
    /**
     * 
     * @type {EventStatus}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'status': EventStatus;
    /**
     * 
     * @type {string}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'endTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'startTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetEventWithLobbyDetailsResponse
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface GetExternalApiKeyResponse
 */
export interface GetExternalApiKeyResponse {
    /**
     * 
     * @type {string}
     * @memberof GetExternalApiKeyResponse
     */
    'gameId': string;
    /**
     * 
     * @type {AccessStatus}
     * @memberof GetExternalApiKeyResponse
     */
    'status': AccessStatus;
    /**
     * 
     * @type {string}
     * @memberof GetExternalApiKeyResponse
     */
    'expireAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetExternalApiKeyResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof GetExternalApiKeyResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetExternalApiKeyResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetExternalApiKeyResponse
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface GetGameApiKeysResponse
 */
export interface GetGameApiKeysResponse {
    /**
     * 
     * @type {string}
     * @memberof GetGameApiKeysResponse
     */
    'expireAt': string | null;
    /**
     * 
     * @type {AccessStatus}
     * @memberof GetGameApiKeysResponse
     */
    'status': AccessStatus;
    /**
     * 
     * @type {string}
     * @memberof GetGameApiKeysResponse
     */
    'gameId': string;
    /**
     * 
     * @type {string}
     * @memberof GetGameApiKeysResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof GetGameApiKeysResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetGameApiKeysResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetGameApiKeysResponse
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface GetGameLinksResponse
 */
export interface GetGameLinksResponse {
    /**
     * 
     * @type {AccessStatus}
     * @memberof GetGameLinksResponse
     */
    'status': AccessStatus;
    /**
     * 
     * @type {number}
     * @memberof GetGameLinksResponse
     */
    'order': number;
    /**
     * 
     * @type {string}
     * @memberof GetGameLinksResponse
     */
    'url': string;
    /**
     * 
     * @type {LinkType}
     * @memberof GetGameLinksResponse
     */
    'linkType': LinkType;
    /**
     * 
     * @type {string}
     * @memberof GetGameLinksResponse
     */
    'gameId': string;
    /**
     * 
     * @type {string}
     * @memberof GetGameLinksResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetGameLinksResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetGameLinksResponse
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface GetGameResponseDetailed
 */
export interface GetGameResponseDetailed {
    /**
     * 
     * @type {Array<GetGameApiKeysResponse>}
     * @memberof GetGameResponseDetailed
     */
    'apiKeys': Array<GetGameApiKeysResponse>;
    /**
     * 
     * @type {Array<GetGameLinksResponse>}
     * @memberof GetGameResponseDetailed
     */
    'links': Array<GetGameLinksResponse>;
    /**
     * 
     * @type {string}
     * @memberof GetGameResponseDetailed
     */
    'clientId': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetGameResponseDetailed
     */
    'createEventImageUrl': string | null;
    /**
     * 
     * @type {CreateEventGameAccess}
     * @memberof GetGameResponseDetailed
     */
    'createAccess': CreateEventGameAccess;
    /**
     * 
     * @type {string}
     * @memberof GetGameResponseDetailed
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetGameResponseDetailed
     */
    'iconUrl': string;
    /**
     * 
     * @type {string}
     * @memberof GetGameResponseDetailed
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GetGameResponseDetailed
     */
    'studioId': string;
    /**
     * 
     * @type {string}
     * @memberof GetGameResponseDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetGameResponseDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetGameResponseDetailed
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface GetGamesResponse
 */
export interface GetGamesResponse {
    /**
     * 
     * @type {string}
     * @memberof GetGamesResponse
     */
    'clientId': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetGamesResponse
     */
    'createEventImageUrl': string | null;
    /**
     * 
     * @type {CreateEventGameAccess}
     * @memberof GetGamesResponse
     */
    'createAccess': CreateEventGameAccess;
    /**
     * 
     * @type {string}
     * @memberof GetGamesResponse
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetGamesResponse
     */
    'iconUrl': string;
    /**
     * 
     * @type {string}
     * @memberof GetGamesResponse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GetGamesResponse
     */
    'studioId': string;
    /**
     * 
     * @type {string}
     * @memberof GetGamesResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetGamesResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetGamesResponse
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface GetLeaderboardResponse
 */
export interface GetLeaderboardResponse {
    /**
     * 
     * @type {Array<PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct>}
     * @memberof GetLeaderboardResponse
     */
    'leaderboardRewards': Array<PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct>;
    /**
     * 
     * @type {GetLeaderboardResponseLeaderboardSchedule}
     * @memberof GetLeaderboardResponse
     */
    'leaderboardSchedule': GetLeaderboardResponseLeaderboardSchedule;
    /**
     * 
     * @type {GetLeaderboardResponseLeaderboardFactor}
     * @memberof GetLeaderboardResponse
     */
    'leaderboardFactor': GetLeaderboardResponseLeaderboardFactor;
    /**
     * 
     * @type {LeaderboardDisplay}
     * @memberof GetLeaderboardResponse
     */
    'leaderboardDisplay': LeaderboardDisplay | null;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponse
     */
    'gameId': string;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponse
     */
    'eventId': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponse
     */
    'scoreTextAlias': string;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponse
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface GetLeaderboardResponseLeaderboardFactor
 */
export interface GetLeaderboardResponseLeaderboardFactor {
    /**
     * 
     * @type {LeaderboardFactorType}
     * @memberof GetLeaderboardResponseLeaderboardFactor
     */
    'type': LeaderboardFactorType;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponseLeaderboardFactor
     */
    'objectId': string;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponseLeaderboardFactor
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponseLeaderboardFactor
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponseLeaderboardFactor
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface GetLeaderboardResponseLeaderboardSchedule
 */
export interface GetLeaderboardResponseLeaderboardSchedule {
    /**
     * 
     * @type {boolean}
     * @memberof GetLeaderboardResponseLeaderboardSchedule
     */
    'rewardsProcessed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetLeaderboardResponseLeaderboardSchedule
     */
    'scheduleProcessed': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponseLeaderboardSchedule
     */
    'endTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponseLeaderboardSchedule
     */
    'startTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponseLeaderboardSchedule
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponseLeaderboardSchedule
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetLeaderboardResponseLeaderboardSchedule
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetLeaderboardRewardSummaryResponse
 */
export interface GetLeaderboardRewardSummaryResponse {
    /**
     * 
     * @type {PickProductIdOrTitleOrSubTitleOrIconUrlOrType}
     * @memberof GetLeaderboardRewardSummaryResponse
     */
    'product': PickProductIdOrTitleOrSubTitleOrIconUrlOrType;
    /**
     * 
     * @type {number}
     * @memberof GetLeaderboardRewardSummaryResponse
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof GetLeaderboardRewardSummaryResponse
     */
    'endingPlace': number;
    /**
     * 
     * @type {number}
     * @memberof GetLeaderboardRewardSummaryResponse
     */
    'startingPlace': number;
}
/**
 * 
 * @export
 * @interface GetQuestResponse
 */
export interface GetQuestResponse {
    /**
     * 
     * @type {Array<GetQuestResponseGoalsInner>}
     * @memberof GetQuestResponse
     */
    'goals': Array<GetQuestResponseGoalsInner>;
    /**
     * 
     * @type {QuestType}
     * @memberof GetQuestResponse
     */
    'questType': QuestType;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponse
     */
    'endTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponse
     */
    'startTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponse
     */
    'scheduleId': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponse
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface GetQuestResponseGoalsInner
 */
export interface GetQuestResponseGoalsInner {
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponseGoalsInner
     */
    'rewardProductType': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponseGoalsInner
     */
    'rewardProductImageUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponseGoalsInner
     */
    'rewardProductSubtitle': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponseGoalsInner
     */
    'rewardProductTitle': string | null;
    /**
     * 
     * @type {number}
     * @memberof GetQuestResponseGoalsInner
     */
    'rewardQuantity': number | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponseGoalsInner
     */
    'rewardProductId': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponseGoalsInner
     */
    'goalProductId': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponseGoalsInner
     */
    'openUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponseGoalsInner
     */
    'objectId': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponseGoalsInner
     */
    'bannerUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponseGoalsInner
     */
    'instructions': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponseGoalsInner
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponseGoalsInner
     */
    'activity': string;
    /**
     * 
     * @type {number}
     * @memberof GetQuestResponseGoalsInner
     */
    'target': number;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponseGoalsInner
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GetQuestResponseGoalsInner
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetQuestRewardResponse
 */
export interface GetQuestRewardResponse {
    /**
     * 
     * @type {string}
     * @memberof GetQuestRewardResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetQuestRewardResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetQuestRewardResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof GetQuestRewardResponse
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof GetQuestRewardResponse
     */
    'productId': string;
    /**
     * 
     * @type {string}
     * @memberof GetQuestRewardResponse
     */
    'goalId': string;
    /**
     * 
     * @type {PickProductIdOrCreatedAtOrUpdatedAtOrTitleOrSubTitleOrIconUrlOrType}
     * @memberof GetQuestRewardResponse
     */
    'product': PickProductIdOrCreatedAtOrUpdatedAtOrTitleOrSubTitleOrIconUrlOrType;
}
/**
 * 
 * @export
 * @interface GetQuestScheduleResponse
 */
export interface GetQuestScheduleResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetQuestScheduleResponse
     */
    'processed': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetQuestScheduleResponse
     */
    'endTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetQuestScheduleResponse
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof GetQuestScheduleResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetQuestScheduleResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetQuestScheduleResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetRaffleResultsResponse
 */
export interface GetRaffleResultsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetRaffleResultsResponse
     */
    'rewardIconUrl'?: string | null;
    /**
     * 
     * @type {ProductType}
     * @memberof GetRaffleResultsResponse
     */
    'rewardType'?: ProductType;
    /**
     * 
     * @type {string}
     * @memberof GetRaffleResultsResponse
     */
    'rewardSubTitle'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetRaffleResultsResponse
     */
    'rewardTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRaffleResultsResponse
     */
    'rewardId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRaffleResultsResponse
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetRaffleResultsResponse
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRaffleResultsResponse
     */
    'userId': string;
    /**
     * 
     * @type {UserDrawStatus}
     * @memberof GetRaffleResultsResponse
     */
    'status': UserDrawStatus;
    /**
     * 
     * @type {string}
     * @memberof GetRaffleResultsResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetRaffleResultsResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetRaffleResultsResponse
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface GetToken200Response
 */
export interface GetToken200Response {
    /**
     * 
     * @type {string}
     * @memberof GetToken200Response
     */
    'token_type': string;
    /**
     * 
     * @type {number}
     * @memberof GetToken200Response
     */
    'expires_in': number;
    /**
     * 
     * @type {string}
     * @memberof GetToken200Response
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface GetUserConnectionResponse
 */
export interface GetUserConnectionResponse {
    /**
     * 
     * @type {string}
     * @memberof GetUserConnectionResponse
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserConnectionResponse
     */
    'sub': string | null;
    /**
     * 
     * @type {ConnectionType}
     * @memberof GetUserConnectionResponse
     */
    'socialConnectionType': ConnectionType;
    /**
     * 
     * @type {string}
     * @memberof GetUserConnectionResponse
     */
    'nickname': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetUserConnectionResponse
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetUserConnectionResponse
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface GetUserJoinedStatus200Response
 */
export interface GetUserJoinedStatus200Response {
    /**
     * 
     * @type {string}
     * @memberof GetUserJoinedStatus200Response
     */
    'timestamp': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetUserJoinedStatus200Response
     */
    'joined': boolean;
}
/**
 * 
 * @export
 * @interface GetUserRole
 */
export interface GetUserRole {
    /**
     * 
     * @type {string}
     * @memberof GetUserRole
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserRole
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserRole
     */
    'updatedAt': string;
    /**
     * 
     * @type {UserRoleType}
     * @memberof GetUserRole
     */
    'role': UserRoleType;
    /**
     * 
     * @type {string}
     * @memberof GetUserRole
     */
    'userId': string;
    /**
     * 
     * @type {PickUserIdOrEmailOrUsername}
     * @memberof GetUserRole
     */
    'user': PickUserIdOrEmailOrUsername;
}


/**
 * 
 * @export
 * @interface Goal
 */
export interface Goal {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof Goal
     */
    'target': number;
    /**
     * 
     * @type {ActivityType}
     * @memberof Goal
     */
    'activity': ActivityType;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'instructions': string | null;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'bannerUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'objectId': string | null;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'openUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'questId': string;
    /**
     * 
     * @type {Quest}
     * @memberof Goal
     */
    'quest'?: Quest | null;
    /**
     * 
     * @type {Array<GoalAttribute>}
     * @memberof Goal
     */
    'goalAttributes'?: Array<GoalAttribute>;
    /**
     * 
     * @type {Array<GoalProduct>}
     * @memberof Goal
     */
    'goalProducts'?: Array<GoalProduct>;
}


/**
 * 
 * @export
 * @interface GoalAttribute
 */
export interface GoalAttribute {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof GoalAttribute
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GoalAttribute
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GoalAttribute
     */
    'updatedAt': string;
    /**
     * 
     * @type {GoalAttributeKey}
     * @memberof GoalAttribute
     */
    'key': GoalAttributeKey;
    /**
     * 
     * @type {string}
     * @memberof GoalAttribute
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof GoalAttribute
     */
    'goalId': string;
    /**
     * 
     * @type {Goal}
     * @memberof GoalAttribute
     */
    'goal'?: Goal;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const GoalAttributeKey = {
    TargetUserId: 'TARGET_USER_ID'
} as const;

export type GoalAttributeKey = typeof GoalAttributeKey[keyof typeof GoalAttributeKey];


/**
 * 
 * @export
 * @interface GoalProduct
 */
export interface GoalProduct {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof GoalProduct
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GoalProduct
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GoalProduct
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof GoalProduct
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof GoalProduct
     */
    'goalId': string;
    /**
     * 
     * @type {Goal}
     * @memberof GoalProduct
     */
    'goal'?: Goal;
    /**
     * 
     * @type {string}
     * @memberof GoalProduct
     */
    'productId': string;
    /**
     * 
     * @type {Product}
     * @memberof GoalProduct
     */
    'product'?: Product;
}
/**
 * 
 * @export
 * @interface GoalWithProgress
 */
export interface GoalWithProgress {
    /**
     * 
     * @type {ActivityType}
     * @memberof GoalWithProgress
     */
    'activityType': ActivityType;
    /**
     * 
     * @type {Progress}
     * @memberof GoalWithProgress
     */
    'progress': Progress | null;
    /**
     * 
     * @type {GoalWithProgressReward}
     * @memberof GoalWithProgress
     */
    'reward': GoalWithProgressReward | null;
    /**
     * 
     * @type {string}
     * @memberof GoalWithProgress
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof GoalWithProgress
     */
    'openUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof GoalWithProgress
     */
    'bannerUrl': string | null;
    /**
     * 
     * @type {number}
     * @memberof GoalWithProgress
     */
    'target': number;
    /**
     * 
     * @type {string}
     * @memberof GoalWithProgress
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof GoalWithProgress
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface GoalWithProgressReward
 */
export interface GoalWithProgressReward {
    /**
     * 
     * @type {string}
     * @memberof GoalWithProgressReward
     */
    'gameId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoalWithProgressReward
     */
    'iconUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoalWithProgressReward
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoalWithProgressReward
     */
    'subTitle'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoalWithProgressReward
     */
    'title'?: string;
    /**
     * 
     * @type {ProductType}
     * @memberof GoalWithProgressReward
     */
    'productType'?: ProductType;
    /**
     * 
     * @type {string}
     * @memberof GoalWithProgressReward
     */
    'productId'?: string;
    /**
     * 
     * @type {number}
     * @memberof GoalWithProgressReward
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof GoalWithProgressReward
     */
    'id'?: string;
}


/**
 * 
 * @export
 * @interface InventoryItemCount
 */
export interface InventoryItemCount {
    /**
     * 
     * @type {number}
     * @memberof InventoryItemCount
     */
    'userEntries': number;
    /**
     * 
     * @type {number}
     * @memberof InventoryItemCount
     */
    'totalEntries': number;
}
/**
 * 
 * @export
 * @interface Leaderboard
 */
export interface Leaderboard {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Leaderboard
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Leaderboard
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Leaderboard
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Leaderboard
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Leaderboard
     */
    'scoreTextAlias': string;
    /**
     * 
     * @type {string}
     * @memberof Leaderboard
     */
    'altScoreTextAlias': string | null;
    /**
     * 
     * @type {string}
     * @memberof Leaderboard
     */
    'eventId': string | null;
    /**
     * 
     * @type {Event}
     * @memberof Leaderboard
     */
    'event'?: Event | null;
    /**
     * 
     * @type {string}
     * @memberof Leaderboard
     */
    'gameId': string;
    /**
     * 
     * @type {Game}
     * @memberof Leaderboard
     */
    'game'?: Game;
    /**
     * 
     * @type {Array<LeaderboardSchedule>}
     * @memberof Leaderboard
     */
    'leaderboardSchedules'?: Array<LeaderboardSchedule>;
    /**
     * 
     * @type {Array<LeaderboardFactor>}
     * @memberof Leaderboard
     */
    'leaderboardFactors'?: Array<LeaderboardFactor>;
    /**
     * 
     * @type {LeaderboardDisplay}
     * @memberof Leaderboard
     */
    'leaderboardDisplay': LeaderboardDisplay | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const LeaderboardDisplay = {
    V1: 'V1',
    Hidden: 'HIDDEN'
} as const;

export type LeaderboardDisplay = typeof LeaderboardDisplay[keyof typeof LeaderboardDisplay];


/**
 * 
 * @export
 * @interface LeaderboardFactor
 */
export interface LeaderboardFactor {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof LeaderboardFactor
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardFactor
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardFactor
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardFactor
     */
    'objectId': string;
    /**
     * 
     * @type {LeaderboardFactorType}
     * @memberof LeaderboardFactor
     */
    'type': LeaderboardFactorType;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardFactor
     */
    'leaderboardId': string;
    /**
     * 
     * @type {Leaderboard}
     * @memberof LeaderboardFactor
     */
    'leaderboard'?: Leaderboard;
}


/**
 * 
 * @export
 * @interface LeaderboardFactorNew
 */
export interface LeaderboardFactorNew {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof LeaderboardFactorNew
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardFactorNew
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardFactorNew
     */
    'updatedAt': string;
    /**
     * 
     * @type {LeaderboardFactorType}
     * @memberof LeaderboardFactorNew
     */
    'type': LeaderboardFactorType;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardFactorNew
     */
    'gameModeId': string;
    /**
     * 
     * @type {GameMode}
     * @memberof LeaderboardFactorNew
     */
    'gameMode'?: GameMode | null;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardFactorNew
     */
    'leaderboardId': string;
    /**
     * 
     * @type {LeaderboardNew}
     * @memberof LeaderboardFactorNew
     */
    'leaderboard'?: LeaderboardNew;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const LeaderboardFactorType = {
    Cumulative: 'CUMULATIVE',
    Milestone: 'MILESTONE',
    QuestCompleted: 'QUEST_COMPLETED'
} as const;

export type LeaderboardFactorType = typeof LeaderboardFactorType[keyof typeof LeaderboardFactorType];


/**
 * 
 * @export
 * @interface LeaderboardNew
 */
export interface LeaderboardNew {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof LeaderboardNew
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardNew
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardNew
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardNew
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardNew
     */
    'scoreTextAlias': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardNew
     */
    'altScoreTextAlias': string | null;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardNew
     */
    'eventId': string | null;
    /**
     * 
     * @type {EventNew}
     * @memberof LeaderboardNew
     */
    'event'?: EventNew | null;
    /**
     * 
     * @type {Array<LeaderboardFactorNew>}
     * @memberof LeaderboardNew
     */
    'leaderboardFactors'?: Array<LeaderboardFactorNew>;
}
/**
 * 
 * @export
 * @interface LeaderboardResult
 */
export interface LeaderboardResult {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof LeaderboardResult
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardResult
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardResult
     */
    'updatedAt': string;
    /**
     * 
     * @type {UserDrawStatus}
     * @memberof LeaderboardResult
     */
    'status': UserDrawStatus;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardResult
     */
    'userId': string;
    /**
     * 
     * @type {User}
     * @memberof LeaderboardResult
     */
    'user'?: User | null;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardResult
     */
    'leaderboardScheduleId': string;
    /**
     * 
     * @type {LeaderboardSchedule}
     * @memberof LeaderboardResult
     */
    'leaderboardSchedule'?: LeaderboardSchedule | null;
    /**
     * 
     * @type {Array<LeaderboardReward>}
     * @memberof LeaderboardResult
     */
    'leaderboardRewards'?: Array<LeaderboardReward>;
}


/**
 * 
 * @export
 * @interface LeaderboardReward
 */
export interface LeaderboardReward {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof LeaderboardReward
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardReward
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardReward
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardReward
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardReward
     */
    'rewardPlace': number;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardReward
     */
    'leaderboardScheduleId': string;
    /**
     * 
     * @type {LeaderboardSchedule}
     * @memberof LeaderboardReward
     */
    'leaderboardSchedule'?: LeaderboardSchedule;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardReward
     */
    'productId': string;
    /**
     * 
     * @type {Product}
     * @memberof LeaderboardReward
     */
    'product'?: Product;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardReward
     */
    'leaderboardResultId': string | null;
    /**
     * 
     * @type {LeaderboardResult}
     * @memberof LeaderboardReward
     */
    'leaderboardResult'?: LeaderboardResult | null;
}
/**
 * 
 * @export
 * @interface LeaderboardRewardDetailed
 */
export interface LeaderboardRewardDetailed {
    /**
     * 
     * @type {string}
     * @memberof LeaderboardRewardDetailed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardRewardDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardRewardDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardRewardDetailed
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardRewardDetailed
     */
    'rewardPlace': number;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardRewardDetailed
     */
    'leaderboardScheduleId': string;
    /**
     * 
     * @type {LeaderboardSchedule}
     * @memberof LeaderboardRewardDetailed
     */
    'leaderboardSchedule'?: LeaderboardSchedule;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardRewardDetailed
     */
    'productId': string;
    /**
     * 
     * @type {LeaderboardRewardDetailedAllOfProduct}
     * @memberof LeaderboardRewardDetailed
     */
    'product': LeaderboardRewardDetailedAllOfProduct;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardRewardDetailed
     */
    'leaderboardResultId': string | null;
    /**
     * 
     * @type {LeaderboardResult}
     * @memberof LeaderboardRewardDetailed
     */
    'leaderboardResult'?: LeaderboardResult | null;
}
/**
 * 
 * @export
 * @interface LeaderboardRewardDetailedAllOfProduct
 */
export interface LeaderboardRewardDetailedAllOfProduct {
    /**
     * 
     * @type {ProductType}
     * @memberof LeaderboardRewardDetailedAllOfProduct
     */
    'type': ProductType;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardRewardDetailedAllOfProduct
     */
    'iconUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardRewardDetailedAllOfProduct
     */
    'subTitle'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardRewardDetailedAllOfProduct
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardRewardDetailedAllOfProduct
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface LeaderboardSchedule
 */
export interface LeaderboardSchedule {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof LeaderboardSchedule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardSchedule
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardSchedule
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardSchedule
     */
    'startTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardSchedule
     */
    'endTime': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LeaderboardSchedule
     */
    'recurring': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LeaderboardSchedule
     */
    'scheduleProcessed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LeaderboardSchedule
     */
    'rewardsProcessed': boolean;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardSchedule
     */
    'leaderboardId': string;
    /**
     * 
     * @type {Leaderboard}
     * @memberof LeaderboardSchedule
     */
    'leaderboard'?: Leaderboard;
    /**
     * 
     * @type {Array<LeaderboardReward>}
     * @memberof LeaderboardSchedule
     */
    'leaderboardRewards'?: Array<LeaderboardReward>;
    /**
     * 
     * @type {Array<LeaderboardScore>}
     * @memberof LeaderboardSchedule
     */
    'scores'?: Array<LeaderboardScore>;
    /**
     * 
     * @type {Array<LeaderboardResult>}
     * @memberof LeaderboardSchedule
     */
    'leaderboardResults'?: Array<LeaderboardResult>;
}
/**
 * 
 * @export
 * @interface LeaderboardScheduleDetailed
 */
export interface LeaderboardScheduleDetailed {
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScheduleDetailed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScheduleDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScheduleDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScheduleDetailed
     */
    'startTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScheduleDetailed
     */
    'endTime': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LeaderboardScheduleDetailed
     */
    'recurring': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LeaderboardScheduleDetailed
     */
    'scheduleProcessed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LeaderboardScheduleDetailed
     */
    'rewardsProcessed': boolean;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScheduleDetailed
     */
    'leaderboardId': string;
    /**
     * 
     * @type {Leaderboard}
     * @memberof LeaderboardScheduleDetailed
     */
    'leaderboard': Leaderboard;
    /**
     * 
     * @type {Array<LeaderboardRewardDetailed>}
     * @memberof LeaderboardScheduleDetailed
     */
    'leaderboardRewards': Array<LeaderboardRewardDetailed>;
    /**
     * 
     * @type {Array<LeaderboardScoreDetailed>}
     * @memberof LeaderboardScheduleDetailed
     */
    'scores': Array<LeaderboardScoreDetailed>;
    /**
     * 
     * @type {Array<LeaderboardResult>}
     * @memberof LeaderboardScheduleDetailed
     */
    'leaderboardResults'?: Array<LeaderboardResult>;
}
/**
 * 
 * @export
 * @interface LeaderboardScore
 */
export interface LeaderboardScore {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof LeaderboardScore
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScore
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScore
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardScore
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScore
     */
    'playerId': string;
    /**
     * 
     * @type {User}
     * @memberof LeaderboardScore
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScore
     */
    'leaderboardScheduleId': string;
    /**
     * 
     * @type {LeaderboardSchedule}
     * @memberof LeaderboardScore
     */
    'leaderboardSchedule'?: LeaderboardSchedule;
}
/**
 * 
 * @export
 * @interface LeaderboardScoreDetailed
 */
export interface LeaderboardScoreDetailed {
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScoreDetailed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScoreDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScoreDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof LeaderboardScoreDetailed
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScoreDetailed
     */
    'playerId': string;
    /**
     * 
     * @type {UserDetailed}
     * @memberof LeaderboardScoreDetailed
     */
    'user': UserDetailed;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardScoreDetailed
     */
    'leaderboardScheduleId': string;
    /**
     * 
     * @type {LeaderboardSchedule}
     * @memberof LeaderboardScoreDetailed
     */
    'leaderboardSchedule'?: LeaderboardSchedule;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LinkType = {
    X: 'X',
    Discord: 'DISCORD',
    Website: 'WEBSITE',
    Facebook: 'FACEBOOK',
    Youtube: 'YOUTUBE',
    Linkedin: 'LINKEDIN',
    Instagram: 'INSTAGRAM',
    Tiktok: 'TIKTOK',
    Reddit: 'REDDIT',
    Twitch: 'TWITCH',
    Game: 'GAME'
} as const;

export type LinkType = typeof LinkType[keyof typeof LinkType];


/**
 * 
 * @export
 * @interface LinkedAccount
 */
export interface LinkedAccount {
    /**
     * 
     * @type {Game}
     * @memberof LinkedAccount
     */
    'game': Game;
    /**
     * 
     * @type {User}
     * @memberof LinkedAccount
     */
    'externalUser': User;
}
/**
 * 
 * @export
 * @interface LobbyItems
 */
export interface LobbyItems {
    /**
     * 
     * @type {string}
     * @memberof LobbyItems
     */
    'value': string | null;
    /**
     * 
     * @type {string}
     * @memberof LobbyItems
     */
    'key': LobbyItemsKeyEnum;
}

export const LobbyItemsKeyEnum = {
    GameMode: 'Game Mode',
    PrizePool: 'Prize Pool',
    Raffle: 'Raffle',
    Joiners: 'Joiners'
} as const;

export type LobbyItemsKeyEnum = typeof LobbyItemsKeyEnum[keyof typeof LobbyItemsKeyEnum];

/**
 * 
 * @export
 * @interface LobbyPrize
 */
export interface LobbyPrize {
    /**
     * 
     * @type {string}
     * @memberof LobbyPrize
     */
    'assetType': LobbyPrizeAssetTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof LobbyPrize
     */
    'unit': string;
    /**
     * 
     * @type {number}
     * @memberof LobbyPrize
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof LobbyPrize
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof LobbyPrize
     */
    'imageUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof LobbyPrize
     */
    'id': string;
}

export const LobbyPrizeAssetTypeEnum = {
    Icon: 'icon',
    Image: 'image'
} as const;

export type LobbyPrizeAssetTypeEnum = typeof LobbyPrizeAssetTypeEnum[keyof typeof LobbyPrizeAssetTypeEnum];

/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'updatedAt': string;
    /**
     * 
     * @type {NotificationType}
     * @memberof Notification
     */
    'type': NotificationType;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'objectId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    'seen': boolean;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'subtitle': string | null;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'bannerUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'userId': string;
    /**
     * 
     * @type {User}
     * @memberof Notification
     */
    'user'?: User;
}


/**
 * 
 * @export
 * @interface NotificationDetailed
 */
export interface NotificationDetailed {
    /**
     * 
     * @type {string}
     * @memberof NotificationDetailed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {NotificationType}
     * @memberof NotificationDetailed
     */
    'type': NotificationType;
    /**
     * 
     * @type {string}
     * @memberof NotificationDetailed
     */
    'objectId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationDetailed
     */
    'seen': boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationDetailed
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDetailed
     */
    'subtitle': string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationDetailed
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationDetailed
     */
    'bannerUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationDetailed
     */
    'userId': string;
    /**
     * 
     * @type {User}
     * @memberof NotificationDetailed
     */
    'user'?: User;
    /**
     * 
     * @type {UserDraw}
     * @memberof NotificationDetailed
     */
    'userDraw': UserDraw | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationType = {
    Event: 'EVENT',
    CaseReward: 'CASE_REWARD',
    ReferralCodeUsed: 'REFERRAL_CODE_USED',
    UnusedReferralsRemaining: 'UNUSED_REFERRALS_REMAINING',
    UnopenedCase: 'UNOPENED_CASE',
    LeaderboardWinner: 'LEADERBOARD_WINNER',
    RaffleWinner: 'RAFFLE_WINNER',
    EmailNotConnected: 'EMAIL_NOT_CONNECTED',
    PrizeClaimed: 'PRIZE_CLAIMED',
    PrizeDelivered: 'PRIZE_DELIVERED',
    ExportWallet: 'EXPORT_WALLET'
} as const;

export type NotificationType = typeof NotificationType[keyof typeof NotificationType];


/**
 * 
 * @export
 * @interface PaginatedAny
 */
export interface PaginatedAny {
    /**
     * 
     * @type {PaginatedGetEventWithLobbyDetailsResponsePagination}
     * @memberof PaginatedAny
     */
    'pagination': PaginatedGetEventWithLobbyDetailsResponsePagination;
    /**
     * 
     * @type {Array<any>}
     * @memberof PaginatedAny
     */
    'data': Array<any>;
}
/**
 * 
 * @export
 * @interface PaginatedEventGame
 */
export interface PaginatedEventGame {
    /**
     * 
     * @type {PaginatedGetEventWithLobbyDetailsResponsePagination}
     * @memberof PaginatedEventGame
     */
    'pagination': PaginatedGetEventWithLobbyDetailsResponsePagination;
    /**
     * 
     * @type {Array<EventGame>}
     * @memberof PaginatedEventGame
     */
    'data': Array<EventGame>;
}
/**
 * 
 * @export
 * @interface PaginatedGetEventWithLobbyDetailsResponse
 */
export interface PaginatedGetEventWithLobbyDetailsResponse {
    /**
     * 
     * @type {PaginatedGetEventWithLobbyDetailsResponsePagination}
     * @memberof PaginatedGetEventWithLobbyDetailsResponse
     */
    'pagination': PaginatedGetEventWithLobbyDetailsResponsePagination;
    /**
     * 
     * @type {Array<GetEventWithLobbyDetailsResponse>}
     * @memberof PaginatedGetEventWithLobbyDetailsResponse
     */
    'data': Array<GetEventWithLobbyDetailsResponse>;
}
/**
 * 
 * @export
 * @interface PaginatedGetEventWithLobbyDetailsResponsePagination
 */
export interface PaginatedGetEventWithLobbyDetailsResponsePagination {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGetEventWithLobbyDetailsResponsePagination
     */
    'totalItems': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedGetEventWithLobbyDetailsResponsePagination
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedGetEventWithLobbyDetailsResponsePagination
     */
    'pageSize': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedGetEventWithLobbyDetailsResponsePagination
     */
    'totalPages': number;
}
/**
 * 
 * @export
 * @interface PaginatedNotificationDetailed
 */
export interface PaginatedNotificationDetailed {
    /**
     * 
     * @type {PaginatedGetEventWithLobbyDetailsResponsePagination}
     * @memberof PaginatedNotificationDetailed
     */
    'pagination': PaginatedGetEventWithLobbyDetailsResponsePagination;
    /**
     * 
     * @type {Array<NotificationDetailed>}
     * @memberof PaginatedNotificationDetailed
     */
    'data': Array<NotificationDetailed>;
}
/**
 * 
 * @export
 * @interface PaginatedQuestGoal
 */
export interface PaginatedQuestGoal {
    /**
     * 
     * @type {PaginatedGetEventWithLobbyDetailsResponsePagination}
     * @memberof PaginatedQuestGoal
     */
    'pagination': PaginatedGetEventWithLobbyDetailsResponsePagination;
    /**
     * 
     * @type {Array<QuestGoal>}
     * @memberof PaginatedQuestGoal
     */
    'data': Array<QuestGoal>;
}
/**
 * 
 * @export
 * @interface PaginatedTransactionDetailed
 */
export interface PaginatedTransactionDetailed {
    /**
     * 
     * @type {PaginatedGetEventWithLobbyDetailsResponsePagination}
     * @memberof PaginatedTransactionDetailed
     */
    'pagination': PaginatedGetEventWithLobbyDetailsResponsePagination;
    /**
     * 
     * @type {Array<TransactionDetailed>}
     * @memberof PaginatedTransactionDetailed
     */
    'data': Array<TransactionDetailed>;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialCreateAnnouncementArgs
 */
export interface PartialCreateAnnouncementArgs {
    /**
     * 
     * @type {string}
     * @memberof PartialCreateAnnouncementArgs
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PartialCreateAnnouncementArgs
     */
    'status'?: boolean;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialCreateBannerArgs
 */
export interface PartialCreateBannerArgs {
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof PartialCreateBannerArgs
     */
    'startTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {BannerLocation}
     * @memberof PartialCreateBannerArgs
     */
    'bannerLocation'?: BannerLocation;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateBannerArgs
     */
    'eventId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateBannerArgs
     */
    'desktopImageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateBannerArgs
     */
    'mobileImageUrl'?: string;
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof PartialCreateBannerArgs
     */
    'endTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateBannerArgs
     */
    'logoUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateBannerArgs
     */
    'alt'?: string | null;
}


/**
 * Make all properties in T optional
 * @export
 * @interface PartialCreateEventArgs
 */
export interface PartialCreateEventArgs {
    /**
     * 
     * @type {string}
     * @memberof PartialCreateEventArgs
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateEventArgs
     */
    'subtitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateEventArgs
     */
    'gameId'?: string;
    /**
     * 
     * @type {EventStatus}
     * @memberof PartialCreateEventArgs
     */
    'status'?: EventStatus;
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof PartialCreateEventArgs
     */
    'startTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof PartialCreateEventArgs
     */
    'endTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateEventArgs
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateEventArgs
     */
    'imageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateEventArgs
     */
    'mapCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateEventArgs
     */
    'youtubeId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateEventArgs
     */
    'videoUrl'?: string | null;
}


/**
 * Make all properties in T optional
 * @export
 * @interface PartialCreateGameArgs
 */
export interface PartialCreateGameArgs {
    /**
     * 
     * @type {string}
     * @memberof PartialCreateGameArgs
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateGameArgs
     */
    'studioId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateGameArgs
     */
    'iconUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateGameArgs
     */
    'description'?: string | null;
    /**
     * 
     * @type {CreateEventGameAccess}
     * @memberof PartialCreateGameArgs
     */
    'createAccess'?: CreateEventGameAccess;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateGameArgs
     */
    'createEventImageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateGameArgs
     */
    'clientId'?: string | null;
}


/**
 * Make all properties in T optional
 * @export
 * @interface PartialCreateGameLinkArgs
 */
export interface PartialCreateGameLinkArgs {
    /**
     * 
     * @type {AccessStatus}
     * @memberof PartialCreateGameLinkArgs
     */
    'status'?: AccessStatus;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateGameLinkArgs
     */
    'gameId'?: string;
    /**
     * 
     * @type {LinkType}
     * @memberof PartialCreateGameLinkArgs
     */
    'linkType'?: LinkType;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateGameLinkArgs
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PartialCreateGameLinkArgs
     */
    'order'?: number;
}


/**
 * Make all properties in T optional
 * @export
 * @interface PartialCreateLeaderboardArgs
 */
export interface PartialCreateLeaderboardArgs {
    /**
     * 
     * @type {string}
     * @memberof PartialCreateLeaderboardArgs
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateLeaderboardArgs
     */
    'scoreTextAlias'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateLeaderboardArgs
     */
    'eventId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateLeaderboardArgs
     */
    'gameId'?: string;
    /**
     * 
     * @type {LeaderboardDisplay}
     * @memberof PartialCreateLeaderboardArgs
     */
    'leaderboardDisplay'?: LeaderboardDisplay;
}


/**
 * Make all properties in T optional
 * @export
 * @interface PartialCreateLeaderboardFactorArgs
 */
export interface PartialCreateLeaderboardFactorArgs {
    /**
     * 
     * @type {string}
     * @memberof PartialCreateLeaderboardFactorArgs
     */
    'objectId'?: string;
    /**
     * 
     * @type {LeaderboardFactorType}
     * @memberof PartialCreateLeaderboardFactorArgs
     */
    'type'?: LeaderboardFactorType;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateLeaderboardFactorArgs
     */
    'leaderboardId'?: string;
}


/**
 * Make all properties in T optional
 * @export
 * @interface PartialCreateLeaderboardScheduleArgs
 */
export interface PartialCreateLeaderboardScheduleArgs {
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof PartialCreateLeaderboardScheduleArgs
     */
    'startTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof PartialCreateLeaderboardScheduleArgs
     */
    'endTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateLeaderboardScheduleArgs
     */
    'leaderboardId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PartialCreateLeaderboardScheduleArgs
     */
    'scheduleProcessed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PartialCreateLeaderboardScheduleArgs
     */
    'rewardsProcessed'?: boolean;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialCreateProductArgs
 */
export interface PartialCreateProductArgs {
    /**
     * 
     * @type {string}
     * @memberof PartialCreateProductArgs
     */
    'title'?: string;
    /**
     * 
     * @type {ProductType}
     * @memberof PartialCreateProductArgs
     */
    'type'?: ProductType;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateProductArgs
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateProductArgs
     */
    'gameId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateProductArgs
     */
    'iconUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateProductArgs
     */
    'subTitle'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PartialCreateProductArgs
     */
    'initialQuantity'?: number;
}


/**
 * Make all properties in T optional
 * @export
 * @interface PartialCreateQuestGoalArgs
 */
export interface PartialCreateQuestGoalArgs {
    /**
     * 
     * @type {QuestType}
     * @memberof PartialCreateQuestGoalArgs
     */
    'type'?: QuestType;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateQuestGoalArgs
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateQuestGoalArgs
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PartialCreateQuestGoalArgs
     */
    'target'?: number;
    /**
     * 
     * @type {ActivityType}
     * @memberof PartialCreateQuestGoalArgs
     */
    'activity'?: ActivityType;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateQuestGoalArgs
     */
    'objectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateQuestGoalArgs
     */
    'openUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateQuestGoalArgs
     */
    'bannerUrl'?: string | null;
}


/**
 * Make all properties in T optional
 * @export
 * @interface PartialCreateQuestRewardArgs
 */
export interface PartialCreateQuestRewardArgs {
    /**
     * 
     * @type {number}
     * @memberof PartialCreateQuestRewardArgs
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateQuestRewardArgs
     */
    'productId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateQuestRewardArgs
     */
    'goalId'?: string;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialCreateQuestScheduleArgs
 */
export interface PartialCreateQuestScheduleArgs {
    /**
     * 
     * @type {string}
     * @memberof PartialCreateQuestScheduleArgs
     */
    'questId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateQuestScheduleArgs
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialCreateQuestScheduleArgs
     */
    'endTime'?: string | null;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialPickPrismaBannerUncheckedCreateInputEndTimeOrLogoUrlOrAlt
 */
export interface PartialPickPrismaBannerUncheckedCreateInputEndTimeOrLogoUrlOrAlt {
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof PartialPickPrismaBannerUncheckedCreateInputEndTimeOrLogoUrlOrAlt
     */
    'endTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaBannerUncheckedCreateInputEndTimeOrLogoUrlOrAlt
     */
    'logoUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaBannerUncheckedCreateInputEndTimeOrLogoUrlOrAlt
     */
    'alt'?: string | null;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialPickPrismaEventUncheckedCreateInputStartTimeOrEndTimeOrStatusOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrl
 */
export interface PartialPickPrismaEventUncheckedCreateInputStartTimeOrEndTimeOrStatusOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrl {
    /**
     * 
     * @type {EventStatus}
     * @memberof PartialPickPrismaEventUncheckedCreateInputStartTimeOrEndTimeOrStatusOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrl
     */
    'status'?: EventStatus;
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof PartialPickPrismaEventUncheckedCreateInputStartTimeOrEndTimeOrStatusOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrl
     */
    'startTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof PartialPickPrismaEventUncheckedCreateInputStartTimeOrEndTimeOrStatusOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrl
     */
    'endTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaEventUncheckedCreateInputStartTimeOrEndTimeOrStatusOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrl
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaEventUncheckedCreateInputStartTimeOrEndTimeOrStatusOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrl
     */
    'imageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaEventUncheckedCreateInputStartTimeOrEndTimeOrStatusOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrl
     */
    'mapCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaEventUncheckedCreateInputStartTimeOrEndTimeOrStatusOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrl
     */
    'youtubeId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaEventUncheckedCreateInputStartTimeOrEndTimeOrStatusOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrl
     */
    'videoUrl'?: string | null;
}


/**
 * Make all properties in T optional
 * @export
 * @interface PartialPickPrismaGameUncheckedCreateInputDescriptionOrCreateAccessOrCreateEventImageUrlOrClientId
 */
export interface PartialPickPrismaGameUncheckedCreateInputDescriptionOrCreateAccessOrCreateEventImageUrlOrClientId {
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaGameUncheckedCreateInputDescriptionOrCreateAccessOrCreateEventImageUrlOrClientId
     */
    'description'?: string | null;
    /**
     * 
     * @type {CreateEventGameAccess}
     * @memberof PartialPickPrismaGameUncheckedCreateInputDescriptionOrCreateAccessOrCreateEventImageUrlOrClientId
     */
    'createAccess'?: CreateEventGameAccess;
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaGameUncheckedCreateInputDescriptionOrCreateAccessOrCreateEventImageUrlOrClientId
     */
    'createEventImageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaGameUncheckedCreateInputDescriptionOrCreateAccessOrCreateEventImageUrlOrClientId
     */
    'clientId'?: string | null;
}


/**
 * Make all properties in T optional
 * @export
 * @interface PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId
 */
export interface PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId {
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId
     */
    'objectId'?: string;
    /**
     * 
     * @type {LeaderboardFactorType}
     * @memberof PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId
     */
    'type'?: LeaderboardFactorType;
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId
     */
    'leaderboardId'?: string;
}


/**
 * Make all properties in T optional
 * @export
 * @interface PartialPickPrismaProductUncheckedCreateInputSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
 */
export interface PartialPickPrismaProductUncheckedCreateInputSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId {
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaProductUncheckedCreateInputSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaProductUncheckedCreateInputSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'gameId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaProductUncheckedCreateInputSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'iconUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialPickPrismaProductUncheckedCreateInputSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'subTitle'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PartialPickPrismaProductUncheckedCreateInputSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'initialQuantity'?: number;
}
/**
 * 
 * @export
 * @interface Participant
 */
export interface Participant {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'userId': string;
    /**
     * 
     * @type {User}
     * @memberof Participant
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'eventId': string;
    /**
     * 
     * @type {Event}
     * @memberof Participant
     */
    'event'?: Event;
}
/**
 * 
 * @export
 * @interface ParticipantNew
 */
export interface ParticipantNew {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ParticipantNew
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ParticipantNew
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ParticipantNew
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ParticipantNew
     */
    'userId': string;
    /**
     * 
     * @type {User}
     * @memberof ParticipantNew
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof ParticipantNew
     */
    'eventId': string;
    /**
     * 
     * @type {EventNew}
     * @memberof ParticipantNew
     */
    'event'?: EventNew;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt
 */
export interface PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt {
    /**
     * 
     * @type {string}
     * @memberof PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt
     */
    'startTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt
     */
    'endTime': string | null;
    /**
     * 
     * @type {BannerLocation}
     * @memberof PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt
     */
    'bannerLocation': BannerLocation;
    /**
     * 
     * @type {string}
     * @memberof PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt
     */
    'eventId': string;
    /**
     * 
     * @type {string}
     * @memberof PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt
     */
    'logoUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt
     */
    'desktopImageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt
     */
    'mobileImageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt
     */
    'alt': string | null;
}


/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId
 */
export interface PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId {
    /**
     * 
     * @type {EventStatus}
     * @memberof PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId
     */
    'status': EventStatus;
    /**
     * 
     * @type {string}
     * @memberof PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId
     */
    'startTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId
     */
    'endTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId
     */
    'subtitle': string;
    /**
     * 
     * @type {string}
     * @memberof PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId
     */
    'imageUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId
     */
    'mapCode': string | null;
    /**
     * 
     * @type {string}
     * @memberof PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId
     */
    'youtubeId': string | null;
    /**
     * 
     * @type {string}
     * @memberof PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId
     */
    'videoUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId
     */
    'gameId': string;
}


/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickGoalProductIdOrCreatedAtOrUpdatedAtOrQuantityOrProductIdOrGoalId
 */
export interface PickGoalProductIdOrCreatedAtOrUpdatedAtOrQuantityOrProductIdOrGoalId {
    /**
     * 
     * @type {string}
     * @memberof PickGoalProductIdOrCreatedAtOrUpdatedAtOrQuantityOrProductIdOrGoalId
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PickGoalProductIdOrCreatedAtOrUpdatedAtOrQuantityOrProductIdOrGoalId
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PickGoalProductIdOrCreatedAtOrUpdatedAtOrQuantityOrProductIdOrGoalId
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof PickGoalProductIdOrCreatedAtOrUpdatedAtOrQuantityOrProductIdOrGoalId
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof PickGoalProductIdOrCreatedAtOrUpdatedAtOrQuantityOrProductIdOrGoalId
     */
    'productId': string;
    /**
     * 
     * @type {string}
     * @memberof PickGoalProductIdOrCreatedAtOrUpdatedAtOrQuantityOrProductIdOrGoalId
     */
    'goalId': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickLeaderboardFactorIdOrCreatedAtOrUpdatedAtOrObjectIdOrType
 */
export interface PickLeaderboardFactorIdOrCreatedAtOrUpdatedAtOrObjectIdOrType {
    /**
     * 
     * @type {string}
     * @memberof PickLeaderboardFactorIdOrCreatedAtOrUpdatedAtOrObjectIdOrType
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PickLeaderboardFactorIdOrCreatedAtOrUpdatedAtOrObjectIdOrType
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PickLeaderboardFactorIdOrCreatedAtOrUpdatedAtOrObjectIdOrType
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PickLeaderboardFactorIdOrCreatedAtOrUpdatedAtOrObjectIdOrType
     */
    'objectId': string;
    /**
     * 
     * @type {LeaderboardFactorType}
     * @memberof PickLeaderboardFactorIdOrCreatedAtOrUpdatedAtOrObjectIdOrType
     */
    'type': LeaderboardFactorType;
}


/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct
 */
export interface PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct {
    /**
     * 
     * @type {string}
     * @memberof PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct
     */
    'rewardPlace': number;
    /**
     * 
     * @type {string}
     * @memberof PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct
     */
    'productId': string;
    /**
     * 
     * @type {Product}
     * @memberof PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct
     */
    'product'?: Product;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed
 */
export interface PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed {
    /**
     * 
     * @type {string}
     * @memberof PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed
     */
    'startTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed
     */
    'endTime': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed
     */
    'scheduleProcessed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed
     */
    'rewardsProcessed': boolean;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus
 */
export interface PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus {
    /**
     * 
     * @type {string}
     * @memberof PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus
     */
    'message': string;
    /**
     * 
     * @type {boolean}
     * @memberof PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus
     */
    'status': boolean;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventId
 */
export interface PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventId {
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventId
     */
    'startTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {BannerLocation}
     * @memberof PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventId
     */
    'bannerLocation': BannerLocation;
    /**
     * 
     * @type {string}
     * @memberof PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventId
     */
    'eventId': string;
    /**
     * 
     * @type {string}
     * @memberof PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventId
     */
    'desktopImageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventId
     */
    'mobileImageUrl': string;
}


/**
 * 
 * @export
 * @interface PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime
 */
export interface PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime {
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPrismaEventUncheckedCreateInputTitleOrSubtitleOrGameId
 */
export interface PickPrismaEventUncheckedCreateInputTitleOrSubtitleOrGameId {
    /**
     * 
     * @type {string}
     * @memberof PickPrismaEventUncheckedCreateInputTitleOrSubtitleOrGameId
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PickPrismaEventUncheckedCreateInputTitleOrSubtitleOrGameId
     */
    'subtitle': string;
    /**
     * 
     * @type {string}
     * @memberof PickPrismaEventUncheckedCreateInputTitleOrSubtitleOrGameId
     */
    'gameId': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId
 */
export interface PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId {
    /**
     * 
     * @type {AccessStatus}
     * @memberof PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId
     */
    'status'?: AccessStatus;
    /**
     * 
     * @type {string}
     * @memberof PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId
     */
    'gameId': string;
    /**
     * 
     * @type {LinkType}
     * @memberof PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId
     */
    'linkType': LinkType;
    /**
     * 
     * @type {string}
     * @memberof PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId
     */
    'order': number;
}


/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPrismaGameUncheckedCreateInputStudioIdOrTitleOrIconUrl
 */
export interface PickPrismaGameUncheckedCreateInputStudioIdOrTitleOrIconUrl {
    /**
     * 
     * @type {string}
     * @memberof PickPrismaGameUncheckedCreateInputStudioIdOrTitleOrIconUrl
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PickPrismaGameUncheckedCreateInputStudioIdOrTitleOrIconUrl
     */
    'studioId': string;
    /**
     * 
     * @type {string}
     * @memberof PickPrismaGameUncheckedCreateInputStudioIdOrTitleOrIconUrl
     */
    'iconUrl': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId
 */
export interface PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId {
    /**
     * 
     * @type {string}
     * @memberof PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId
     */
    'objectId': string;
    /**
     * 
     * @type {LeaderboardFactorType}
     * @memberof PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId
     */
    'type': LeaderboardFactorType;
    /**
     * 
     * @type {string}
     * @memberof PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId
     */
    'leaderboardId': string;
}


/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId
 */
export interface PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId {
    /**
     * 
     * @type {number}
     * @memberof PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId
     */
    'quantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId
     */
    'rewardPlace': number;
    /**
     * 
     * @type {string}
     * @memberof PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId
     */
    'productId': string;
    /**
     * 
     * @type {string}
     * @memberof PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId
     */
    'leaderboardScheduleId': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId
 */
export interface PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId {
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId
     */
    'startTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime}
     * @memberof PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId
     */
    'endTime'?: PickPrismaBannerUncheckedCreateInputBannerLocationOrStartTimeOrDesktopImageUrlOrMobileImageUrlOrEventIdStartTime | null;
    /**
     * 
     * @type {string}
     * @memberof PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId
     */
    'leaderboardId': string;
    /**
     * 
     * @type {boolean}
     * @memberof PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId
     */
    'scheduleProcessed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId
     */
    'rewardsProcessed'?: boolean;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPrismaProductUncheckedCreateInputTypeOrTitle
 */
export interface PickPrismaProductUncheckedCreateInputTypeOrTitle {
    /**
     * 
     * @type {string}
     * @memberof PickPrismaProductUncheckedCreateInputTypeOrTitle
     */
    'title': string;
    /**
     * 
     * @type {ProductType}
     * @memberof PickPrismaProductUncheckedCreateInputTypeOrTitle
     */
    'type': ProductType;
}


/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPrismaUserRoleNewUncheckedCreateInputRole
 */
export interface PickPrismaUserRoleNewUncheckedCreateInputRole {
    /**
     * 
     * @type {UserRoleType}
     * @memberof PickPrismaUserRoleNewUncheckedCreateInputRole
     */
    'role': UserRoleType;
}


/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickProductIdOrCreatedAtOrUpdatedAtOrTitleOrSubTitleOrIconUrlOrType
 */
export interface PickProductIdOrCreatedAtOrUpdatedAtOrTitleOrSubTitleOrIconUrlOrType {
    /**
     * 
     * @type {string}
     * @memberof PickProductIdOrCreatedAtOrUpdatedAtOrTitleOrSubTitleOrIconUrlOrType
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PickProductIdOrCreatedAtOrUpdatedAtOrTitleOrSubTitleOrIconUrlOrType
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PickProductIdOrCreatedAtOrUpdatedAtOrTitleOrSubTitleOrIconUrlOrType
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PickProductIdOrCreatedAtOrUpdatedAtOrTitleOrSubTitleOrIconUrlOrType
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PickProductIdOrCreatedAtOrUpdatedAtOrTitleOrSubTitleOrIconUrlOrType
     */
    'iconUrl': string | null;
    /**
     * 
     * @type {ProductType}
     * @memberof PickProductIdOrCreatedAtOrUpdatedAtOrTitleOrSubTitleOrIconUrlOrType
     */
    'type': ProductType;
    /**
     * 
     * @type {string}
     * @memberof PickProductIdOrCreatedAtOrUpdatedAtOrTitleOrSubTitleOrIconUrlOrType
     */
    'subTitle': string | null;
}


/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickProductIdOrTitleOrSubTitleOrIconUrlOrType
 */
export interface PickProductIdOrTitleOrSubTitleOrIconUrlOrType {
    /**
     * 
     * @type {string}
     * @memberof PickProductIdOrTitleOrSubTitleOrIconUrlOrType
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PickProductIdOrTitleOrSubTitleOrIconUrlOrType
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PickProductIdOrTitleOrSubTitleOrIconUrlOrType
     */
    'iconUrl': string | null;
    /**
     * 
     * @type {ProductType}
     * @memberof PickProductIdOrTitleOrSubTitleOrIconUrlOrType
     */
    'type': ProductType;
    /**
     * 
     * @type {string}
     * @memberof PickProductIdOrTitleOrSubTitleOrIconUrlOrType
     */
    'subTitle': string | null;
}


/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
 */
export interface PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId {
    /**
     * 
     * @type {string}
     * @memberof PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'gameId': string | null;
    /**
     * 
     * @type {string}
     * @memberof PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'iconUrl': string | null;
    /**
     * 
     * @type {ProductType}
     * @memberof PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'type': ProductType;
    /**
     * 
     * @type {string}
     * @memberof PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'subTitle': string | null;
    /**
     * 
     * @type {number}
     * @memberof PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId
     */
    'initialQuantity': number;
}


/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickUserIdOrEmailOrUsername
 */
export interface PickUserIdOrEmailOrUsername {
    /**
     * 
     * @type {string}
     * @memberof PickUserIdOrEmailOrUsername
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PickUserIdOrEmailOrUsername
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PickUserIdOrEmailOrUsername
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PrizeType = {
    Blitz: 'blitz',
    Cash: 'cash',
    Custom: 'custom'
} as const;

export type PrizeType = typeof PrizeType[keyof typeof PrizeType];


/**
 * 
 * @export
 * @interface ProcessGameCodeRequest
 */
export interface ProcessGameCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessGameCodeRequest
     */
    'eventId'?: string;
    /**
     * 
     * @type {GameCodeType}
     * @memberof ProcessGameCodeRequest
     */
    'type': GameCodeType;
    /**
     * 
     * @type {string}
     * @memberof ProcessGameCodeRequest
     */
    'code': string;
}


/**
 * 
 * @export
 * @interface ProcessedDrawSchedule
 */
export interface ProcessedDrawSchedule {
    /**
     * 
     * @type {string}
     * @memberof ProcessedDrawSchedule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessedDrawSchedule
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessedDrawSchedule
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessedDrawSchedule
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessedDrawSchedule
     */
    'endTime': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProcessedDrawSchedule
     */
    'recurring': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProcessedDrawSchedule
     */
    'drawId': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProcessedDrawSchedule
     */
    'processed': boolean;
    /**
     * 
     * @type {Draw}
     * @memberof ProcessedDrawSchedule
     */
    'draw'?: Draw | null;
    /**
     * 
     * @type {Array<UserDrawDetailed>}
     * @memberof ProcessedDrawSchedule
     */
    'userDraws': Array<UserDrawDetailed>;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'updatedAt': string;
    /**
     * 
     * @type {ProductType}
     * @memberof Product
     */
    'type': ProductType;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'subTitle': string | null;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'description': string | null;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'initialQuantity': number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'iconUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'gameId': string | null;
    /**
     * 
     * @type {RaffleNew}
     * @memberof Product
     */
    'raffleNew'?: RaffleNew | null;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof Product
     */
    'buyTransactions'?: Array<Transaction>;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof Product
     */
    'sellTransactions'?: Array<Transaction>;
    /**
     * 
     * @type {Array<GoalProduct>}
     * @memberof Product
     */
    'goalProducts'?: Array<GoalProduct>;
    /**
     * 
     * @type {Array<UserInventory>}
     * @memberof Product
     */
    'userInventory'?: Array<UserInventory>;
    /**
     * 
     * @type {Array<Draw>}
     * @memberof Product
     */
    'ticketDraws'?: Array<Draw>;
    /**
     * 
     * @type {Array<Draw>}
     * @memberof Product
     */
    'expiredTicketDraws'?: Array<Draw>;
    /**
     * 
     * @type {Array<DrawProduct>}
     * @memberof Product
     */
    'drawProducts'?: Array<DrawProduct>;
    /**
     * 
     * @type {Array<LeaderboardReward>}
     * @memberof Product
     */
    'leaderboardRewards'?: Array<LeaderboardReward>;
    /**
     * 
     * @type {Array<RewardNew>}
     * @memberof Product
     */
    'rewards'?: Array<RewardNew>;
    /**
     * 
     * @type {Array<TransactionNew>}
     * @memberof Product
     */
    'buyTransactionsNew'?: Array<TransactionNew>;
    /**
     * 
     * @type {Array<TransactionNew>}
     * @memberof Product
     */
    'sellTransactionsNew'?: Array<TransactionNew>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ProductType = {
    Ticket: 'TICKET',
    ExpiredTicket: 'EXPIRED_TICKET',
    CryptoEthereum: 'CRYPTO_ETHEREUM',
    CryptoUsdc: 'CRYPTO_USDC',
    Usd: 'USD',
    Nft: 'NFT',
    InGameItem: 'IN_GAME_ITEM',
    PhysicalProduct: 'PHYSICAL_PRODUCT',
    Token: 'TOKEN',
    GiftCard: 'GIFT_CARD',
    Avatar: 'AVATAR',
    Banner: 'BANNER',
    Other: 'OTHER'
} as const;

export type ProductType = typeof ProductType[keyof typeof ProductType];


/**
 * 
 * @export
 * @interface Progress
 */
export interface Progress {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Progress
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Progress
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Progress
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Progress
     */
    'userId': string;
    /**
     * 
     * @type {number}
     * @memberof Progress
     */
    'progress': number;
    /**
     * 
     * @type {boolean}
     * @memberof Progress
     */
    'complete': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Progress
     */
    'isPendingVerification': boolean;
    /**
     * 
     * @type {string}
     * @memberof Progress
     */
    'goalId': string;
    /**
     * 
     * @type {string}
     * @memberof Progress
     */
    'questScheduleId': string;
    /**
     * 
     * @type {QuestSchedule}
     * @memberof Progress
     */
    'questSchedule'?: QuestSchedule;
}
/**
 * 
 * @export
 * @interface ProgressNew
 */
export interface ProgressNew {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ProgressNew
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProgressNew
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProgressNew
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProgressNew
     */
    'achievedAt': string;
    /**
     * 
     * @type {number}
     * @memberof ProgressNew
     */
    'progress': number;
    /**
     * 
     * @type {boolean}
     * @memberof ProgressNew
     */
    'complete': boolean;
    /**
     * 
     * @type {ScheduleType}
     * @memberof ProgressNew
     */
    'type': ScheduleType;
    /**
     * 
     * @type {string}
     * @memberof ProgressNew
     */
    'objectId': string;
    /**
     * 
     * @type {string}
     * @memberof ProgressNew
     */
    'userId': string;
    /**
     * 
     * @type {User}
     * @memberof ProgressNew
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof ProgressNew
     */
    'scheduleHistoryId': string;
    /**
     * 
     * @type {ScheduleHistoryNew}
     * @memberof ProgressNew
     */
    'scheduleHistoryNew'?: ScheduleHistoryNew;
}


/**
 * 
 * @export
 * @interface Quest
 */
export interface Quest {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Quest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Quest
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Quest
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Quest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Quest
     */
    'description': string | null;
    /**
     * 
     * @type {QuestType}
     * @memberof Quest
     */
    'type': QuestType;
    /**
     * 
     * @type {string}
     * @memberof Quest
     */
    'gameId': string;
    /**
     * 
     * @type {Game}
     * @memberof Quest
     */
    'game'?: Game;
    /**
     * 
     * @type {string}
     * @memberof Quest
     */
    'eventId': string;
    /**
     * 
     * @type {Event}
     * @memberof Quest
     */
    'event'?: Event;
    /**
     * 
     * @type {Array<Goal>}
     * @memberof Quest
     */
    'goals'?: Array<Goal>;
    /**
     * 
     * @type {Array<QuestSchedule>}
     * @memberof Quest
     */
    'schedules'?: Array<QuestSchedule>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const QuestDifficulty = {
    Easy: 'EASY',
    Medium: 'MEDIUM',
    Hard: 'HARD'
} as const;

export type QuestDifficulty = typeof QuestDifficulty[keyof typeof QuestDifficulty];


/**
 * 
 * @export
 * @interface QuestGoal
 */
export interface QuestGoal {
    /**
     * 
     * @type {number}
     * @memberof QuestGoal
     */
    'completedQuests': number;
    /**
     * 
     * @type {Array<GoalWithProgress>}
     * @memberof QuestGoal
     */
    'goals': Array<GoalWithProgress>;
    /**
     * 
     * @type {boolean}
     * @memberof QuestGoal
     */
    'processed': boolean;
    /**
     * 
     * @type {string}
     * @memberof QuestGoal
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof QuestGoal
     */
    'questId': string;
    /**
     * 
     * @type {string}
     * @memberof QuestGoal
     */
    'endTime': string | null;
    /**
     * 
     * @type {string}
     * @memberof QuestGoal
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof QuestGoal
     */
    'questScheduleId': string;
}
/**
 * 
 * @export
 * @interface QuestNew
 */
export interface QuestNew {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof QuestNew
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof QuestNew
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof QuestNew
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof QuestNew
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof QuestNew
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof QuestNew
     */
    'instructions': string | null;
    /**
     * 
     * @type {QuestType}
     * @memberof QuestNew
     */
    'type': QuestType;
    /**
     * 
     * @type {ActivityType}
     * @memberof QuestNew
     */
    'activityType': ActivityType;
    /**
     * 
     * @type {string}
     * @memberof QuestNew
     */
    'openUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof QuestNew
     */
    'bannerUrl': string | null;
    /**
     * 
     * @type {number}
     * @memberof QuestNew
     */
    'target': number;
    /**
     * 
     * @type {string}
     * @memberof QuestNew
     */
    'mappingId': string | null;
    /**
     * 
     * @type {string}
     * @memberof QuestNew
     */
    'questSetId': string;
    /**
     * 
     * @type {QuestSet}
     * @memberof QuestNew
     */
    'questSet'?: QuestSet;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const QuestOrientation = {
    Horizontal: 'HORIZONTAL',
    Vertical: 'VERTICAL'
} as const;

export type QuestOrientation = typeof QuestOrientation[keyof typeof QuestOrientation];


/**
 * 
 * @export
 * @interface QuestSchedule
 */
export interface QuestSchedule {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof QuestSchedule
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof QuestSchedule
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof QuestSchedule
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof QuestSchedule
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof QuestSchedule
     */
    'endTime': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof QuestSchedule
     */
    'recurring': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QuestSchedule
     */
    'processed': boolean;
    /**
     * 
     * @type {string}
     * @memberof QuestSchedule
     */
    'questId': string;
    /**
     * 
     * @type {Quest}
     * @memberof QuestSchedule
     */
    'quest'?: Quest;
    /**
     * 
     * @type {Array<Progress>}
     * @memberof QuestSchedule
     */
    'progress'?: Array<Progress>;
}
/**
 * 
 * @export
 * @interface QuestSet
 */
export interface QuestSet {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof QuestSet
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof QuestSet
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof QuestSet
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof QuestSet
     */
    'eventId': string;
    /**
     * 
     * @type {EventNew}
     * @memberof QuestSet
     */
    'event'?: EventNew;
    /**
     * 
     * @type {Array<QuestNew>}
     * @memberof QuestSet
     */
    'quests'?: Array<QuestNew>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const QuestType = {
    DailyIndividual: 'DAILY_INDIVIDUAL',
    SocialIndividual: 'SOCIAL_INDIVIDUAL'
} as const;

export type QuestType = typeof QuestType[keyof typeof QuestType];


/**
 * 
 * @export
 * @interface RaffleNew
 */
export interface RaffleNew {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof RaffleNew
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RaffleNew
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RaffleNew
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof RaffleNew
     */
    'title': string | null;
    /**
     * 
     * @type {string}
     * @memberof RaffleNew
     */
    'expiredTicketId': string | null;
    /**
     * 
     * @type {PrizeType}
     * @memberof RaffleNew
     */
    'rewardDistributionMethod': PrizeType;
    /**
     * 
     * @type {string}
     * @memberof RaffleNew
     */
    'ticketId': string;
    /**
     * 
     * @type {Product}
     * @memberof RaffleNew
     */
    'ticket'?: Product;
    /**
     * 
     * @type {string}
     * @memberof RaffleNew
     */
    'eventId': string | null;
    /**
     * 
     * @type {EventNew}
     * @memberof RaffleNew
     */
    'event'?: EventNew | null;
}


/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'externalId'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'gameId'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'authId': string;
}
/**
 * 
 * @export
 * @interface RewardCreateInput
 */
export interface RewardCreateInput {
    /**
     * 
     * @type {number}
     * @memberof RewardCreateInput
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof RewardCreateInput
     */
    'productId': string;
}
/**
 * 
 * @export
 * @interface RewardNew
 */
export interface RewardNew {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof RewardNew
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RewardNew
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RewardNew
     */
    'updatedAt': string;
    /**
     * 
     * @type {number}
     * @memberof RewardNew
     */
    'quantity': number;
    /**
     * 
     * @type {ScheduleType}
     * @memberof RewardNew
     */
    'type': ScheduleType;
    /**
     * 
     * @type {string}
     * @memberof RewardNew
     */
    'objectId': string;
    /**
     * 
     * @type {number}
     * @memberof RewardNew
     */
    'rewardPlace': number | null;
    /**
     * 
     * @type {string}
     * @memberof RewardNew
     */
    'productId': string;
    /**
     * 
     * @type {Product}
     * @memberof RewardNew
     */
    'product'?: Product;
}


/**
 * 
 * @export
 * @interface SaveEventDetailsArgs
 */
export interface SaveEventDetailsArgs {
    [key: string]: any;

    /**
     * 
     * @type {CreateEventArgs}
     * @memberof SaveEventDetailsArgs
     */
    'eventData': CreateEventArgs;
    /**
     * 
     * @type {CreateLeaderboardArgs}
     * @memberof SaveEventDetailsArgs
     */
    'leaderboardData'?: CreateLeaderboardArgs;
    /**
     * 
     * @type {CreateLeaderboardRewardArgs}
     * @memberof SaveEventDetailsArgs
     */
    'leaderboardRewardData'?: CreateLeaderboardRewardArgs;
    /**
     * 
     * @type {CreateRaffleArgsBaseRaffleRewardsArgs}
     * @memberof SaveEventDetailsArgs
     */
    'raffleData'?: CreateRaffleArgsBaseRaffleRewardsArgs;
    /**
     * 
     * @type {CreateGameQuestArgs}
     * @memberof SaveEventDetailsArgs
     */
    'gameQuestData'?: CreateGameQuestArgs;
    /**
     * 
     * @type {CreateSocialQuestArgs}
     * @memberof SaveEventDetailsArgs
     */
    'socialQuestData'?: CreateSocialQuestArgs;
}
/**
 * 
 * @export
 * @interface SaveLeaderboardArgs
 */
export interface SaveLeaderboardArgs {
    /**
     * 
     * @type {LeaderboardDisplay}
     * @memberof SaveLeaderboardArgs
     */
    'leaderboardDisplay'?: LeaderboardDisplay;
    /**
     * 
     * @type {string}
     * @memberof SaveLeaderboardArgs
     */
    'gameId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveLeaderboardArgs
     */
    'eventId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveLeaderboardArgs
     */
    'scoreTextAlias'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveLeaderboardArgs
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveLeaderboardArgs
     */
    'id'?: string;
}


/**
 * 
 * @export
 * @interface ScheduleExceptionNew
 */
export interface ScheduleExceptionNew {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ScheduleExceptionNew
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleExceptionNew
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleExceptionNew
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleExceptionNew
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleExceptionNew
     */
    'endTime': string;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduleExceptionNew
     */
    'isDeleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof ScheduleExceptionNew
     */
    'scheduleId': string;
    /**
     * 
     * @type {ScheduleNew}
     * @memberof ScheduleExceptionNew
     */
    'schedule'?: ScheduleNew;
}
/**
 * 
 * @export
 * @interface ScheduleHistoryNew
 */
export interface ScheduleHistoryNew {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ScheduleHistoryNew
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleHistoryNew
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleHistoryNew
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleHistoryNew
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleHistoryNew
     */
    'endTime': string;
    /**
     * 
     * @type {ScheduleType}
     * @memberof ScheduleHistoryNew
     */
    'type': ScheduleType;
    /**
     * 
     * @type {ScheduleStatus}
     * @memberof ScheduleHistoryNew
     */
    'status': ScheduleStatus;
    /**
     * 
     * @type {Array<ProgressNew>}
     * @memberof ScheduleHistoryNew
     */
    'progressNew'?: Array<ProgressNew>;
    /**
     * 
     * @type {string}
     * @memberof ScheduleHistoryNew
     */
    'scheduleId': string;
    /**
     * 
     * @type {ScheduleNew}
     * @memberof ScheduleHistoryNew
     */
    'schedule'?: ScheduleNew;
}


/**
 * 
 * @export
 * @interface ScheduleNew
 */
export interface ScheduleNew {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ScheduleNew
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleNew
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleNew
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleNew
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleNew
     */
    'endTime': string | null;
    /**
     * 
     * @type {ScheduleType}
     * @memberof ScheduleNew
     */
    'type': ScheduleType;
    /**
     * 
     * @type {string}
     * @memberof ScheduleNew
     */
    'objectId': string;
    /**
     * 
     * @type {Frequency}
     * @memberof ScheduleNew
     */
    'frequency': Frequency;
    /**
     * 
     * @type {number}
     * @memberof ScheduleNew
     */
    'interval': number;
    /**
     * 
     * @type {string}
     * @memberof ScheduleNew
     */
    'daysOfWeek': string | null;
    /**
     * 
     * @type {number}
     * @memberof ScheduleNew
     */
    'dayOfMonth': number | null;
    /**
     * 
     * @type {number}
     * @memberof ScheduleNew
     */
    'weekOfMonth': number | null;
    /**
     * 
     * @type {number}
     * @memberof ScheduleNew
     */
    'endAfterOccurrences': number | null;
    /**
     * 
     * @type {Array<ScheduleHistoryNew>}
     * @memberof ScheduleNew
     */
    'scheduleHistory'?: Array<ScheduleHistoryNew>;
    /**
     * 
     * @type {Array<ScheduleExceptionNew>}
     * @memberof ScheduleNew
     */
    'scheduleExceptions'?: Array<ScheduleExceptionNew>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ScheduleStatus = {
    NotProcessed: 'NOT_PROCESSED',
    Error: 'ERROR',
    Processed: 'PROCESSED'
} as const;

export type ScheduleStatus = typeof ScheduleStatus[keyof typeof ScheduleStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ScheduleType = {
    Event: 'EVENT',
    Leaderboard: 'LEADERBOARD',
    Raffle: 'RAFFLE',
    Quest: 'QUEST',
    GameQuestTemplate: 'GAME_QUEST_TEMPLATE'
} as const;

export type ScheduleType = typeof ScheduleType[keyof typeof ScheduleType];


/**
 * 
 * @export
 * @interface SocialGoalCreateInput
 */
export interface SocialGoalCreateInput {
    /**
     * 
     * @type {string}
     * @memberof SocialGoalCreateInput
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SocialGoalCreateInput
     */
    'bannerUrl'?: string;
    /**
     * 
     * @type {ActivityType}
     * @memberof SocialGoalCreateInput
     */
    'activity': ActivityType;
    /**
     * 
     * @type {string}
     * @memberof SocialGoalCreateInput
     */
    'questId': string;
    /**
     * 
     * @type {string}
     * @memberof SocialGoalCreateInput
     */
    'openUrl': string;
    /**
     * 
     * @type {number}
     * @memberof SocialGoalCreateInput
     */
    'target': number;
    /**
     * 
     * @type {string}
     * @memberof SocialGoalCreateInput
     */
    'title': string;
}


/**
 * 
 * @export
 * @interface SocialLink
 */
export interface SocialLink {
    /**
     * 
     * @type {LinkType}
     * @memberof SocialLink
     */
    'linkType': LinkType;
    /**
     * 
     * @type {string}
     * @memberof SocialLink
     */
    'icon': string | null;
    /**
     * 
     * @type {string}
     * @memberof SocialLink
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof SocialLink
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SocialLink
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface SocialQuestCreateInput
 */
export interface SocialQuestCreateInput {
    /**
     * 
     * @type {Array<RewardCreateInput>}
     * @memberof SocialQuestCreateInput
     */
    'rewards': Array<RewardCreateInput>;
    /**
     * 
     * @type {SocialGoalCreateInput}
     * @memberof SocialQuestCreateInput
     */
    'goal': SocialGoalCreateInput;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StatusType = {
    NotClaimed: 'NOT_CLAIMED',
    Claimed: 'CLAIMED',
    Processing: 'PROCESSING',
    Delivered: 'DELIVERED',
    Expired: 'EXPIRED'
} as const;

export type StatusType = typeof StatusType[keyof typeof StatusType];


/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'updatedAt': string;
    /**
     * 
     * @type {TransactionType}
     * @memberof Transaction
     */
    'transactionType': TransactionType;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'buyProductId': string;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'buyProductQuantity': number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'sellProductId': string | null;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'sellProductQuantity': number | null;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'objectId': string | null;
    /**
     * 
     * @type {StatusType}
     * @memberof Transaction
     */
    'status': StatusType;
    /**
     * 
     * @type {User}
     * @memberof Transaction
     */
    'user'?: User | null;
    /**
     * 
     * @type {Product}
     * @memberof Transaction
     */
    'sellProduct'?: Product | null;
    /**
     * 
     * @type {Product}
     * @memberof Transaction
     */
    'buyProduct'?: Product | null;
}


/**
 * 
 * @export
 * @interface TransactionDetailed
 */
export interface TransactionDetailed {
    /**
     * 
     * @type {string}
     * @memberof TransactionDetailed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {TransactionType}
     * @memberof TransactionDetailed
     */
    'transactionType': TransactionType;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetailed
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetailed
     */
    'buyProductId': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionDetailed
     */
    'buyProductQuantity': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetailed
     */
    'sellProductId': string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionDetailed
     */
    'sellProductQuantity': number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetailed
     */
    'objectId': string | null;
    /**
     * 
     * @type {StatusType}
     * @memberof TransactionDetailed
     */
    'status': StatusType;
    /**
     * 
     * @type {User}
     * @memberof TransactionDetailed
     */
    'user'?: User | null;
    /**
     * 
     * @type {Product}
     * @memberof TransactionDetailed
     */
    'sellProduct': Product | null;
    /**
     * 
     * @type {Product}
     * @memberof TransactionDetailed
     */
    'buyProduct': Product | null;
}


/**
 * 
 * @export
 * @interface TransactionNew
 */
export interface TransactionNew {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof TransactionNew
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionNew
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionNew
     */
    'updatedAt': string;
    /**
     * 
     * @type {TransactionType}
     * @memberof TransactionNew
     */
    'transactionType': TransactionType;
    /**
     * 
     * @type {string}
     * @memberof TransactionNew
     */
    'buyerUserId': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionNew
     */
    'boughtProductId': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionNew
     */
    'boughtProductQuantity': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionNew
     */
    'sellerUserId': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionNew
     */
    'soldProductId': string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionNew
     */
    'soldProductQuantity': number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionNew
     */
    'objectId': string | null;
    /**
     * 
     * @type {StatusType}
     * @memberof TransactionNew
     */
    'status': StatusType;
    /**
     * 
     * @type {User}
     * @memberof TransactionNew
     */
    'buyer'?: User | null;
    /**
     * 
     * @type {User}
     * @memberof TransactionNew
     */
    'seller'?: User | null;
    /**
     * 
     * @type {Product}
     * @memberof TransactionNew
     */
    'soldProduct'?: Product | null;
    /**
     * 
     * @type {Product}
     * @memberof TransactionNew
     */
    'boughtProduct'?: Product | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionType = {
    QuestReward: 'QUEST_REWARD',
    LeaderboardReward: 'LEADERBOARD_REWARD',
    RaffleReward: 'RAFFLE_REWARD',
    Reward: 'REWARD',
    Marketplace: 'MARKETPLACE',
    Draw: 'DRAW',
    ExpiredRaffleTicket: 'EXPIRED_RAFFLE_TICKET'
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


/**
 * 
 * @export
 * @interface UpdateApiKeyArgs
 */
export interface UpdateApiKeyArgs {
    /**
     * 
     * @type {AccessStatus}
     * @memberof UpdateApiKeyArgs
     */
    'status': AccessStatus;
    /**
     * 
     * @type {string}
     * @memberof UpdateApiKeyArgs
     */
    'expireAt': string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateApiKeyArgs
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApiKeyArgs
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface UpdateGameLinksBulkArgs
 */
export interface UpdateGameLinksBulkArgs {
    /**
     * 
     * @type {string}
     * @memberof UpdateGameLinksBulkArgs
     */
    'gameId': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateGameLinksBulkArgs
     */
    'isNew'?: boolean;
    /**
     * 
     * @type {AccessStatus}
     * @memberof UpdateGameLinksBulkArgs
     */
    'status': AccessStatus;
    /**
     * 
     * @type {number}
     * @memberof UpdateGameLinksBulkArgs
     */
    'order': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateGameLinksBulkArgs
     */
    'url': string;
    /**
     * 
     * @type {LinkType}
     * @memberof UpdateGameLinksBulkArgs
     */
    'linkType': LinkType;
    /**
     * 
     * @type {string}
     * @memberof UpdateGameLinksBulkArgs
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface UpdateLeaderboardResponse
 */
export interface UpdateLeaderboardResponse {
    /**
     * 
     * @type {LeaderboardDisplay}
     * @memberof UpdateLeaderboardResponse
     */
    'leaderboardDisplay'?: LeaderboardDisplay | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateLeaderboardResponse
     */
    'gameId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLeaderboardResponse
     */
    'eventId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateLeaderboardResponse
     */
    'scoreTextAlias'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLeaderboardResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLeaderboardResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLeaderboardResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLeaderboardResponse
     */
    'id'?: string;
}


/**
 * 
 * @export
 * @interface UpdateNotificationsRequest
 */
export interface UpdateNotificationsRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateNotificationsRequest
     */
    'seen': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateNotificationsRequest
     */
    'notificationIds': Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateProfileRequest
 */
export interface UpdateProfileRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateProfileRequest
     */
    'default'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateProfileRequest
     */
    'inventoryId': string;
    /**
     * 
     * @type {ProductType}
     * @memberof UpdateProfileRequest
     */
    'productType': ProductType;
}


/**
 * 
 * @export
 * @interface UpdateRequest
 */
export interface UpdateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRequest
     */
    'enableNotifications'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRequest
     */
    'hasAcceptedAge'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRequest
     */
    'hasAcceptedLegal'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRequest
     */
    'hasOnboarded'?: boolean;
    /**
     * 
     * @type {Gender}
     * @memberof UpdateRequest
     */
    'gender'?: Gender | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateRequest
     */
    'birthYear'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequest
     */
    'mergedWith'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequest
     */
    'externalId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequest
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequest
     */
    'avatarProductId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateRequest
     */
    'username'?: string;
}


/**
 * 
 * @export
 * @interface UpdateUserWalletRequest
 */
export interface UpdateUserWalletRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserWalletRequest
     */
    'userId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserWalletRequest
     */
    'isPrimary': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserWalletRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'originalCreationDate': string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'authId': string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phoneNumber': string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'usertag': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'remainingReferrals': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatarUrl': string | null;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'birthYear': number;
    /**
     * 
     * @type {Gender}
     * @memberof User
     */
    'gender': Gender;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'hasOnboarded': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'hasAcceptedLegal': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'hasAcceptedAge': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'enableNotifications': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'referredById': string | null;
    /**
     * 
     * @type {User}
     * @memberof User
     */
    'referredBy'?: User | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof User
     */
    'referredUsers'?: Array<User>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'mergedWith': string | null;
    /**
     * 
     * @type {User}
     * @memberof User
     */
    'mergedWithUser'?: User | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof User
     */
    'externalUsers'?: Array<User>;
    /**
     * 
     * @type {Blacklist}
     * @memberof User
     */
    'blacklist'?: Blacklist | null;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof User
     */
    'transactions'?: Array<Transaction>;
    /**
     * 
     * @type {Array<UserDraw>}
     * @memberof User
     */
    'userDraws'?: Array<UserDraw>;
    /**
     * 
     * @type {Array<LeaderboardScore>}
     * @memberof User
     */
    'leaderboardScores'?: Array<LeaderboardScore>;
    /**
     * 
     * @type {Array<LeaderboardResult>}
     * @memberof User
     */
    'leaderboardResult'?: Array<LeaderboardResult>;
    /**
     * 
     * @type {Array<Notification>}
     * @memberof User
     */
    'notifications'?: Array<Notification>;
    /**
     * 
     * @type {Array<UserInventory>}
     * @memberof User
     */
    'userInventory'?: Array<UserInventory>;
    /**
     * 
     * @type {Array<Activity>}
     * @memberof User
     */
    'activity'?: Array<Activity>;
    /**
     * 
     * @type {Array<UserConnection>}
     * @memberof User
     */
    'userConnections'?: Array<UserConnection>;
    /**
     * 
     * @type {Array<UserWallet>}
     * @memberof User
     */
    'userWallets'?: Array<UserWallet>;
    /**
     * 
     * @type {Array<UserInstalledGames>}
     * @memberof User
     */
    'userInstalledGames'?: Array<UserInstalledGames>;
    /**
     * 
     * @type {Array<GameCode>}
     * @memberof User
     */
    'gameCode'?: Array<GameCode>;
    /**
     * 
     * @type {Array<BlacklistHistory>}
     * @memberof User
     */
    'blacklistHistory'?: Array<BlacklistHistory>;
    /**
     * 
     * @type {Array<UserRoleNew>}
     * @memberof User
     */
    'userRoles'?: Array<UserRoleNew>;
    /**
     * 
     * @type {Array<ProgressNew>}
     * @memberof User
     */
    'progressNew'?: Array<ProgressNew>;
    /**
     * 
     * @type {Array<TransactionNew>}
     * @memberof User
     */
    'buyTransactions'?: Array<TransactionNew>;
    /**
     * 
     * @type {Array<TransactionNew>}
     * @memberof User
     */
    'sellTransactions'?: Array<TransactionNew>;
    /**
     * 
     * @type {Array<Participant>}
     * @memberof User
     */
    'joinedEvents'?: Array<Participant>;
    /**
     * 
     * @type {Array<ParticipantNew>}
     * @memberof User
     */
    'joinedEventsNew'?: Array<ParticipantNew>;
    /**
     * 
     * @type {Array<EventNew>}
     * @memberof User
     */
    'eventNew'?: Array<EventNew>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'externalId': string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'gameId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastLogin': string | null;
}


/**
 * 
 * @export
 * @interface UserConnection
 */
export interface UserConnection {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UserConnection
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserConnection
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserConnection
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserConnection
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserConnection
     */
    'nickname': string | null;
    /**
     * 
     * @type {ConnectionType}
     * @memberof UserConnection
     */
    'socialConnectionType': ConnectionType;
    /**
     * 
     * @type {string}
     * @memberof UserConnection
     */
    'sub': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserConnection
     */
    'userId': string;
    /**
     * 
     * @type {User}
     * @memberof UserConnection
     */
    'user'?: User;
}


/**
 * 
 * @export
 * @interface UserDetailed
 */
export interface UserDetailed {
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'originalCreationDate': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'authId': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'phoneNumber': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'username': string;
    /**
     * 
     * @type {number}
     * @memberof UserDetailed
     */
    'usertag': number;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof UserDetailed
     */
    'remainingReferrals': number;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'avatarUrl': string | null;
    /**
     * 
     * @type {number}
     * @memberof UserDetailed
     */
    'birthYear': number;
    /**
     * 
     * @type {Gender}
     * @memberof UserDetailed
     */
    'gender': Gender;
    /**
     * 
     * @type {boolean}
     * @memberof UserDetailed
     */
    'hasOnboarded': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserDetailed
     */
    'hasAcceptedLegal': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserDetailed
     */
    'hasAcceptedAge': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserDetailed
     */
    'enableNotifications': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'referredById': string | null;
    /**
     * 
     * @type {User}
     * @memberof UserDetailed
     */
    'referredBy'?: User | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserDetailed
     */
    'referredUsers'?: Array<User>;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'mergedWith': string | null;
    /**
     * 
     * @type {User}
     * @memberof UserDetailed
     */
    'mergedWithUser': User | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserDetailed
     */
    'externalUsers'?: Array<User>;
    /**
     * 
     * @type {Blacklist}
     * @memberof UserDetailed
     */
    'blacklist': Blacklist | null;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof UserDetailed
     */
    'transactions'?: Array<Transaction>;
    /**
     * 
     * @type {Array<UserDraw>}
     * @memberof UserDetailed
     */
    'userDraws'?: Array<UserDraw>;
    /**
     * 
     * @type {Array<LeaderboardScore>}
     * @memberof UserDetailed
     */
    'leaderboardScores'?: Array<LeaderboardScore>;
    /**
     * 
     * @type {Array<LeaderboardResult>}
     * @memberof UserDetailed
     */
    'leaderboardResult'?: Array<LeaderboardResult>;
    /**
     * 
     * @type {Array<Notification>}
     * @memberof UserDetailed
     */
    'notifications'?: Array<Notification>;
    /**
     * 
     * @type {Array<UserInventory>}
     * @memberof UserDetailed
     */
    'userInventory'?: Array<UserInventory>;
    /**
     * 
     * @type {Array<Activity>}
     * @memberof UserDetailed
     */
    'activity'?: Array<Activity>;
    /**
     * 
     * @type {Array<UserConnection>}
     * @memberof UserDetailed
     */
    'userConnections'?: Array<UserConnection>;
    /**
     * 
     * @type {Array<UserWallet>}
     * @memberof UserDetailed
     */
    'userWallets'?: Array<UserWallet>;
    /**
     * 
     * @type {Array<UserInstalledGames>}
     * @memberof UserDetailed
     */
    'userInstalledGames'?: Array<UserInstalledGames>;
    /**
     * 
     * @type {Array<GameCode>}
     * @memberof UserDetailed
     */
    'gameCode'?: Array<GameCode>;
    /**
     * 
     * @type {Array<BlacklistHistory>}
     * @memberof UserDetailed
     */
    'blacklistHistory'?: Array<BlacklistHistory>;
    /**
     * 
     * @type {Array<UserRoleNew>}
     * @memberof UserDetailed
     */
    'userRoles'?: Array<UserRoleNew>;
    /**
     * 
     * @type {Array<ProgressNew>}
     * @memberof UserDetailed
     */
    'progressNew'?: Array<ProgressNew>;
    /**
     * 
     * @type {Array<TransactionNew>}
     * @memberof UserDetailed
     */
    'buyTransactions'?: Array<TransactionNew>;
    /**
     * 
     * @type {Array<TransactionNew>}
     * @memberof UserDetailed
     */
    'sellTransactions'?: Array<TransactionNew>;
    /**
     * 
     * @type {Array<Participant>}
     * @memberof UserDetailed
     */
    'joinedEvents'?: Array<Participant>;
    /**
     * 
     * @type {Array<ParticipantNew>}
     * @memberof UserDetailed
     */
    'joinedEventsNew'?: Array<ParticipantNew>;
    /**
     * 
     * @type {Array<EventNew>}
     * @memberof UserDetailed
     */
    'eventNew'?: Array<EventNew>;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'externalId': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'gameId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserDetailed
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserDetailed
     */
    'lastLogin': string | null;
}


/**
 * 
 * @export
 * @interface UserDraw
 */
export interface UserDraw {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UserDraw
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserDraw
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserDraw
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserDraw
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserDraw
     */
    'drawScheduleId': string;
    /**
     * 
     * @type {string}
     * @memberof UserDraw
     */
    'drawProductId': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserDraw
     */
    'transactionId': string | null;
    /**
     * 
     * @type {UserDrawStatus}
     * @memberof UserDraw
     */
    'status': UserDrawStatus;
    /**
     * 
     * @type {User}
     * @memberof UserDraw
     */
    'user'?: User | null;
    /**
     * 
     * @type {DrawSchedule}
     * @memberof UserDraw
     */
    'drawSchedule'?: DrawSchedule | null;
    /**
     * 
     * @type {DrawProduct}
     * @memberof UserDraw
     */
    'drawProduct'?: DrawProduct | null;
}


/**
 * 
 * @export
 * @interface UserDrawDetailed
 */
export interface UserDrawDetailed {
    /**
     * 
     * @type {string}
     * @memberof UserDrawDetailed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserDrawDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserDrawDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserDrawDetailed
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserDrawDetailed
     */
    'drawScheduleId': string;
    /**
     * 
     * @type {string}
     * @memberof UserDrawDetailed
     */
    'drawProductId': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserDrawDetailed
     */
    'transactionId': string | null;
    /**
     * 
     * @type {UserDrawStatus}
     * @memberof UserDrawDetailed
     */
    'status': UserDrawStatus;
    /**
     * 
     * @type {User}
     * @memberof UserDrawDetailed
     */
    'user': User | null;
    /**
     * 
     * @type {DrawSchedule}
     * @memberof UserDrawDetailed
     */
    'drawSchedule'?: DrawSchedule | null;
    /**
     * 
     * @type {DrawProductDetailed}
     * @memberof UserDrawDetailed
     */
    'drawProduct': DrawProductDetailed | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserDrawStatus = {
    Claimed: 'CLAIMED',
    NotClaimed: 'NOT_CLAIMED',
    Expired: 'EXPIRED'
} as const;

export type UserDrawStatus = typeof UserDrawStatus[keyof typeof UserDrawStatus];


/**
 * 
 * @export
 * @interface UserInstalledGames
 */
export interface UserInstalledGames {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UserInstalledGames
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserInstalledGames
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserInstalledGames
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserInstalledGames
     */
    'firstInstalledTime': string;
    /**
     * 
     * @type {string}
     * @memberof UserInstalledGames
     */
    'applicationId': string;
    /**
     * 
     * @type {string}
     * @memberof UserInstalledGames
     */
    'userId': string;
    /**
     * 
     * @type {User}
     * @memberof UserInstalledGames
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof UserInstalledGames
     */
    'gameId': string | null;
    /**
     * 
     * @type {Game}
     * @memberof UserInstalledGames
     */
    'game'?: Game | null;
}
/**
 * 
 * @export
 * @interface UserInventory
 */
export interface UserInventory {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UserInventory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserInventory
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserInventory
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserInventory
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserInventory
     */
    'productId': string;
    /**
     * 
     * @type {number}
     * @memberof UserInventory
     */
    'qty': number;
    /**
     * 
     * @type {boolean}
     * @memberof UserInventory
     */
    'seen': boolean;
    /**
     * 
     * @type {User}
     * @memberof UserInventory
     */
    'user'?: User | null;
    /**
     * 
     * @type {Product}
     * @memberof UserInventory
     */
    'product'?: Product | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserInventory
     */
    'default': boolean;
}
/**
 * 
 * @export
 * @interface UserInventoryDetailed
 */
export interface UserInventoryDetailed {
    /**
     * 
     * @type {string}
     * @memberof UserInventoryDetailed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserInventoryDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserInventoryDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserInventoryDetailed
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserInventoryDetailed
     */
    'productId': string;
    /**
     * 
     * @type {number}
     * @memberof UserInventoryDetailed
     */
    'qty': number;
    /**
     * 
     * @type {boolean}
     * @memberof UserInventoryDetailed
     */
    'seen': boolean;
    /**
     * 
     * @type {User}
     * @memberof UserInventoryDetailed
     */
    'user': User | null;
    /**
     * 
     * @type {Product}
     * @memberof UserInventoryDetailed
     */
    'product': Product | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserInventoryDetailed
     */
    'default': boolean;
}
/**
 * 
 * @export
 * @interface UserRoleNew
 */
export interface UserRoleNew {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UserRoleNew
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserRoleNew
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserRoleNew
     */
    'updatedAt': string;
    /**
     * 
     * @type {UserRoleType}
     * @memberof UserRoleNew
     */
    'role': UserRoleType;
    /**
     * 
     * @type {string}
     * @memberof UserRoleNew
     */
    'userId': string;
    /**
     * 
     * @type {User}
     * @memberof UserRoleNew
     */
    'user'?: User;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserRoleType = {
    Creator: 'CREATOR',
    Verified: 'VERIFIED',
    LedgeAdmin: 'LEDGE_ADMIN'
} as const;

export type UserRoleType = typeof UserRoleType[keyof typeof UserRoleType];


/**
 * 
 * @export
 * @interface UserSpinDetailed
 */
export interface UserSpinDetailed {
    /**
     * 
     * @type {string}
     * @memberof UserSpinDetailed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserSpinDetailed
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserSpinDetailed
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserSpinDetailed
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserSpinDetailed
     */
    'productId': string;
    /**
     * 
     * @type {number}
     * @memberof UserSpinDetailed
     */
    'qty': number;
    /**
     * 
     * @type {boolean}
     * @memberof UserSpinDetailed
     */
    'seen': boolean;
    /**
     * 
     * @type {User}
     * @memberof UserSpinDetailed
     */
    'user'?: User | null;
    /**
     * 
     * @type {Product}
     * @memberof UserSpinDetailed
     */
    'product': Product | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserSpinDetailed
     */
    'default': boolean;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof UserSpinDetailed
     */
    'transactions': Array<Transaction> | null;
    /**
     * 
     * @type {Game}
     * @memberof UserSpinDetailed
     */
    'game': Game | null;
}
/**
 * 
 * @export
 * @interface UserWallet
 */
export interface UserWallet {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UserWallet
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserWallet
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserWallet
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserWallet
     */
    'address': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserWallet
     */
    'primary': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserWallet
     */
    'connectorType': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWallet
     */
    'walletClientType': string | null;
    /**
     * 
     * @type {WalletType}
     * @memberof UserWallet
     */
    'walletType': WalletType;
    /**
     * 
     * @type {string}
     * @memberof UserWallet
     */
    'userId': string;
    /**
     * 
     * @type {User}
     * @memberof UserWallet
     */
    'user'?: User;
}


/**
 * 
 * @export
 * @interface ValidateLinkingCode200Response
 */
export interface ValidateLinkingCode200Response {
    /**
     * 
     * @type {string}
     * @memberof ValidateLinkingCode200Response
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ValidateLinkingCode200Response
     */
    'isValid': boolean;
    /**
     * 
     * @type {GameCodeDetailed}
     * @memberof ValidateLinkingCode200Response
     */
    'gameCode': GameCodeDetailed | null;
    /**
     * 
     * @type {User}
     * @memberof ValidateLinkingCode200Response
     */
    'externalUser': User | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WalletType = {
    Ethereum: 'ETHEREUM',
    Solana: 'SOLANA'
} as const;

export type WalletType = typeof WalletType[keyof typeof WalletType];



/**
 * AdminAnnouncementApi - axios parameter creator
 * @export
 */
export const AdminAnnouncementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement: async (body: PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createAnnouncement', 'body', body)
            const localVarPath = `/admin/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAnnouncement', 'id', id)
            const localVarPath = `/admin/announcements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAnnouncements: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} announcementId 
         * @param {PartialCreateAnnouncementArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement: async (announcementId: string, body: PartialCreateAnnouncementArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'announcementId' is not null or undefined
            assertParamExists('updateAnnouncement', 'announcementId', announcementId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateAnnouncement', 'body', body)
            const localVarPath = `/admin/announcements/{announcementId}`
                .replace(`{${"announcementId"}}`, encodeURIComponent(String(announcementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminAnnouncementApi - functional programming interface
 * @export
 */
export const AdminAnnouncementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminAnnouncementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnnouncement(body: PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAnnouncement(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminAnnouncementApi.createAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnnouncement(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAnnouncement(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminAnnouncementApi.deleteAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAnnouncements(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Announcement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAnnouncements(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminAnnouncementApi.getAllAnnouncements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} announcementId 
         * @param {PartialCreateAnnouncementArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAnnouncement(announcementId: string, body: PartialCreateAnnouncementArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAnnouncement(announcementId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminAnnouncementApi.updateAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminAnnouncementApi - factory interface
 * @export
 */
export const AdminAnnouncementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminAnnouncementApiFp(configuration)
    return {
        /**
         * 
         * @param {PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement(body: PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.createAnnouncement(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.deleteAnnouncement(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAnnouncements(options?: RawAxiosRequestConfig): AxiosPromise<Array<Announcement>> {
            return localVarFp.getAllAnnouncements(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} announcementId 
         * @param {PartialCreateAnnouncementArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement(announcementId: string, body: PartialCreateAnnouncementArgs, options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.updateAnnouncement(announcementId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminAnnouncementApi - object-oriented interface
 * @export
 * @class AdminAnnouncementApi
 * @extends {BaseAPI}
 */
export class AdminAnnouncementApi extends BaseAPI {
    /**
     * 
     * @param {PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAnnouncementApi
     */
    public createAnnouncement(body: PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus, options?: RawAxiosRequestConfig) {
        return AdminAnnouncementApiFp(this.configuration).createAnnouncement(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAnnouncementApi
     */
    public deleteAnnouncement(id: string, options?: RawAxiosRequestConfig) {
        return AdminAnnouncementApiFp(this.configuration).deleteAnnouncement(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAnnouncementApi
     */
    public getAllAnnouncements(options?: RawAxiosRequestConfig) {
        return AdminAnnouncementApiFp(this.configuration).getAllAnnouncements(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} announcementId 
     * @param {PartialCreateAnnouncementArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAnnouncementApi
     */
    public updateAnnouncement(announcementId: string, body: PartialCreateAnnouncementArgs, options?: RawAxiosRequestConfig) {
        return AdminAnnouncementApiFp(this.configuration).updateAnnouncement(announcementId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminBannerApi - axios parameter creator
 * @export
 */
export const AdminBannerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateBannerArgs} createBannerArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBanner: async (createBannerArgs: CreateBannerArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBannerArgs' is not null or undefined
            assertParamExists('createBanner', 'createBannerArgs', createBannerArgs)
            const localVarPath = `/admin/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBannerArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBanner: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBanner', 'id', id)
            const localVarPath = `/admin/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getAllBanners', 'eventId', eventId)
            const localVarPath = `/admin/banners/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bannerId 
         * @param {PartialCreateBannerArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBanner: async (bannerId: string, body: PartialCreateBannerArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bannerId' is not null or undefined
            assertParamExists('updateBanner', 'bannerId', bannerId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateBanner', 'body', body)
            const localVarPath = `/admin/banners/{bannerId}`
                .replace(`{${"bannerId"}}`, encodeURIComponent(String(bannerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
         * @param {string} id banner id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBannerImages: async (id: string, imageType: string, file: File, replaceUrl?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadBannerImages', 'id', id)
            // verify required parameter 'imageType' is not null or undefined
            assertParamExists('uploadBannerImages', 'imageType', imageType)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadBannerImages', 'file', file)
            const localVarPath = `/admin/banners/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


            if (imageType !== undefined) { 
                localVarFormParams.append('imageType', imageType as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (replaceUrl !== undefined) { 
                localVarFormParams.append('replaceUrl', replaceUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminBannerApi - functional programming interface
 * @export
 */
export const AdminBannerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminBannerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateBannerArgs} createBannerArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBanner(createBannerArgs: CreateBannerArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBanner(createBannerArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminBannerApi.createBanner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBanner(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBanner(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminBannerApi.deleteBanner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBanners(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBanners(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminBannerApi.getAllBanners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bannerId 
         * @param {PartialCreateBannerArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBanner(bannerId: string, body: PartialCreateBannerArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBanner(bannerId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminBannerApi.updateBanner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
         * @param {string} id banner id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadBannerImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadBannerImages(id, imageType, file, replaceUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminBannerApi.uploadBannerImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminBannerApi - factory interface
 * @export
 */
export const AdminBannerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminBannerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateBannerArgs} createBannerArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBanner(createBannerArgs: CreateBannerArgs, options?: RawAxiosRequestConfig): AxiosPromise<PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt> {
            return localVarFp.createBanner(createBannerArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBanner(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.deleteBanner(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt>> {
            return localVarFp.getAllBanners(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bannerId 
         * @param {PartialCreateBannerArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBanner(bannerId: string, body: PartialCreateBannerArgs, options?: RawAxiosRequestConfig): AxiosPromise<PickBannerOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrBannerLocationOrEventIdOrLogoUrlOrDesktopImageUrlOrMobileImageUrlOrAlt> {
            return localVarFp.updateBanner(bannerId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
         * @param {string} id banner id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBannerImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.uploadBannerImages(id, imageType, file, replaceUrl, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminBannerApi - object-oriented interface
 * @export
 * @class AdminBannerApi
 * @extends {BaseAPI}
 */
export class AdminBannerApi extends BaseAPI {
    /**
     * 
     * @param {CreateBannerArgs} createBannerArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminBannerApi
     */
    public createBanner(createBannerArgs: CreateBannerArgs, options?: RawAxiosRequestConfig) {
        return AdminBannerApiFp(this.configuration).createBanner(createBannerArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminBannerApi
     */
    public deleteBanner(id: string, options?: RawAxiosRequestConfig) {
        return AdminBannerApiFp(this.configuration).deleteBanner(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminBannerApi
     */
    public getAllBanners(eventId: string, options?: RawAxiosRequestConfig) {
        return AdminBannerApiFp(this.configuration).getAllBanners(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bannerId 
     * @param {PartialCreateBannerArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminBannerApi
     */
    public updateBanner(bannerId: string, body: PartialCreateBannerArgs, options?: RawAxiosRequestConfig) {
        return AdminBannerApiFp(this.configuration).updateBanner(bannerId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
     * @param {string} id banner id
     * @param {string} imageType corresponds to the DB column name
     * @param {File} file image to upload to S3
     * @param {string} [replaceUrl] optional url to replace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminBannerApi
     */
    public uploadBannerImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig) {
        return AdminBannerApiFp(this.configuration).uploadBannerImages(id, imageType, file, replaceUrl, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminEventApi - axios parameter creator
 * @export
 */
export const AdminEventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint is for the old system
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetEvent: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminGetEvent', 'id', id)
            const localVarPath = `/admin/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is for the old system
         * @param {CreateEventArgs} createEventArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (createEventArgs: CreateEventArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEventArgs' is not null or undefined
            assertParamExists('createEvent', 'createEventArgs', createEventArgs)
            const localVarPath = `/admin/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is for the old system
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEvent', 'id', id)
            const localVarPath = `/admin/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is for the old system
         * @param {string} eventId 
         * @param {PartialCreateEventArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (eventId: string, body: PartialCreateEventArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEvent', 'eventId', eventId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateEvent', 'body', body)
            const localVarPath = `/admin/events/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
         * @param {string} id event id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadEventImages: async (id: string, imageType: string, file: File, replaceUrl?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadEventImages', 'id', id)
            // verify required parameter 'imageType' is not null or undefined
            assertParamExists('uploadEventImages', 'imageType', imageType)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadEventImages', 'file', file)
            const localVarPath = `/admin/events/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


            if (imageType !== undefined) { 
                localVarFormParams.append('imageType', imageType as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (replaceUrl !== undefined) { 
                localVarFormParams.append('replaceUrl', replaceUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminEventApi - functional programming interface
 * @export
 */
export const AdminEventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminEventApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint is for the old system
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetEvent(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventDetailedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetEvent(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminEventApi.adminGetEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminEventApi.adminGetEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is for the old system
         * @param {CreateEventArgs} createEventArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(createEventArgs: CreateEventArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(createEventArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminEventApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is for the old system
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvent(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminEventApi.deleteEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is for the old system
         * @param {string} eventId 
         * @param {PartialCreateEventArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(eventId: string, body: PartialCreateEventArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(eventId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminEventApi.updateEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
         * @param {string} id event id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadEventImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadEventImages(id, imageType, file, replaceUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminEventApi.uploadEventImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminEventApi - factory interface
 * @export
 */
export const AdminEventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminEventApiFp(configuration)
    return {
        /**
         * This endpoint is for the old system
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetEvent(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetEventDetailedResponse> {
            return localVarFp.adminGetEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetEvents(options?: RawAxiosRequestConfig): AxiosPromise<Array<PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId>> {
            return localVarFp.adminGetEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is for the old system
         * @param {CreateEventArgs} createEventArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(createEventArgs: CreateEventArgs, options?: RawAxiosRequestConfig): AxiosPromise<PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId> {
            return localVarFp.createEvent(createEventArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is for the old system
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.deleteEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is for the old system
         * @param {string} eventId 
         * @param {PartialCreateEventArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(eventId: string, body: PartialCreateEventArgs, options?: RawAxiosRequestConfig): AxiosPromise<PickEventOrIdOrStartTimeOrEndTimeOrStatusOrTitleOrSubtitleOrDescriptionOrImageUrlOrMapCodeOrYoutubeIdOrVideoUrlOrGameId> {
            return localVarFp.updateEvent(eventId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
         * @param {string} id event id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadEventImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.uploadEventImages(id, imageType, file, replaceUrl, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminEventApi - object-oriented interface
 * @export
 * @class AdminEventApi
 * @extends {BaseAPI}
 */
export class AdminEventApi extends BaseAPI {
    /**
     * This endpoint is for the old system
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventApi
     */
    public adminGetEvent(id: string, options?: RawAxiosRequestConfig) {
        return AdminEventApiFp(this.configuration).adminGetEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventApi
     */
    public adminGetEvents(options?: RawAxiosRequestConfig) {
        return AdminEventApiFp(this.configuration).adminGetEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is for the old system
     * @param {CreateEventArgs} createEventArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventApi
     */
    public createEvent(createEventArgs: CreateEventArgs, options?: RawAxiosRequestConfig) {
        return AdminEventApiFp(this.configuration).createEvent(createEventArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is for the old system
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventApi
     */
    public deleteEvent(id: string, options?: RawAxiosRequestConfig) {
        return AdminEventApiFp(this.configuration).deleteEvent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is for the old system
     * @param {string} eventId 
     * @param {PartialCreateEventArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventApi
     */
    public updateEvent(eventId: string, body: PartialCreateEventArgs, options?: RawAxiosRequestConfig) {
        return AdminEventApiFp(this.configuration).updateEvent(eventId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
     * @param {string} id event id
     * @param {string} imageType corresponds to the DB column name
     * @param {File} file image to upload to S3
     * @param {string} [replaceUrl] optional url to replace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventApi
     */
    public uploadEventImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig) {
        return AdminEventApiFp(this.configuration).uploadEventImages(id, imageType, file, replaceUrl, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminEventNewApi - axios parameter creator
 * @export
 */
export const AdminEventNewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetails: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventDetails', 'eventId', eventId)
            const localVarPath = `/admin/events-new/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/events-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminEventNewApi - functional programming interface
 * @export
 */
export const AdminEventNewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminEventNewApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventDetails(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventNew>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventDetails(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminEventNewApi.getEventDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventNew>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminEventNewApi.listEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminEventNewApi - factory interface
 * @export
 */
export const AdminEventNewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminEventNewApiFp(configuration)
    return {
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetails(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventNew> {
            return localVarFp.getEventDetails(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(options?: RawAxiosRequestConfig): AxiosPromise<Array<EventNew>> {
            return localVarFp.listEvents(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminEventNewApi - object-oriented interface
 * @export
 * @class AdminEventNewApi
 * @extends {BaseAPI}
 */
export class AdminEventNewApi extends BaseAPI {
    /**
     * 
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventNewApi
     */
    public getEventDetails(eventId: string, options?: RawAxiosRequestConfig) {
        return AdminEventNewApiFp(this.configuration).getEventDetails(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventNewApi
     */
    public listEvents(options?: RawAxiosRequestConfig) {
        return AdminEventNewApiFp(this.configuration).listEvents(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminGameApi - axios parameter creator
 * @export
 */
export const AdminGameApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Stores newly created external api key for a game.
         * @param {string} id game id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalApiKey: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createExternalApiKey', 'id', id)
            const localVarPath = `/admin/games/{id}/external-api-key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateGameArgs} createGameArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGame: async (createGameArgs: CreateGameArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGameArgs' is not null or undefined
            assertParamExists('createGame', 'createGameArgs', createGameArgs)
            const localVarPath = `/admin/games`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGameArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGame: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGame', 'id', id)
            const localVarPath = `/admin/games/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the external api keys for a game.
         * @param {string} id game id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExternalApiKey: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAllExternalApiKey', 'id', id)
            const localVarPath = `/admin/games/{id}/external-api-keys`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGames: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/games`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGameById', 'id', id)
            const localVarPath = `/admin/games/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing external api key for a game.
         * @param {string} id api key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExternalApiKey: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateExternalApiKey', 'id', id)
            const localVarPath = `/admin/games/{id}/external-api-key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing external api key for a game.
         * @param {Array<UpdateApiKeyArgs>} updateApiKeyArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExternalApiKeyBulk: async (updateApiKeyArgs: Array<UpdateApiKeyArgs>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateApiKeyArgs' is not null or undefined
            assertParamExists('updateExternalApiKeyBulk', 'updateApiKeyArgs', updateApiKeyArgs)
            const localVarPath = `/admin/games/external-api-key/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateApiKeyArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateGameArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGame: async (id: string, body: PartialCreateGameArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGame', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateGame', 'body', body)
            const localVarPath = `/admin/games`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads an image to S3 and updates the game\'s image URL in the database.
         * @param {string} id game id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGameImages: async (id: string, imageType: string, file: File, replaceUrl?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadGameImages', 'id', id)
            // verify required parameter 'imageType' is not null or undefined
            assertParamExists('uploadGameImages', 'imageType', imageType)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadGameImages', 'file', file)
            const localVarPath = `/admin/games/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


            if (imageType !== undefined) { 
                localVarFormParams.append('imageType', imageType as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (replaceUrl !== undefined) { 
                localVarFormParams.append('replaceUrl', replaceUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminGameApi - functional programming interface
 * @export
 */
export const AdminGameApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminGameApiAxiosParamCreator(configuration)
    return {
        /**
         * Stores newly created external api key for a game.
         * @param {string} id game id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExternalApiKey(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExternalApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExternalApiKey(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameApi.createExternalApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateGameArgs} createGameArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGame(createGameArgs: CreateGameArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGamesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGame(createGameArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameApi.createGame']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGame(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGame(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameApi.deleteGame']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the external api keys for a game.
         * @param {string} id game id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllExternalApiKey(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetExternalApiKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllExternalApiKey(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameApi.getAllExternalApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllGames(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetGamesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllGames(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameApi.getAllGames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGameById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGameResponseDetailed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGameById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameApi.getGameById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing external api key for a game.
         * @param {string} id api key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExternalApiKey(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExternalApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExternalApiKey(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameApi.updateExternalApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing external api key for a game.
         * @param {Array<UpdateApiKeyArgs>} updateApiKeyArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExternalApiKeyBulk(updateApiKeyArgs: Array<UpdateApiKeyArgs>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetExternalApiKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExternalApiKeyBulk(updateApiKeyArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameApi.updateExternalApiKeyBulk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateGameArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGame(id: string, body: PartialCreateGameArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGamesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGame(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameApi.updateGame']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads an image to S3 and updates the game\'s image URL in the database.
         * @param {string} id game id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadGameImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadGameImages(id, imageType, file, replaceUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameApi.uploadGameImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminGameApi - factory interface
 * @export
 */
export const AdminGameApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminGameApiFp(configuration)
    return {
        /**
         * Stores newly created external api key for a game.
         * @param {string} id game id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalApiKey(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetExternalApiKeyResponse> {
            return localVarFp.createExternalApiKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateGameArgs} createGameArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGame(createGameArgs: CreateGameArgs, options?: RawAxiosRequestConfig): AxiosPromise<GetGamesResponse> {
            return localVarFp.createGame(createGameArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGame(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.deleteGame(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the external api keys for a game.
         * @param {string} id game id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExternalApiKey(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetExternalApiKeyResponse>> {
            return localVarFp.getAllExternalApiKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGames(options?: RawAxiosRequestConfig): AxiosPromise<Array<GetGamesResponse>> {
            return localVarFp.getAllGames(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetGameResponseDetailed> {
            return localVarFp.getGameById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing external api key for a game.
         * @param {string} id api key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExternalApiKey(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetExternalApiKeyResponse> {
            return localVarFp.updateExternalApiKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing external api key for a game.
         * @param {Array<UpdateApiKeyArgs>} updateApiKeyArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExternalApiKeyBulk(updateApiKeyArgs: Array<UpdateApiKeyArgs>, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetExternalApiKeyResponse>> {
            return localVarFp.updateExternalApiKeyBulk(updateApiKeyArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateGameArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGame(id: string, body: PartialCreateGameArgs, options?: RawAxiosRequestConfig): AxiosPromise<GetGamesResponse> {
            return localVarFp.updateGame(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads an image to S3 and updates the game\'s image URL in the database.
         * @param {string} id game id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGameImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.uploadGameImages(id, imageType, file, replaceUrl, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminGameApi - object-oriented interface
 * @export
 * @class AdminGameApi
 * @extends {BaseAPI}
 */
export class AdminGameApi extends BaseAPI {
    /**
     * Stores newly created external api key for a game.
     * @param {string} id game id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    public createExternalApiKey(id: string, options?: RawAxiosRequestConfig) {
        return AdminGameApiFp(this.configuration).createExternalApiKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateGameArgs} createGameArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    public createGame(createGameArgs: CreateGameArgs, options?: RawAxiosRequestConfig) {
        return AdminGameApiFp(this.configuration).createGame(createGameArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    public deleteGame(id: string, options?: RawAxiosRequestConfig) {
        return AdminGameApiFp(this.configuration).deleteGame(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the external api keys for a game.
     * @param {string} id game id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    public getAllExternalApiKey(id: string, options?: RawAxiosRequestConfig) {
        return AdminGameApiFp(this.configuration).getAllExternalApiKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    public getAllGames(options?: RawAxiosRequestConfig) {
        return AdminGameApiFp(this.configuration).getAllGames(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    public getGameById(id: string, options?: RawAxiosRequestConfig) {
        return AdminGameApiFp(this.configuration).getGameById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing external api key for a game.
     * @param {string} id api key id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    public updateExternalApiKey(id: string, options?: RawAxiosRequestConfig) {
        return AdminGameApiFp(this.configuration).updateExternalApiKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing external api key for a game.
     * @param {Array<UpdateApiKeyArgs>} updateApiKeyArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    public updateExternalApiKeyBulk(updateApiKeyArgs: Array<UpdateApiKeyArgs>, options?: RawAxiosRequestConfig) {
        return AdminGameApiFp(this.configuration).updateExternalApiKeyBulk(updateApiKeyArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PartialCreateGameArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    public updateGame(id: string, body: PartialCreateGameArgs, options?: RawAxiosRequestConfig) {
        return AdminGameApiFp(this.configuration).updateGame(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads an image to S3 and updates the game\'s image URL in the database.
     * @param {string} id game id
     * @param {string} imageType corresponds to the DB column name
     * @param {File} file image to upload to S3
     * @param {string} [replaceUrl] optional url to replace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    public uploadGameImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig) {
        return AdminGameApiFp(this.configuration).uploadGameImages(id, imageType, file, replaceUrl, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminGameLinkApi - axios parameter creator
 * @export
 */
export const AdminGameLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} gameId 
         * @param {PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGameLink: async (gameId: string, body: PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameId' is not null or undefined
            assertParamExists('createGameLink', 'gameId', gameId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createGameLink', 'body', body)
            const localVarPath = `/admin/game-links/{gameId}`
                .replace(`{${"gameId"}}`, encodeURIComponent(String(gameId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGameLink: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGameLink', 'id', id)
            const localVarPath = `/admin/game-links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameLinks: async (gameId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameId' is not null or undefined
            assertParamExists('getGameLinks', 'gameId', gameId)
            const localVarPath = `/admin/game-links/{gameId}`
                .replace(`{${"gameId"}}`, encodeURIComponent(String(gameId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateGameLinkArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGameLink: async (id: string, body: PartialCreateGameLinkArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGameLink', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateGameLink', 'body', body)
            const localVarPath = `/admin/game-links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<UpdateGameLinksBulkArgs>} updateGameLinksBulkArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGameLinks: async (updateGameLinksBulkArgs: Array<UpdateGameLinksBulkArgs>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateGameLinksBulkArgs' is not null or undefined
            assertParamExists('updateGameLinks', 'updateGameLinksBulkArgs', updateGameLinksBulkArgs)
            const localVarPath = `/admin/game-links/bulkUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGameLinksBulkArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminGameLinkApi - functional programming interface
 * @export
 */
export const AdminGameLinkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminGameLinkApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} gameId 
         * @param {PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGameLink(gameId: string, body: PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameLinks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGameLink(gameId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameLinkApi.createGameLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGameLink(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGameLink(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameLinkApi.deleteGameLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGameLinks(gameId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameLinks>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGameLinks(gameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameLinkApi.getGameLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateGameLinkArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGameLink(id: string, body: PartialCreateGameLinkArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameLinks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGameLink(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameLinkApi.updateGameLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<UpdateGameLinksBulkArgs>} updateGameLinksBulkArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGameLinks(updateGameLinksBulkArgs: Array<UpdateGameLinksBulkArgs>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameLinks>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGameLinks(updateGameLinksBulkArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGameLinkApi.updateGameLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminGameLinkApi - factory interface
 * @export
 */
export const AdminGameLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminGameLinkApiFp(configuration)
    return {
        /**
         * 
         * @param {string} gameId 
         * @param {PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGameLink(gameId: string, body: PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId, options?: RawAxiosRequestConfig): AxiosPromise<GameLinks> {
            return localVarFp.createGameLink(gameId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGameLink(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.deleteGameLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameLinks(gameId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GameLinks>> {
            return localVarFp.getGameLinks(gameId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateGameLinkArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGameLink(id: string, body: PartialCreateGameLinkArgs, options?: RawAxiosRequestConfig): AxiosPromise<GameLinks> {
            return localVarFp.updateGameLink(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<UpdateGameLinksBulkArgs>} updateGameLinksBulkArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGameLinks(updateGameLinksBulkArgs: Array<UpdateGameLinksBulkArgs>, options?: RawAxiosRequestConfig): AxiosPromise<Array<GameLinks>> {
            return localVarFp.updateGameLinks(updateGameLinksBulkArgs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminGameLinkApi - object-oriented interface
 * @export
 * @class AdminGameLinkApi
 * @extends {BaseAPI}
 */
export class AdminGameLinkApi extends BaseAPI {
    /**
     * 
     * @param {string} gameId 
     * @param {PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameLinkApi
     */
    public createGameLink(gameId: string, body: PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId, options?: RawAxiosRequestConfig) {
        return AdminGameLinkApiFp(this.configuration).createGameLink(gameId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameLinkApi
     */
    public deleteGameLink(id: string, options?: RawAxiosRequestConfig) {
        return AdminGameLinkApiFp(this.configuration).deleteGameLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} gameId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameLinkApi
     */
    public getGameLinks(gameId: string, options?: RawAxiosRequestConfig) {
        return AdminGameLinkApiFp(this.configuration).getGameLinks(gameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PartialCreateGameLinkArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameLinkApi
     */
    public updateGameLink(id: string, body: PartialCreateGameLinkArgs, options?: RawAxiosRequestConfig) {
        return AdminGameLinkApiFp(this.configuration).updateGameLink(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<UpdateGameLinksBulkArgs>} updateGameLinksBulkArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameLinkApi
     */
    public updateGameLinks(updateGameLinksBulkArgs: Array<UpdateGameLinksBulkArgs>, options?: RawAxiosRequestConfig) {
        return AdminGameLinkApiFp(this.configuration).updateGameLinks(updateGameLinksBulkArgs, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminLeaderboardApi - axios parameter creator
 * @export
 */
export const AdminLeaderboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateLeaderboardArgs} createLeaderboardArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboard: async (createLeaderboardArgs: CreateLeaderboardArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createLeaderboardArgs' is not null or undefined
            assertParamExists('createLeaderboard', 'createLeaderboardArgs', createLeaderboardArgs)
            const localVarPath = `/admin/leaderboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLeaderboardArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboard: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteLeaderboard', 'id', id)
            const localVarPath = `/admin/leaderboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: although its possible for an event to have multiple leaderboards, this endpoint will only return the first one found b/c currently we only do events with one leaderboard. That typically means 1 leaderboard schedule starting/ending at the same time as the event itself. Get a leaderboard by event id
         * @param {string} eventId - The event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboard: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getLeaderboard', 'eventId', eventId)
            const localVarPath = `/admin/leaderboards/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SaveLeaderboardArgs} saveLeaderboardArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboard: async (saveLeaderboardArgs: SaveLeaderboardArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveLeaderboardArgs' is not null or undefined
            assertParamExists('saveLeaderboard', 'saveLeaderboardArgs', saveLeaderboardArgs)
            const localVarPath = `/admin/leaderboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveLeaderboardArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateLeaderboardArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboard: async (id: string, body: PartialCreateLeaderboardArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateLeaderboard', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateLeaderboard', 'body', body)
            const localVarPath = `/admin/leaderboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminLeaderboardApi - functional programming interface
 * @export
 */
export const AdminLeaderboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminLeaderboardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateLeaderboardArgs} createLeaderboardArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLeaderboard(createLeaderboardArgs: CreateLeaderboardArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateLeaderboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLeaderboard(createLeaderboardArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardApi.createLeaderboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLeaderboard(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLeaderboard(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardApi.deleteLeaderboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Note: although its possible for an event to have multiple leaderboards, this endpoint will only return the first one found b/c currently we only do events with one leaderboard. That typically means 1 leaderboard schedule starting/ending at the same time as the event itself. Get a leaderboard by event id
         * @param {string} eventId - The event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeaderboard(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLeaderboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeaderboard(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardApi.getLeaderboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SaveLeaderboardArgs} saveLeaderboardArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveLeaderboard(saveLeaderboardArgs: SaveLeaderboardArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateLeaderboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveLeaderboard(saveLeaderboardArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardApi.saveLeaderboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateLeaderboardArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLeaderboard(id: string, body: PartialCreateLeaderboardArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateLeaderboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLeaderboard(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardApi.updateLeaderboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminLeaderboardApi - factory interface
 * @export
 */
export const AdminLeaderboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminLeaderboardApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateLeaderboardArgs} createLeaderboardArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboard(createLeaderboardArgs: CreateLeaderboardArgs, options?: RawAxiosRequestConfig): AxiosPromise<CreateLeaderboardResponse> {
            return localVarFp.createLeaderboard(createLeaderboardArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboard(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.deleteLeaderboard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Note: although its possible for an event to have multiple leaderboards, this endpoint will only return the first one found b/c currently we only do events with one leaderboard. That typically means 1 leaderboard schedule starting/ending at the same time as the event itself. Get a leaderboard by event id
         * @param {string} eventId - The event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboard(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetLeaderboardResponse> {
            return localVarFp.getLeaderboard(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SaveLeaderboardArgs} saveLeaderboardArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboard(saveLeaderboardArgs: SaveLeaderboardArgs, options?: RawAxiosRequestConfig): AxiosPromise<UpdateLeaderboardResponse> {
            return localVarFp.saveLeaderboard(saveLeaderboardArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateLeaderboardArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboard(id: string, body: PartialCreateLeaderboardArgs, options?: RawAxiosRequestConfig): AxiosPromise<UpdateLeaderboardResponse> {
            return localVarFp.updateLeaderboard(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminLeaderboardApi - object-oriented interface
 * @export
 * @class AdminLeaderboardApi
 * @extends {BaseAPI}
 */
export class AdminLeaderboardApi extends BaseAPI {
    /**
     * 
     * @param {CreateLeaderboardArgs} createLeaderboardArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardApi
     */
    public createLeaderboard(createLeaderboardArgs: CreateLeaderboardArgs, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardApiFp(this.configuration).createLeaderboard(createLeaderboardArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardApi
     */
    public deleteLeaderboard(id: string, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardApiFp(this.configuration).deleteLeaderboard(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: although its possible for an event to have multiple leaderboards, this endpoint will only return the first one found b/c currently we only do events with one leaderboard. That typically means 1 leaderboard schedule starting/ending at the same time as the event itself. Get a leaderboard by event id
     * @param {string} eventId - The event id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardApi
     */
    public getLeaderboard(eventId: string, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardApiFp(this.configuration).getLeaderboard(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SaveLeaderboardArgs} saveLeaderboardArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardApi
     */
    public saveLeaderboard(saveLeaderboardArgs: SaveLeaderboardArgs, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardApiFp(this.configuration).saveLeaderboard(saveLeaderboardArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PartialCreateLeaderboardArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardApi
     */
    public updateLeaderboard(id: string, body: PartialCreateLeaderboardArgs, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardApiFp(this.configuration).updateLeaderboard(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminLeaderboardFactorApi - axios parameter creator
 * @export
 */
export const AdminLeaderboardFactorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardFactor: async (body: PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createLeaderboardFactor', 'body', body)
            const localVarPath = `/admin/leaderboard-factors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardFactor: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteLeaderboardFactor', 'id', id)
            const localVarPath = `/admin/leaderboard-factors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} leaderboardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardFactor: async (leaderboardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leaderboardId' is not null or undefined
            assertParamExists('getLeaderboardFactor', 'leaderboardId', leaderboardId)
            const localVarPath = `/admin/leaderboard-factors/{leaderboardId}`
                .replace(`{${"leaderboardId"}}`, encodeURIComponent(String(leaderboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboardFactor: async (body: PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('saveLeaderboardFactor', 'body', body)
            const localVarPath = `/admin/leaderboard-factors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateLeaderboardFactorArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardFactor: async (id: string, body: PartialCreateLeaderboardFactorArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateLeaderboardFactor', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateLeaderboardFactor', 'body', body)
            const localVarPath = `/admin/leaderboard-factors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminLeaderboardFactorApi - functional programming interface
 * @export
 */
export const AdminLeaderboardFactorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminLeaderboardFactorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLeaderboardFactor(body: PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaderboardFactor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLeaderboardFactor(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardFactorApi.createLeaderboardFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLeaderboardFactor(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLeaderboardFactor(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardFactorApi.deleteLeaderboardFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} leaderboardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeaderboardFactor(leaderboardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickLeaderboardFactorIdOrCreatedAtOrUpdatedAtOrObjectIdOrType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeaderboardFactor(leaderboardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardFactorApi.getLeaderboardFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveLeaderboardFactor(body: PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickLeaderboardFactorIdOrCreatedAtOrUpdatedAtOrObjectIdOrType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveLeaderboardFactor(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardFactorApi.saveLeaderboardFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateLeaderboardFactorArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLeaderboardFactor(id: string, body: PartialCreateLeaderboardFactorArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickLeaderboardFactorIdOrCreatedAtOrUpdatedAtOrObjectIdOrType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLeaderboardFactor(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardFactorApi.updateLeaderboardFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminLeaderboardFactorApi - factory interface
 * @export
 */
export const AdminLeaderboardFactorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminLeaderboardFactorApiFp(configuration)
    return {
        /**
         * 
         * @param {PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardFactor(body: PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId, options?: RawAxiosRequestConfig): AxiosPromise<LeaderboardFactor> {
            return localVarFp.createLeaderboardFactor(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardFactor(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.deleteLeaderboardFactor(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} leaderboardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardFactor(leaderboardId: string, options?: RawAxiosRequestConfig): AxiosPromise<PickLeaderboardFactorIdOrCreatedAtOrUpdatedAtOrObjectIdOrType> {
            return localVarFp.getLeaderboardFactor(leaderboardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboardFactor(body: PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId, options?: RawAxiosRequestConfig): AxiosPromise<PickLeaderboardFactorIdOrCreatedAtOrUpdatedAtOrObjectIdOrType> {
            return localVarFp.saveLeaderboardFactor(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateLeaderboardFactorArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardFactor(id: string, body: PartialCreateLeaderboardFactorArgs, options?: RawAxiosRequestConfig): AxiosPromise<PickLeaderboardFactorIdOrCreatedAtOrUpdatedAtOrObjectIdOrType> {
            return localVarFp.updateLeaderboardFactor(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminLeaderboardFactorApi - object-oriented interface
 * @export
 * @class AdminLeaderboardFactorApi
 * @extends {BaseAPI}
 */
export class AdminLeaderboardFactorApi extends BaseAPI {
    /**
     * 
     * @param {PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardFactorApi
     */
    public createLeaderboardFactor(body: PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardFactorApiFp(this.configuration).createLeaderboardFactor(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardFactorApi
     */
    public deleteLeaderboardFactor(id: string, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardFactorApiFp(this.configuration).deleteLeaderboardFactor(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} leaderboardId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardFactorApi
     */
    public getLeaderboardFactor(leaderboardId: string, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardFactorApiFp(this.configuration).getLeaderboardFactor(leaderboardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardFactorApi
     */
    public saveLeaderboardFactor(body: PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardFactorApiFp(this.configuration).saveLeaderboardFactor(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PartialCreateLeaderboardFactorArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardFactorApi
     */
    public updateLeaderboardFactor(id: string, body: PartialCreateLeaderboardFactorArgs, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardFactorApiFp(this.configuration).updateLeaderboardFactor(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminLeaderboardRewardApi - axios parameter creator
 * @export
 */
export const AdminLeaderboardRewardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateLeaderboardRewardsArgs} createLeaderboardRewardsArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardRewards: async (createLeaderboardRewardsArgs: CreateLeaderboardRewardsArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createLeaderboardRewardsArgs' is not null or undefined
            assertParamExists('createLeaderboardRewards', 'createLeaderboardRewardsArgs', createLeaderboardRewardsArgs)
            const localVarPath = `/admin/leaderboard-rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLeaderboardRewardsArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardReward: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteLeaderboardReward', 'id', id)
            const localVarPath = `/admin/leaderboard-rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} leaderboardScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRewards: async (leaderboardScheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leaderboardScheduleId' is not null or undefined
            assertParamExists('getLeaderboardRewards', 'leaderboardScheduleId', leaderboardScheduleId)
            const localVarPath = `/admin/leaderboard-rewards/{leaderboardScheduleId}`
                .replace(`{${"leaderboardScheduleId"}}`, encodeURIComponent(String(leaderboardScheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} leaderboardScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRewardsSummary: async (leaderboardScheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leaderboardScheduleId' is not null or undefined
            assertParamExists('getLeaderboardRewardsSummary', 'leaderboardScheduleId', leaderboardScheduleId)
            const localVarPath = `/admin/leaderboard-rewards/summary/{leaderboardScheduleId}`
                .replace(`{${"leaderboardScheduleId"}}`, encodeURIComponent(String(leaderboardScheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateLeaderboardRewardsArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboardRewards: async (body: CreateLeaderboardRewardsArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('saveLeaderboardRewards', 'body', body)
            const localVarPath = `/admin/leaderboard-rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardRewards: async (id: string, body: PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateLeaderboardRewards', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateLeaderboardRewards', 'body', body)
            const localVarPath = `/admin/leaderboard-rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminLeaderboardRewardApi - functional programming interface
 * @export
 */
export const AdminLeaderboardRewardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminLeaderboardRewardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateLeaderboardRewardsArgs} createLeaderboardRewardsArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLeaderboardRewards(createLeaderboardRewardsArgs: CreateLeaderboardRewardsArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLeaderboardRewards(createLeaderboardRewardsArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardRewardApi.createLeaderboardRewards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLeaderboardReward(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLeaderboardReward(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardRewardApi.deleteLeaderboardReward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} leaderboardScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeaderboardRewards(leaderboardScheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeaderboardRewards(leaderboardScheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardRewardApi.getLeaderboardRewards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} leaderboardScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeaderboardRewardsSummary(leaderboardScheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetLeaderboardRewardSummaryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeaderboardRewardsSummary(leaderboardScheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardRewardApi.getLeaderboardRewardsSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateLeaderboardRewardsArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveLeaderboardRewards(body: CreateLeaderboardRewardsArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveLeaderboardRewards(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardRewardApi.saveLeaderboardRewards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLeaderboardRewards(id: string, body: PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLeaderboardRewards(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardRewardApi.updateLeaderboardRewards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminLeaderboardRewardApi - factory interface
 * @export
 */
export const AdminLeaderboardRewardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminLeaderboardRewardApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateLeaderboardRewardsArgs} createLeaderboardRewardsArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardRewards(createLeaderboardRewardsArgs: CreateLeaderboardRewardsArgs, options?: RawAxiosRequestConfig): AxiosPromise<BatchPayload> {
            return localVarFp.createLeaderboardRewards(createLeaderboardRewardsArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardReward(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.deleteLeaderboardReward(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} leaderboardScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRewards(leaderboardScheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct>> {
            return localVarFp.getLeaderboardRewards(leaderboardScheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} leaderboardScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRewardsSummary(leaderboardScheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetLeaderboardRewardSummaryResponse>> {
            return localVarFp.getLeaderboardRewardsSummary(leaderboardScheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateLeaderboardRewardsArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboardRewards(body: CreateLeaderboardRewardsArgs, options?: RawAxiosRequestConfig): AxiosPromise<Array<PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct>> {
            return localVarFp.saveLeaderboardRewards(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardRewards(id: string, body: PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId, options?: RawAxiosRequestConfig): AxiosPromise<PickLeaderboardRewardIdOrCreatedAtOrUpdatedAtOrQuantityOrRewardPlaceOrProductIdOrProduct> {
            return localVarFp.updateLeaderboardRewards(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminLeaderboardRewardApi - object-oriented interface
 * @export
 * @class AdminLeaderboardRewardApi
 * @extends {BaseAPI}
 */
export class AdminLeaderboardRewardApi extends BaseAPI {
    /**
     * 
     * @param {CreateLeaderboardRewardsArgs} createLeaderboardRewardsArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardRewardApi
     */
    public createLeaderboardRewards(createLeaderboardRewardsArgs: CreateLeaderboardRewardsArgs, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardRewardApiFp(this.configuration).createLeaderboardRewards(createLeaderboardRewardsArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardRewardApi
     */
    public deleteLeaderboardReward(id: string, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardRewardApiFp(this.configuration).deleteLeaderboardReward(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} leaderboardScheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardRewardApi
     */
    public getLeaderboardRewards(leaderboardScheduleId: string, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardRewardApiFp(this.configuration).getLeaderboardRewards(leaderboardScheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} leaderboardScheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardRewardApi
     */
    public getLeaderboardRewardsSummary(leaderboardScheduleId: string, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardRewardApiFp(this.configuration).getLeaderboardRewardsSummary(leaderboardScheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateLeaderboardRewardsArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardRewardApi
     */
    public saveLeaderboardRewards(body: CreateLeaderboardRewardsArgs, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardRewardApiFp(this.configuration).saveLeaderboardRewards(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardRewardApi
     */
    public updateLeaderboardRewards(id: string, body: PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardRewardApiFp(this.configuration).updateLeaderboardRewards(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminLeaderboardScheduleApi - axios parameter creator
 * @export
 */
export const AdminLeaderboardScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardSchedule: async (body: PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createLeaderboardSchedule', 'body', body)
            const localVarPath = `/admin/leaderboard-schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardSchedule: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteLeaderboardSchedule', 'id', id)
            const localVarPath = `/admin/leaderboard-schedules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} leaderboardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardSchedules: async (leaderboardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leaderboardId' is not null or undefined
            assertParamExists('getLeaderboardSchedules', 'leaderboardId', leaderboardId)
            const localVarPath = `/admin/leaderboard-schedules/{leaderboardId}`
                .replace(`{${"leaderboardId"}}`, encodeURIComponent(String(leaderboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateLeaderboardScheduleArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardSchedule: async (id: string, body: PartialCreateLeaderboardScheduleArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateLeaderboardSchedule', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateLeaderboardSchedule', 'body', body)
            const localVarPath = `/admin/leaderboard-schedules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminLeaderboardScheduleApi - functional programming interface
 * @export
 */
export const AdminLeaderboardScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminLeaderboardScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLeaderboardSchedule(body: PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLeaderboardSchedule(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardScheduleApi.createLeaderboardSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLeaderboardSchedule(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLeaderboardSchedule(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardScheduleApi.deleteLeaderboardSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} leaderboardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeaderboardSchedules(leaderboardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeaderboardSchedules(leaderboardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardScheduleApi.getLeaderboardSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateLeaderboardScheduleArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLeaderboardSchedule(id: string, body: PartialCreateLeaderboardScheduleArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLeaderboardSchedule(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLeaderboardScheduleApi.updateLeaderboardSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminLeaderboardScheduleApi - factory interface
 * @export
 */
export const AdminLeaderboardScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminLeaderboardScheduleApiFp(configuration)
    return {
        /**
         * 
         * @param {PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardSchedule(body: PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId, options?: RawAxiosRequestConfig): AxiosPromise<PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed> {
            return localVarFp.createLeaderboardSchedule(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardSchedule(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.deleteLeaderboardSchedule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} leaderboardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardSchedules(leaderboardId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed>> {
            return localVarFp.getLeaderboardSchedules(leaderboardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateLeaderboardScheduleArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardSchedule(id: string, body: PartialCreateLeaderboardScheduleArgs, options?: RawAxiosRequestConfig): AxiosPromise<PickLeaderboardScheduleOrIdOrCreatedAtOrUpdatedAtOrStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessed> {
            return localVarFp.updateLeaderboardSchedule(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminLeaderboardScheduleApi - object-oriented interface
 * @export
 * @class AdminLeaderboardScheduleApi
 * @extends {BaseAPI}
 */
export class AdminLeaderboardScheduleApi extends BaseAPI {
    /**
     * 
     * @param {PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardScheduleApi
     */
    public createLeaderboardSchedule(body: PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardScheduleApiFp(this.configuration).createLeaderboardSchedule(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardScheduleApi
     */
    public deleteLeaderboardSchedule(id: string, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardScheduleApiFp(this.configuration).deleteLeaderboardSchedule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} leaderboardId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardScheduleApi
     */
    public getLeaderboardSchedules(leaderboardId: string, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardScheduleApiFp(this.configuration).getLeaderboardSchedules(leaderboardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PartialCreateLeaderboardScheduleArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardScheduleApi
     */
    public updateLeaderboardSchedule(id: string, body: PartialCreateLeaderboardScheduleArgs, options?: RawAxiosRequestConfig) {
        return AdminLeaderboardScheduleApiFp(this.configuration).updateLeaderboardSchedule(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminProductApi - axios parameter creator
 * @export
 */
export const AdminProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateProductArgs} createProductArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (createProductArgs: CreateProductArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductArgs' is not null or undefined
            assertParamExists('createProduct', 'createProductArgs', createProductArgs)
            const localVarPath = `/admin/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProduct', 'id', id)
            const localVarPath = `/admin/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<ProductType>} types 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts: async (types: Array<ProductType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'types' is not null or undefined
            assertParamExists('getAllProducts', 'types', types)
            const localVarPath = `/admin/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (types) {
                localVarQueryParameter['types'] = types;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProduct', 'id', id)
            const localVarPath = `/admin/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateProductArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (id: string, body: PartialCreateProductArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProduct', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateProduct', 'body', body)
            const localVarPath = `/admin/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads an image to S3 and updates the product\'s image URL in the database.
         * @param {string} id product id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProductImages: async (id: string, imageType: string, file: File, replaceUrl?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadProductImages', 'id', id)
            // verify required parameter 'imageType' is not null or undefined
            assertParamExists('uploadProductImages', 'imageType', imageType)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadProductImages', 'file', file)
            const localVarPath = `/admin/products/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


            if (imageType !== undefined) { 
                localVarFormParams.append('imageType', imageType as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (replaceUrl !== undefined) { 
                localVarFormParams.append('replaceUrl', replaceUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminProductApi - functional programming interface
 * @export
 */
export const AdminProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateProductArgs} createProductArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(createProductArgs: CreateProductArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(createProductArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminProductApi.createProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminProductApi.deleteProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<ProductType>} types 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProducts(types: Array<ProductType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProducts(types, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminProductApi.getAllProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminProductApi.getProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateProductArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(id: string, body: PartialCreateProductArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminProductApi.updateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads an image to S3 and updates the product\'s image URL in the database.
         * @param {string} id product id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProductImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProductImages(id, imageType, file, replaceUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminProductApi.uploadProductImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminProductApi - factory interface
 * @export
 */
export const AdminProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminProductApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateProductArgs} createProductArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(createProductArgs: CreateProductArgs, options?: RawAxiosRequestConfig): AxiosPromise<PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId> {
            return localVarFp.createProduct(createProductArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.deleteProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<ProductType>} types 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(types: Array<ProductType>, options?: RawAxiosRequestConfig): AxiosPromise<Array<PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId>> {
            return localVarFp.getAllProducts(types, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId> {
            return localVarFp.getProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateProductArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: string, body: PartialCreateProductArgs, options?: RawAxiosRequestConfig): AxiosPromise<PickProductOrIdOrCreatedAtOrUpdatedAtOrTypeOrTitleOrSubTitleOrDescriptionOrInitialQuantityOrIconUrlOrGameId> {
            return localVarFp.updateProduct(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads an image to S3 and updates the product\'s image URL in the database.
         * @param {string} id product id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProductImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.uploadProductImages(id, imageType, file, replaceUrl, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminProductApi - object-oriented interface
 * @export
 * @class AdminProductApi
 * @extends {BaseAPI}
 */
export class AdminProductApi extends BaseAPI {
    /**
     * 
     * @param {CreateProductArgs} createProductArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProductApi
     */
    public createProduct(createProductArgs: CreateProductArgs, options?: RawAxiosRequestConfig) {
        return AdminProductApiFp(this.configuration).createProduct(createProductArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProductApi
     */
    public deleteProduct(id: string, options?: RawAxiosRequestConfig) {
        return AdminProductApiFp(this.configuration).deleteProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<ProductType>} types 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProductApi
     */
    public getAllProducts(types: Array<ProductType>, options?: RawAxiosRequestConfig) {
        return AdminProductApiFp(this.configuration).getAllProducts(types, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProductApi
     */
    public getProduct(id: string, options?: RawAxiosRequestConfig) {
        return AdminProductApiFp(this.configuration).getProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PartialCreateProductArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProductApi
     */
    public updateProduct(id: string, body: PartialCreateProductArgs, options?: RawAxiosRequestConfig) {
        return AdminProductApiFp(this.configuration).updateProduct(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads an image to S3 and updates the product\'s image URL in the database.
     * @param {string} id product id
     * @param {string} imageType corresponds to the DB column name
     * @param {File} file image to upload to S3
     * @param {string} [replaceUrl] optional url to replace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProductApi
     */
    public uploadProductImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig) {
        return AdminProductApiFp(this.configuration).uploadProductImages(id, imageType, file, replaceUrl, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminQuestApi - axios parameter creator
 * @export
 */
export const AdminQuestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} eventId 
         * @param {Array<QuestType>} questTypes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetQuests: async (eventId: string, questTypes: Array<QuestType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('adminGetQuests', 'eventId', eventId)
            // verify required parameter 'questTypes' is not null or undefined
            assertParamExists('adminGetQuests', 'questTypes', questTypes)
            const localVarPath = `/admin/quests/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (questTypes) {
                localVarQueryParameter['questTypes'] = questTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} gameId 
         * @param {string} eventId 
         * @param {CreateQuestGoalArgs} createQuestGoalArgs 
         * @param {string} [questId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuest: async (gameId: string, eventId: string, createQuestGoalArgs: CreateQuestGoalArgs, questId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameId' is not null or undefined
            assertParamExists('createQuest', 'gameId', gameId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createQuest', 'eventId', eventId)
            // verify required parameter 'createQuestGoalArgs' is not null or undefined
            assertParamExists('createQuest', 'createQuestGoalArgs', createQuestGoalArgs)
            const localVarPath = `/admin/quests/{gameId}/{eventId}`
                .replace(`{${"gameId"}}`, encodeURIComponent(String(gameId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (questId !== undefined) {
                localVarQueryParameter['questId'] = questId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createQuestGoalArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the underlying goal and quest.
         * @param {string} questId 
         * @param {string} goalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuest: async (questId: string, goalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questId' is not null or undefined
            assertParamExists('deleteQuest', 'questId', questId)
            // verify required parameter 'goalId' is not null or undefined
            assertParamExists('deleteQuest', 'goalId', goalId)
            const localVarPath = `/admin/quests/{questId}/{goalId}`
                .replace(`{${"questId"}}`, encodeURIComponent(String(questId)))
                .replace(`{${"goalId"}}`, encodeURIComponent(String(goalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} questId 
         * @param {string} goalId 
         * @param {PartialCreateQuestGoalArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuest: async (questId: string, goalId: string, body: PartialCreateQuestGoalArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questId' is not null or undefined
            assertParamExists('updateQuest', 'questId', questId)
            // verify required parameter 'goalId' is not null or undefined
            assertParamExists('updateQuest', 'goalId', goalId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateQuest', 'body', body)
            const localVarPath = `/admin/quests/{questId}/{goalId}`
                .replace(`{${"questId"}}`, encodeURIComponent(String(questId)))
                .replace(`{${"goalId"}}`, encodeURIComponent(String(goalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads an image to S3 and updates the goal\'s (Quest) image URL in the database.
         * @param {string} id goal id not quest id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadQuestGoalImages: async (id: string, imageType: string, file: File, replaceUrl?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadQuestGoalImages', 'id', id)
            // verify required parameter 'imageType' is not null or undefined
            assertParamExists('uploadQuestGoalImages', 'imageType', imageType)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadQuestGoalImages', 'file', file)
            const localVarPath = `/admin/quests/goal/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


            if (imageType !== undefined) { 
                localVarFormParams.append('imageType', imageType as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (replaceUrl !== undefined) { 
                localVarFormParams.append('replaceUrl', replaceUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminQuestApi - functional programming interface
 * @export
 */
export const AdminQuestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminQuestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} eventId 
         * @param {Array<QuestType>} questTypes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetQuests(eventId: string, questTypes: Array<QuestType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetQuestResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetQuests(eventId, questTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuestApi.adminGetQuests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} gameId 
         * @param {string} eventId 
         * @param {CreateQuestGoalArgs} createQuestGoalArgs 
         * @param {string} [questId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuest(gameId: string, eventId: string, createQuestGoalArgs: CreateQuestGoalArgs, questId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateQuestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuest(gameId, eventId, createQuestGoalArgs, questId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuestApi.createQuest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the underlying goal and quest.
         * @param {string} questId 
         * @param {string} goalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQuest(questId: string, goalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQuest(questId, goalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuestApi.deleteQuest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} questId 
         * @param {string} goalId 
         * @param {PartialCreateQuestGoalArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateQuest(questId: string, goalId: string, body: PartialCreateQuestGoalArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateQuestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateQuest(questId, goalId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuestApi.updateQuest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads an image to S3 and updates the goal\'s (Quest) image URL in the database.
         * @param {string} id goal id not quest id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadQuestGoalImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadQuestGoalImages(id, imageType, file, replaceUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuestApi.uploadQuestGoalImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminQuestApi - factory interface
 * @export
 */
export const AdminQuestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminQuestApiFp(configuration)
    return {
        /**
         * 
         * @param {string} eventId 
         * @param {Array<QuestType>} questTypes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetQuests(eventId: string, questTypes: Array<QuestType>, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetQuestResponse>> {
            return localVarFp.adminGetQuests(eventId, questTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} gameId 
         * @param {string} eventId 
         * @param {CreateQuestGoalArgs} createQuestGoalArgs 
         * @param {string} [questId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuest(gameId: string, eventId: string, createQuestGoalArgs: CreateQuestGoalArgs, questId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateQuestResponse> {
            return localVarFp.createQuest(gameId, eventId, createQuestGoalArgs, questId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the underlying goal and quest.
         * @param {string} questId 
         * @param {string} goalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuest(questId: string, goalId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.deleteQuest(questId, goalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} questId 
         * @param {string} goalId 
         * @param {PartialCreateQuestGoalArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuest(questId: string, goalId: string, body: PartialCreateQuestGoalArgs, options?: RawAxiosRequestConfig): AxiosPromise<CreateQuestResponse> {
            return localVarFp.updateQuest(questId, goalId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads an image to S3 and updates the goal\'s (Quest) image URL in the database.
         * @param {string} id goal id not quest id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadQuestGoalImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.uploadQuestGoalImages(id, imageType, file, replaceUrl, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminQuestApi - object-oriented interface
 * @export
 * @class AdminQuestApi
 * @extends {BaseAPI}
 */
export class AdminQuestApi extends BaseAPI {
    /**
     * 
     * @param {string} eventId 
     * @param {Array<QuestType>} questTypes 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestApi
     */
    public adminGetQuests(eventId: string, questTypes: Array<QuestType>, options?: RawAxiosRequestConfig) {
        return AdminQuestApiFp(this.configuration).adminGetQuests(eventId, questTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} gameId 
     * @param {string} eventId 
     * @param {CreateQuestGoalArgs} createQuestGoalArgs 
     * @param {string} [questId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestApi
     */
    public createQuest(gameId: string, eventId: string, createQuestGoalArgs: CreateQuestGoalArgs, questId?: string, options?: RawAxiosRequestConfig) {
        return AdminQuestApiFp(this.configuration).createQuest(gameId, eventId, createQuestGoalArgs, questId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the underlying goal and quest.
     * @param {string} questId 
     * @param {string} goalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestApi
     */
    public deleteQuest(questId: string, goalId: string, options?: RawAxiosRequestConfig) {
        return AdminQuestApiFp(this.configuration).deleteQuest(questId, goalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} questId 
     * @param {string} goalId 
     * @param {PartialCreateQuestGoalArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestApi
     */
    public updateQuest(questId: string, goalId: string, body: PartialCreateQuestGoalArgs, options?: RawAxiosRequestConfig) {
        return AdminQuestApiFp(this.configuration).updateQuest(questId, goalId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads an image to S3 and updates the goal\'s (Quest) image URL in the database.
     * @param {string} id goal id not quest id
     * @param {string} imageType corresponds to the DB column name
     * @param {File} file image to upload to S3
     * @param {string} [replaceUrl] optional url to replace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestApi
     */
    public uploadQuestGoalImages(id: string, imageType: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig) {
        return AdminQuestApiFp(this.configuration).uploadQuestGoalImages(id, imageType, file, replaceUrl, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminQuestRewardApi - axios parameter creator
 * @export
 */
export const AdminQuestRewardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<CreateQuestRewardArgs>} createQuestRewardArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManyQuestRewards: async (createQuestRewardArgs: Array<CreateQuestRewardArgs>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createQuestRewardArgs' is not null or undefined
            assertParamExists('createManyQuestRewards', 'createQuestRewardArgs', createQuestRewardArgs)
            const localVarPath = `/admin/quest-rewards/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createQuestRewardArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateQuestRewardArgs} createQuestRewardArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestReward: async (createQuestRewardArgs: CreateQuestRewardArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createQuestRewardArgs' is not null or undefined
            assertParamExists('createQuestReward', 'createQuestRewardArgs', createQuestRewardArgs)
            const localVarPath = `/admin/quest-rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createQuestRewardArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestReward: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteQuestReward', 'id', id)
            const localVarPath = `/admin/quest-rewards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PartialCreateQuestRewardArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestReward: async (body: PartialCreateQuestRewardArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateQuestReward', 'body', body)
            const localVarPath = `/admin/quest-rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminQuestRewardApi - functional programming interface
 * @export
 */
export const AdminQuestRewardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminQuestRewardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<CreateQuestRewardArgs>} createQuestRewardArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createManyQuestRewards(createQuestRewardArgs: Array<CreateQuestRewardArgs>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createManyQuestRewards(createQuestRewardArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuestRewardApi.createManyQuestRewards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateQuestRewardArgs} createQuestRewardArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuestReward(createQuestRewardArgs: CreateQuestRewardArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetQuestRewardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuestReward(createQuestRewardArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuestRewardApi.createQuestReward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQuestReward(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQuestReward(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuestRewardApi.deleteQuestReward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PartialCreateQuestRewardArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateQuestReward(body: PartialCreateQuestRewardArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetQuestRewardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateQuestReward(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuestRewardApi.updateQuestReward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminQuestRewardApi - factory interface
 * @export
 */
export const AdminQuestRewardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminQuestRewardApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<CreateQuestRewardArgs>} createQuestRewardArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManyQuestRewards(createQuestRewardArgs: Array<CreateQuestRewardArgs>, options?: RawAxiosRequestConfig): AxiosPromise<BatchPayload> {
            return localVarFp.createManyQuestRewards(createQuestRewardArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateQuestRewardArgs} createQuestRewardArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestReward(createQuestRewardArgs: CreateQuestRewardArgs, options?: RawAxiosRequestConfig): AxiosPromise<GetQuestRewardResponse> {
            return localVarFp.createQuestReward(createQuestRewardArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestReward(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteQuestReward(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PartialCreateQuestRewardArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestReward(body: PartialCreateQuestRewardArgs, options?: RawAxiosRequestConfig): AxiosPromise<GetQuestRewardResponse> {
            return localVarFp.updateQuestReward(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminQuestRewardApi - object-oriented interface
 * @export
 * @class AdminQuestRewardApi
 * @extends {BaseAPI}
 */
export class AdminQuestRewardApi extends BaseAPI {
    /**
     * 
     * @param {Array<CreateQuestRewardArgs>} createQuestRewardArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestRewardApi
     */
    public createManyQuestRewards(createQuestRewardArgs: Array<CreateQuestRewardArgs>, options?: RawAxiosRequestConfig) {
        return AdminQuestRewardApiFp(this.configuration).createManyQuestRewards(createQuestRewardArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateQuestRewardArgs} createQuestRewardArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestRewardApi
     */
    public createQuestReward(createQuestRewardArgs: CreateQuestRewardArgs, options?: RawAxiosRequestConfig) {
        return AdminQuestRewardApiFp(this.configuration).createQuestReward(createQuestRewardArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestRewardApi
     */
    public deleteQuestReward(id: string, options?: RawAxiosRequestConfig) {
        return AdminQuestRewardApiFp(this.configuration).deleteQuestReward(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PartialCreateQuestRewardArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestRewardApi
     */
    public updateQuestReward(body: PartialCreateQuestRewardArgs, options?: RawAxiosRequestConfig) {
        return AdminQuestRewardApiFp(this.configuration).updateQuestReward(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminQuestScheduleApi - axios parameter creator
 * @export
 */
export const AdminQuestScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateQuestScheduleArgs} createQuestScheduleArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestSchedule: async (createQuestScheduleArgs: CreateQuestScheduleArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createQuestScheduleArgs' is not null or undefined
            assertParamExists('createQuestSchedule', 'createQuestScheduleArgs', createQuestScheduleArgs)
            const localVarPath = `/admin/quest-schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createQuestScheduleArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestSchedule: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteQuestSchedule', 'id', id)
            const localVarPath = `/admin/quest-schedules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} questId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestSchedules: async (questId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questId' is not null or undefined
            assertParamExists('getQuestSchedules', 'questId', questId)
            const localVarPath = `/admin/quest-schedules/{questId}`
                .replace(`{${"questId"}}`, encodeURIComponent(String(questId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateQuestScheduleArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestSchedule: async (id: string, body: PartialCreateQuestScheduleArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateQuestSchedule', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateQuestSchedule', 'body', body)
            const localVarPath = `/admin/quest-schedules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminQuestScheduleApi - functional programming interface
 * @export
 */
export const AdminQuestScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminQuestScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateQuestScheduleArgs} createQuestScheduleArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuestSchedule(createQuestScheduleArgs: CreateQuestScheduleArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetQuestScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuestSchedule(createQuestScheduleArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuestScheduleApi.createQuestSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQuestSchedule(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQuestSchedule(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuestScheduleApi.deleteQuestSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} questId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestSchedules(questId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetQuestScheduleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestSchedules(questId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuestScheduleApi.getQuestSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateQuestScheduleArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateQuestSchedule(id: string, body: PartialCreateQuestScheduleArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetQuestScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateQuestSchedule(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuestScheduleApi.updateQuestSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminQuestScheduleApi - factory interface
 * @export
 */
export const AdminQuestScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminQuestScheduleApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateQuestScheduleArgs} createQuestScheduleArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestSchedule(createQuestScheduleArgs: CreateQuestScheduleArgs, options?: RawAxiosRequestConfig): AxiosPromise<GetQuestScheduleResponse> {
            return localVarFp.createQuestSchedule(createQuestScheduleArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestSchedule(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.deleteQuestSchedule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} questId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestSchedules(questId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetQuestScheduleResponse>> {
            return localVarFp.getQuestSchedules(questId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PartialCreateQuestScheduleArgs} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestSchedule(id: string, body: PartialCreateQuestScheduleArgs, options?: RawAxiosRequestConfig): AxiosPromise<GetQuestScheduleResponse> {
            return localVarFp.updateQuestSchedule(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminQuestScheduleApi - object-oriented interface
 * @export
 * @class AdminQuestScheduleApi
 * @extends {BaseAPI}
 */
export class AdminQuestScheduleApi extends BaseAPI {
    /**
     * 
     * @param {CreateQuestScheduleArgs} createQuestScheduleArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestScheduleApi
     */
    public createQuestSchedule(createQuestScheduleArgs: CreateQuestScheduleArgs, options?: RawAxiosRequestConfig) {
        return AdminQuestScheduleApiFp(this.configuration).createQuestSchedule(createQuestScheduleArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestScheduleApi
     */
    public deleteQuestSchedule(id: string, options?: RawAxiosRequestConfig) {
        return AdminQuestScheduleApiFp(this.configuration).deleteQuestSchedule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} questId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestScheduleApi
     */
    public getQuestSchedules(questId: string, options?: RawAxiosRequestConfig) {
        return AdminQuestScheduleApiFp(this.configuration).getQuestSchedules(questId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PartialCreateQuestScheduleArgs} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestScheduleApi
     */
    public updateQuestSchedule(id: string, body: PartialCreateQuestScheduleArgs, options?: RawAxiosRequestConfig) {
        return AdminQuestScheduleApiFp(this.configuration).updateQuestSchedule(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminRaffleResultsApi - axios parameter creator
 * @export
 */
export const AdminRaffleResultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the raffle winners by draw schedule id
         * @param {string} drawScheduleId unique id per draw schedule (e.g \&quot;ledge-fortnite-event-draw-schedule\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaffleWinnersByDrawScheduleId: async (drawScheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'drawScheduleId' is not null or undefined
            assertParamExists('getRaffleWinnersByDrawScheduleId', 'drawScheduleId', drawScheduleId)
            const localVarPath = `/admin/raffle-results/winners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (drawScheduleId !== undefined) {
                localVarQueryParameter['drawScheduleId'] = drawScheduleId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminRaffleResultsApi - functional programming interface
 * @export
 */
export const AdminRaffleResultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminRaffleResultsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the raffle winners by draw schedule id
         * @param {string} drawScheduleId unique id per draw schedule (e.g \&quot;ledge-fortnite-event-draw-schedule\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaffleWinnersByDrawScheduleId(drawScheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRaffleResultsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaffleWinnersByDrawScheduleId(drawScheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminRaffleResultsApi.getRaffleWinnersByDrawScheduleId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminRaffleResultsApi - factory interface
 * @export
 */
export const AdminRaffleResultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminRaffleResultsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the raffle winners by draw schedule id
         * @param {string} drawScheduleId unique id per draw schedule (e.g \&quot;ledge-fortnite-event-draw-schedule\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaffleWinnersByDrawScheduleId(drawScheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRaffleResultsResponse>> {
            return localVarFp.getRaffleWinnersByDrawScheduleId(drawScheduleId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminRaffleResultsApi - object-oriented interface
 * @export
 * @class AdminRaffleResultsApi
 * @extends {BaseAPI}
 */
export class AdminRaffleResultsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the raffle winners by draw schedule id
     * @param {string} drawScheduleId unique id per draw schedule (e.g \&quot;ledge-fortnite-event-draw-schedule\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRaffleResultsApi
     */
    public getRaffleWinnersByDrawScheduleId(drawScheduleId: string, options?: RawAxiosRequestConfig) {
        return AdminRaffleResultsApiFp(this.configuration).getRaffleWinnersByDrawScheduleId(drawScheduleId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminUserRoleApi - axios parameter creator
 * @export
 */
export const AdminUserRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user role for a given user id. User\'s can have multiple roles.
         * @param {string} email 
         * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserRole: async (email: string, body: PickPrismaUserRoleNewUncheckedCreateInputRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('createUserRole', 'email', email)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createUserRole', 'body', body)
            const localVarPath = `/admin/user-roles/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRole: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserRole', 'id', id)
            const localVarPath = `/admin/user-roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<UserRoleType>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles: async (roles?: Array<UserRoleType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/user-roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user\'s role type
         * @param {string} id - id of the user role to update
         * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRole: async (id: string, body: PickPrismaUserRoleNewUncheckedCreateInputRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserRole', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateUserRole', 'body', body)
            const localVarPath = `/admin/user-roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminUserRoleApi - functional programming interface
 * @export
 */
export const AdminUserRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminUserRoleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new user role for a given user id. User\'s can have multiple roles.
         * @param {string} email 
         * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserRole(email: string, body: PickPrismaUserRoleNewUncheckedCreateInputRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserRole(email, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUserRoleApi.createUserRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserRole(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserRole(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUserRoleApi.deleteUserRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<UserRoleType>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRoles(roles?: Array<UserRoleType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUserRole>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoles(roles, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUserRoleApi.getUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a user\'s role type
         * @param {string} id - id of the user role to update
         * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserRole(id: string, body: PickPrismaUserRoleNewUncheckedCreateInputRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserRole(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUserRoleApi.updateUserRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminUserRoleApi - factory interface
 * @export
 */
export const AdminUserRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminUserRoleApiFp(configuration)
    return {
        /**
         * Create a new user role for a given user id. User\'s can have multiple roles.
         * @param {string} email 
         * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserRole(email: string, body: PickPrismaUserRoleNewUncheckedCreateInputRole, options?: RawAxiosRequestConfig): AxiosPromise<GetUserRole> {
            return localVarFp.createUserRole(email, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRole(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.deleteUserRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<UserRoleType>} [roles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(roles?: Array<UserRoleType>, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUserRole>> {
            return localVarFp.getUserRoles(roles, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user\'s role type
         * @param {string} id - id of the user role to update
         * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRole(id: string, body: PickPrismaUserRoleNewUncheckedCreateInputRole, options?: RawAxiosRequestConfig): AxiosPromise<GetUserRole> {
            return localVarFp.updateUserRole(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminUserRoleApi - object-oriented interface
 * @export
 * @class AdminUserRoleApi
 * @extends {BaseAPI}
 */
export class AdminUserRoleApi extends BaseAPI {
    /**
     * Create a new user role for a given user id. User\'s can have multiple roles.
     * @param {string} email 
     * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserRoleApi
     */
    public createUserRole(email: string, body: PickPrismaUserRoleNewUncheckedCreateInputRole, options?: RawAxiosRequestConfig) {
        return AdminUserRoleApiFp(this.configuration).createUserRole(email, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserRoleApi
     */
    public deleteUserRole(id: string, options?: RawAxiosRequestConfig) {
        return AdminUserRoleApiFp(this.configuration).deleteUserRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<UserRoleType>} [roles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserRoleApi
     */
    public getUserRoles(roles?: Array<UserRoleType>, options?: RawAxiosRequestConfig) {
        return AdminUserRoleApiFp(this.configuration).getUserRoles(roles, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user\'s role type
     * @param {string} id - id of the user role to update
     * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserRoleApi
     */
    public updateUserRole(id: string, body: PickPrismaUserRoleNewUncheckedCreateInputRole, options?: RawAxiosRequestConfig) {
        return AdminUserRoleApiFp(this.configuration).updateUserRole(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Call on redis service to store access token to enable social client app (e.g discord bot) to use it in subsequent API requests.
         * @param {ConnectionType} applicationType 
         * @param {string} socialUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppToken: async (applicationType: ConnectionType, socialUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationType' is not null or undefined
            assertParamExists('createAppToken', 'applicationType', applicationType)
            // verify required parameter 'socialUserId' is not null or undefined
            assertParamExists('createAppToken', 'socialUserId', socialUserId)
            const localVarPath = `/auth/token/{applicationType}/{socialUserId}`
                .replace(`{${"applicationType"}}`, encodeURIComponent(String(applicationType)))
                .replace(`{${"socialUserId"}}`, encodeURIComponent(String(socialUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Not currently in use. Use case: - Game Studio Devs can call this API from Ledge App to create their own API key and access our external API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Call on redis service to store access token to enable social client app (e.g discord bot) to use it in subsequent API requests.
         * @param {ConnectionType} applicationType 
         * @param {string} socialUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAppToken(applicationType: ConnectionType, socialUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAppToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAppToken(applicationType, socialUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.createAppToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Not currently in use. Use case: - Game Studio Devs can call this API from Ledge App to create their own API key and access our external API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Call on redis service to store access token to enable social client app (e.g discord bot) to use it in subsequent API requests.
         * @param {ConnectionType} applicationType 
         * @param {string} socialUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppToken(applicationType: ConnectionType, socialUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateAppToken200Response> {
            return localVarFp.createAppToken(applicationType, socialUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Not currently in use. Use case: - Game Studio Devs can call this API from Ledge App to create their own API key and access our external API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(options?: RawAxiosRequestConfig): AxiosPromise<GetToken200Response> {
            return localVarFp.getToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Call on redis service to store access token to enable social client app (e.g discord bot) to use it in subsequent API requests.
     * @param {ConnectionType} applicationType 
     * @param {string} socialUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public createAppToken(applicationType: ConnectionType, socialUserId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).createAppToken(applicationType, socialUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Not currently in use. Use case: - Game Studio Devs can call this API from Ledge App to create their own API key and access our external API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getToken(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getToken(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BannersApi - axios parameter creator
 * @export
 */
export const BannersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BannerLocation} bannerLocation 
         * @param {string} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanners: async (bannerLocation: BannerLocation, eventId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bannerLocation' is not null or undefined
            assertParamExists('getBanners', 'bannerLocation', bannerLocation)
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bannerLocation !== undefined) {
                localVarQueryParameter['bannerLocation'] = bannerLocation;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BannersApi - functional programming interface
 * @export
 */
export const BannersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BannersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BannerLocation} bannerLocation 
         * @param {string} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBanners(bannerLocation: BannerLocation, eventId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Banner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBanners(bannerLocation, eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BannersApi.getBanners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BannersApi - factory interface
 * @export
 */
export const BannersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BannersApiFp(configuration)
    return {
        /**
         * 
         * @param {BannerLocation} bannerLocation 
         * @param {string} [eventId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanners(bannerLocation: BannerLocation, eventId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Banner>> {
            return localVarFp.getBanners(bannerLocation, eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BannersApi - object-oriented interface
 * @export
 * @class BannersApi
 * @extends {BaseAPI}
 */
export class BannersApi extends BaseAPI {
    /**
     * 
     * @param {BannerLocation} bannerLocation 
     * @param {string} [eventId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    public getBanners(bannerLocation: BannerLocation, eventId?: string, options?: RawAxiosRequestConfig) {
        return BannersApiFp(this.configuration).getBanners(bannerLocation, eventId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DrawApi - axios parameter creator
 * @export
 */
export const DrawApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} gameId 
         * @param {string} drawScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimReward: async (gameId: string, drawScheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameId' is not null or undefined
            assertParamExists('claimReward', 'gameId', gameId)
            // verify required parameter 'drawScheduleId' is not null or undefined
            assertParamExists('claimReward', 'drawScheduleId', drawScheduleId)
            const localVarPath = `/draw/claim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (gameId !== undefined) {
                localVarQueryParameter['gameId'] = gameId;
            }

            if (drawScheduleId !== undefined) {
                localVarQueryParameter['drawScheduleId'] = drawScheduleId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextActiveDrawSchedule: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getNextActiveDrawSchedule', 'eventId', eventId)
            const localVarPath = `/draw/drawSchedule/active/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousDrawSchedules: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('getPreviousDrawSchedules', 'objectId', objectId)
            const localVarPath = `/draw/drawSchedule/previous/{objectId}`
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since a raffle result (UserDraw) claimable period expires in n days after an event ends, before fetching the raffle result, we need to check and update the UserDraw status accordingly.
         * @param {string} gameId 
         * @param {string} drawScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaffleResult: async (gameId: string, drawScheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameId' is not null or undefined
            assertParamExists('getRaffleResult', 'gameId', gameId)
            // verify required parameter 'drawScheduleId' is not null or undefined
            assertParamExists('getRaffleResult', 'drawScheduleId', drawScheduleId)
            const localVarPath = `/draw/raffle-result/{gameId}/{drawScheduleId}`
                .replace(`{${"gameId"}}`, encodeURIComponent(String(gameId)))
                .replace(`{${"drawScheduleId"}}`, encodeURIComponent(String(drawScheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProcessedDrawSchedule: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getRecentProcessedDrawSchedule', 'eventId', eventId)
            const localVarPath = `/draw/recent-draw-schedule/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DrawApi - functional programming interface
 * @export
 */
export const DrawApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DrawApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} gameId 
         * @param {string} drawScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claimReward(gameId: string, drawScheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDraw>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claimReward(gameId, drawScheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrawApi.claimReward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNextActiveDrawSchedule(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DrawScheduleDetailed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNextActiveDrawSchedule(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrawApi.getNextActiveDrawSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreviousDrawSchedules(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProcessedDrawSchedule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreviousDrawSchedules(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrawApi.getPreviousDrawSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Since a raffle result (UserDraw) claimable period expires in n days after an event ends, before fetching the raffle result, we need to check and update the UserDraw status accordingly.
         * @param {string} gameId 
         * @param {string} drawScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaffleResult(gameId: string, drawScheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDraw>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaffleResult(gameId, drawScheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrawApi.getRaffleResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentProcessedDrawSchedule(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessedDrawSchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentProcessedDrawSchedule(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DrawApi.getRecentProcessedDrawSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DrawApi - factory interface
 * @export
 */
export const DrawApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DrawApiFp(configuration)
    return {
        /**
         * 
         * @param {string} gameId 
         * @param {string} drawScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimReward(gameId: string, drawScheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDraw> {
            return localVarFp.claimReward(gameId, drawScheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextActiveDrawSchedule(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<DrawScheduleDetailed> {
            return localVarFp.getNextActiveDrawSchedule(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousDrawSchedules(objectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProcessedDrawSchedule>> {
            return localVarFp.getPreviousDrawSchedules(objectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Since a raffle result (UserDraw) claimable period expires in n days after an event ends, before fetching the raffle result, we need to check and update the UserDraw status accordingly.
         * @param {string} gameId 
         * @param {string} drawScheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaffleResult(gameId: string, drawScheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDraw> {
            return localVarFp.getRaffleResult(gameId, drawScheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProcessedDrawSchedule(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProcessedDrawSchedule> {
            return localVarFp.getRecentProcessedDrawSchedule(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DrawApi - object-oriented interface
 * @export
 * @class DrawApi
 * @extends {BaseAPI}
 */
export class DrawApi extends BaseAPI {
    /**
     * 
     * @param {string} gameId 
     * @param {string} drawScheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrawApi
     */
    public claimReward(gameId: string, drawScheduleId: string, options?: RawAxiosRequestConfig) {
        return DrawApiFp(this.configuration).claimReward(gameId, drawScheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrawApi
     */
    public getNextActiveDrawSchedule(eventId: string, options?: RawAxiosRequestConfig) {
        return DrawApiFp(this.configuration).getNextActiveDrawSchedule(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrawApi
     */
    public getPreviousDrawSchedules(objectId: string, options?: RawAxiosRequestConfig) {
        return DrawApiFp(this.configuration).getPreviousDrawSchedules(objectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since a raffle result (UserDraw) claimable period expires in n days after an event ends, before fetching the raffle result, we need to check and update the UserDraw status accordingly.
     * @param {string} gameId 
     * @param {string} drawScheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrawApi
     */
    public getRaffleResult(gameId: string, drawScheduleId: string, options?: RawAxiosRequestConfig) {
        return DrawApiFp(this.configuration).getRaffleResult(gameId, drawScheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrawApi
     */
    public getRecentProcessedDrawSchedule(eventId: string, options?: RawAxiosRequestConfig) {
        return DrawApiFp(this.configuration).getRecentProcessedDrawSchedule(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a specified number of leaderboard win codes for the given game. Requires `write:game-code` permission.
         * @param {GenerateLeaderboardWinCodesRequest} generateLeaderboardWinCodesRequest numOfCodes: the number of codes to generate, eventId: the id of the event to generate codes for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLeaderboardWinCodes: async (generateLeaderboardWinCodesRequest: GenerateLeaderboardWinCodesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateLeaderboardWinCodesRequest' is not null or undefined
            assertParamExists('generateLeaderboardWinCodes', 'generateLeaderboardWinCodesRequest', generateLeaderboardWinCodesRequest)
            const localVarPath = `/events/generate-lb-win-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tsoa_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "tsoa_auth", ["write:game-code"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateLeaderboardWinCodesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all events sorted and filtered by status and end time. See repository for more details. Also map event details to include lobby details.
         * @param {Array<EventStatus>} includeStatuses 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvents: async (includeStatuses: Array<EventStatus>, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'includeStatuses' is not null or undefined
            assertParamExists('getAllEvents', 'includeStatuses', includeStatuses)
            const localVarPath = `/events/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeStatuses) {
                localVarQueryParameter['includeStatuses'] = includeStatuses;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEvent', 'eventId', eventId)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEvent: async (gameId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameId' is not null or undefined
            assertParamExists('getLatestEvent', 'gameId', gameId)
            const localVarPath = `/events/latest/{gameId}`
                .replace(`{${"gameId"}}`, encodeURIComponent(String(gameId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the joined status and timestamp of a user for a specific event.
         * @param {string} eventId The ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserJoinedStatus: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getUserJoinedStatus', 'eventId', eventId)
            const localVarPath = `/events/join/{eventId}/status`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Join an event with the specified eventId, userId, and timestamp.
         * @param {string} eventId The ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinEvent: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('joinEvent', 'eventId', eventId)
            const localVarPath = `/events/join/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates a specified number of leaderboard win codes for the given game. Requires `write:game-code` permission.
         * @param {GenerateLeaderboardWinCodesRequest} generateLeaderboardWinCodesRequest numOfCodes: the number of codes to generate, eventId: the id of the event to generate codes for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateLeaderboardWinCodes(generateLeaderboardWinCodesRequest: GenerateLeaderboardWinCodesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateLeaderboardWinCodes(generateLeaderboardWinCodesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.generateLeaderboardWinCodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all events sorted and filtered by status and end time. See repository for more details. Also map event details to include lobby details.
         * @param {Array<EventStatus>} includeStatuses 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEvents(includeStatuses: Array<EventStatus>, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGetEventWithLobbyDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEvents(includeStatuses, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getAllEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvent(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvent(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestEvent(gameId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestEvent(gameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getLatestEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the joined status and timestamp of a user for a specific event.
         * @param {string} eventId The ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserJoinedStatus(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserJoinedStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserJoinedStatus(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getUserJoinedStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Join an event with the specified eventId, userId, and timestamp.
         * @param {string} eventId The ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinEvent(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinEvent(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.joinEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Generates a specified number of leaderboard win codes for the given game. Requires `write:game-code` permission.
         * @param {GenerateLeaderboardWinCodesRequest} generateLeaderboardWinCodesRequest numOfCodes: the number of codes to generate, eventId: the id of the event to generate codes for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLeaderboardWinCodes(generateLeaderboardWinCodesRequest: GenerateLeaderboardWinCodesRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.generateLeaderboardWinCodes(generateLeaderboardWinCodesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all events sorted and filtered by status and end time. See repository for more details. Also map event details to include lobby details.
         * @param {Array<EventStatus>} includeStatuses 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvents(includeStatuses: Array<EventStatus>, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedGetEventWithLobbyDetailsResponse> {
            return localVarFp.getAllEvents(includeStatuses, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.getEvent(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEvent(gameId: string, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.getLatestEvent(gameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the joined status and timestamp of a user for a specific event.
         * @param {string} eventId The ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserJoinedStatus(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetUserJoinedStatus200Response> {
            return localVarFp.getUserJoinedStatus(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Join an event with the specified eventId, userId, and timestamp.
         * @param {string} eventId The ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinEvent(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.joinEvent(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Generates a specified number of leaderboard win codes for the given game. Requires `write:game-code` permission.
     * @param {GenerateLeaderboardWinCodesRequest} generateLeaderboardWinCodesRequest numOfCodes: the number of codes to generate, eventId: the id of the event to generate codes for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public generateLeaderboardWinCodes(generateLeaderboardWinCodesRequest: GenerateLeaderboardWinCodesRequest, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).generateLeaderboardWinCodes(generateLeaderboardWinCodesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all events sorted and filtered by status and end time. See repository for more details. Also map event details to include lobby details.
     * @param {Array<EventStatus>} includeStatuses 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getAllEvents(includeStatuses: Array<EventStatus>, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getAllEvents(includeStatuses, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvent(eventId: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} gameId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getLatestEvent(gameId: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getLatestEvent(gameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the joined status and timestamp of a user for a specific event.
     * @param {string} eventId The ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getUserJoinedStatus(eventId: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getUserJoinedStatus(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Join an event with the specified eventId, userId, and timestamp.
     * @param {string} eventId The ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public joinEvent(eventId: string, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).joinEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventsNewApi - axios parameter creator
 * @export
 */
export const EventsNewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<EventStatus>} [statuses] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserEvents: async (statuses?: Array<EventStatus>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requires `creator` role.
         * @param {SaveEventDetailsArgs} saveEventDetailsArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEvent: async (saveEventDetailsArgs: SaveEventDetailsArgs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveEventDetailsArgs' is not null or undefined
            assertParamExists('saveEvent', 'saveEventDetailsArgs', saveEventDetailsArgs)
            const localVarPath = `/events-new/save`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveEventDetailsArgs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads an image to S3 and updates the event\'s thumbnail URL in the database.
         * @param {string} eventId event id
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadThumbnail: async (eventId: string, file: File, replaceUrl?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('uploadThumbnail', 'eventId', eventId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadThumbnail', 'file', file)
            const localVarPath = `/events-new/{eventId}/thumbnail`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (replaceUrl !== undefined) { 
                localVarFormParams.append('replaceUrl', replaceUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsNewApi - functional programming interface
 * @export
 */
export const EventsNewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsNewApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<EventStatus>} [statuses] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserEvents(statuses?: Array<EventStatus>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventNew>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserEvents(statuses, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsNewApi.listUserEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Requires `creator` role.
         * @param {SaveEventDetailsArgs} saveEventDetailsArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveEvent(saveEventDetailsArgs: SaveEventDetailsArgs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventNew>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveEvent(saveEventDetailsArgs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsNewApi.saveEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uploads an image to S3 and updates the event\'s thumbnail URL in the database.
         * @param {string} eventId event id
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadThumbnail(eventId: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadThumbnail(eventId, file, replaceUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsNewApi.uploadThumbnail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsNewApi - factory interface
 * @export
 */
export const EventsNewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsNewApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<EventStatus>} [statuses] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserEvents(statuses?: Array<EventStatus>, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventNew>> {
            return localVarFp.listUserEvents(statuses, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires `creator` role.
         * @param {SaveEventDetailsArgs} saveEventDetailsArgs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEvent(saveEventDetailsArgs: SaveEventDetailsArgs, options?: RawAxiosRequestConfig): AxiosPromise<EventNew> {
            return localVarFp.saveEvent(saveEventDetailsArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads an image to S3 and updates the event\'s thumbnail URL in the database.
         * @param {string} eventId event id
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadThumbnail(eventId: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.uploadThumbnail(eventId, file, replaceUrl, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsNewApi - object-oriented interface
 * @export
 * @class EventsNewApi
 * @extends {BaseAPI}
 */
export class EventsNewApi extends BaseAPI {
    /**
     * 
     * @param {Array<EventStatus>} [statuses] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsNewApi
     */
    public listUserEvents(statuses?: Array<EventStatus>, options?: RawAxiosRequestConfig) {
        return EventsNewApiFp(this.configuration).listUserEvents(statuses, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Requires `creator` role.
     * @param {SaveEventDetailsArgs} saveEventDetailsArgs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsNewApi
     */
    public saveEvent(saveEventDetailsArgs: SaveEventDetailsArgs, options?: RawAxiosRequestConfig) {
        return EventsNewApiFp(this.configuration).saveEvent(saveEventDetailsArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads an image to S3 and updates the event\'s thumbnail URL in the database.
     * @param {string} eventId event id
     * @param {File} file image to upload to S3
     * @param {string} [replaceUrl] optional url to replace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsNewApi
     */
    public uploadThumbnail(eventId: string, file: File, replaceUrl?: string, options?: RawAxiosRequestConfig) {
        return EventsNewApiFp(this.configuration).uploadThumbnail(eventId, file, replaceUrl, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GameCodeApi - axios parameter creator
 * @export
 */
export const GameCodeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProcessGameCodeRequest} processGameCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processGameCode: async (processGameCodeRequest: ProcessGameCodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'processGameCodeRequest' is not null or undefined
            assertParamExists('processGameCode', 'processGameCodeRequest', processGameCodeRequest)
            const localVarPath = `/gameCode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processGameCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} linkingCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLinkingCode: async (linkingCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkingCode' is not null or undefined
            assertParamExists('validateLinkingCode', 'linkingCode', linkingCode)
            const localVarPath = `/gameCode/validate-linking-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (linkingCode !== undefined) {
                localVarQueryParameter['linkingCode'] = linkingCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameCodeApi - functional programming interface
 * @export
 */
export const GameCodeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GameCodeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ProcessGameCodeRequest} processGameCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processGameCode(processGameCodeRequest: ProcessGameCodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAnnouncement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processGameCode(processGameCodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameCodeApi.processGameCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} linkingCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateLinkingCode(linkingCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateLinkingCode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateLinkingCode(linkingCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameCodeApi.validateLinkingCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GameCodeApi - factory interface
 * @export
 */
export const GameCodeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GameCodeApiFp(configuration)
    return {
        /**
         * 
         * @param {ProcessGameCodeRequest} processGameCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processGameCode(processGameCodeRequest: ProcessGameCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAnnouncement200Response> {
            return localVarFp.processGameCode(processGameCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} linkingCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLinkingCode(linkingCode: string, options?: RawAxiosRequestConfig): AxiosPromise<ValidateLinkingCode200Response> {
            return localVarFp.validateLinkingCode(linkingCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GameCodeApi - object-oriented interface
 * @export
 * @class GameCodeApi
 * @extends {BaseAPI}
 */
export class GameCodeApi extends BaseAPI {
    /**
     * 
     * @param {ProcessGameCodeRequest} processGameCodeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameCodeApi
     */
    public processGameCode(processGameCodeRequest: ProcessGameCodeRequest, options?: RawAxiosRequestConfig) {
        return GameCodeApiFp(this.configuration).processGameCode(processGameCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} linkingCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameCodeApi
     */
    public validateLinkingCode(linkingCode: string, options?: RawAxiosRequestConfig) {
        return GameCodeApiFp(this.configuration).validateLinkingCode(linkingCode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GamesApi - axios parameter creator
 * @export
 */
export const GamesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns games in which Ledge users can create events for.
         * @param {number} [page] - The current page index (default is 0).
         * @param {number} [limit] - The number of items per page (default is 10).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventGames: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/games/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGame: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getGame', 'eventId', eventId)
            const localVarPath = `/games/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GamesApi - functional programming interface
 * @export
 */
export const GamesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GamesApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns games in which Ledge users can create events for.
         * @param {number} [page] - The current page index (default is 0).
         * @param {number} [limit] - The number of items per page (default is 10).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventGames(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedEventGame>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventGames(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamesApi.getEventGames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGame(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameDetailed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGame(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GamesApi.getGame']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GamesApi - factory interface
 * @export
 */
export const GamesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GamesApiFp(configuration)
    return {
        /**
         * This endpoint returns games in which Ledge users can create events for.
         * @param {number} [page] - The current page index (default is 0).
         * @param {number} [limit] - The number of items per page (default is 10).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventGames(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedEventGame> {
            return localVarFp.getEventGames(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGame(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<GameDetailed> {
            return localVarFp.getGame(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GamesApi - object-oriented interface
 * @export
 * @class GamesApi
 * @extends {BaseAPI}
 */
export class GamesApi extends BaseAPI {
    /**
     * This endpoint returns games in which Ledge users can create events for.
     * @param {number} [page] - The current page index (default is 0).
     * @param {number} [limit] - The number of items per page (default is 10).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamesApi
     */
    public getEventGames(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return GamesApiFp(this.configuration).getEventGames(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamesApi
     */
    public getGame(eventId: string, options?: RawAxiosRequestConfig) {
        return GamesApiFp(this.configuration).getGame(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GuestApi - axios parameter creator
 * @export
 */
export const GuestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveAnnouncement: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/guest/active-announcement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuestApi - functional programming interface
 * @export
 */
export const GuestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GuestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveAnnouncement(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveAnnouncement(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getActiveAnnouncement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GuestApi - factory interface
 * @export
 */
export const GuestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GuestApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveAnnouncement(options?: RawAxiosRequestConfig): AxiosPromise<Announcement> {
            return localVarFp.getActiveAnnouncement(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GuestApi - object-oriented interface
 * @export
 * @class GuestApi
 * @extends {BaseAPI}
 */
export class GuestApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getActiveAnnouncement(options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getActiveAnnouncement(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InventoryApi - axios parameter creator
 * @export
 */
export const InventoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<ProductType>} productTypes 
         * @param {boolean} [isDefault] 
         * @param {boolean} [isSeen] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventory: async (productTypes: Array<ProductType>, isDefault?: boolean, isSeen?: boolean, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productTypes' is not null or undefined
            assertParamExists('getInventory', 'productTypes', productTypes)
            const localVarPath = `/inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (productTypes) {
                localVarQueryParameter['productTypes'] = productTypes;
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['isDefault'] = isDefault;
            }

            if (isSeen !== undefined) {
                localVarQueryParameter['isSeen'] = isSeen;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This should return current user\'s raffle entires and return total entries for given productId. productId CAN come from Draw table ticketId
         * @param {string} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCount: async (productId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/inventory/item-counts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductIdCount: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductIdCount', 'productId', productId)
            const localVarPath = `/inventory/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProductType} spinType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpinCase: async (spinType: ProductType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spinType' is not null or undefined
            assertParamExists('getSpinCase', 'spinType', spinType)
            const localVarPath = `/inventory/SpinCase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (spinType !== undefined) {
                localVarQueryParameter['spinType'] = spinType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} inventoryId 
         * @param {UserInventory} userInventory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventory: async (inventoryId: string, userInventory: UserInventory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inventoryId' is not null or undefined
            assertParamExists('updateInventory', 'inventoryId', inventoryId)
            // verify required parameter 'userInventory' is not null or undefined
            assertParamExists('updateInventory', 'userInventory', userInventory)
            const localVarPath = `/inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (inventoryId !== undefined) {
                localVarQueryParameter['inventoryId'] = inventoryId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInventory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateProfileRequest} updateProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile: async (updateProfileRequest: UpdateProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfileRequest' is not null or undefined
            assertParamExists('updateProfile', 'updateProfileRequest', updateProfileRequest)
            const localVarPath = `/inventory/update-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoryApi - functional programming interface
 * @export
 */
export const InventoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InventoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<ProductType>} productTypes 
         * @param {boolean} [isDefault] 
         * @param {boolean} [isSeen] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInventory(productTypes: Array<ProductType>, isDefault?: boolean, isSeen?: boolean, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInventoryDetailed>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInventory(productTypes, isDefault, isSeen, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.getInventory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This should return current user\'s raffle entires and return total entries for given productId. productId CAN come from Draw table ticketId
         * @param {string} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemCount(productId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItemCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemCount(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.getItemCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductIdCount(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductIdCount(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.getProductIdCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ProductType} spinType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpinCase(spinType: ProductType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSpinDetailed>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpinCase(spinType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.getSpinCase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} inventoryId 
         * @param {UserInventory} userInventory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInventory(inventoryId: string, userInventory: UserInventory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInventory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInventory(inventoryId, userInventory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.updateInventory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateProfileRequest} updateProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfile(updateProfileRequest: UpdateProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInventory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfile(updateProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InventoryApi.updateProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InventoryApi - factory interface
 * @export
 */
export const InventoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InventoryApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<ProductType>} productTypes 
         * @param {boolean} [isDefault] 
         * @param {boolean} [isSeen] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventory(productTypes: Array<ProductType>, isDefault?: boolean, isSeen?: boolean, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserInventoryDetailed>> {
            return localVarFp.getInventory(productTypes, isDefault, isSeen, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * This should return current user\'s raffle entires and return total entries for given productId. productId CAN come from Draw table ticketId
         * @param {string} [productId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCount(productId?: string, options?: RawAxiosRequestConfig): AxiosPromise<InventoryItemCount> {
            return localVarFp.getItemCount(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductIdCount(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getProductIdCount(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProductType} spinType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpinCase(spinType: ProductType, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSpinDetailed>> {
            return localVarFp.getSpinCase(spinType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} inventoryId 
         * @param {UserInventory} userInventory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventory(inventoryId: string, userInventory: UserInventory, options?: RawAxiosRequestConfig): AxiosPromise<UserInventory> {
            return localVarFp.updateInventory(inventoryId, userInventory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateProfileRequest} updateProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(updateProfileRequest: UpdateProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserInventory> {
            return localVarFp.updateProfile(updateProfileRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InventoryApi - object-oriented interface
 * @export
 * @class InventoryApi
 * @extends {BaseAPI}
 */
export class InventoryApi extends BaseAPI {
    /**
     * 
     * @param {Array<ProductType>} productTypes 
     * @param {boolean} [isDefault] 
     * @param {boolean} [isSeen] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getInventory(productTypes: Array<ProductType>, isDefault?: boolean, isSeen?: boolean, userId?: string, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).getInventory(productTypes, isDefault, isSeen, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This should return current user\'s raffle entires and return total entries for given productId. productId CAN come from Draw table ticketId
     * @param {string} [productId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getItemCount(productId?: string, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).getItemCount(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getProductIdCount(productId: string, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).getProductIdCount(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProductType} spinType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public getSpinCase(spinType: ProductType, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).getSpinCase(spinType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} inventoryId 
     * @param {UserInventory} userInventory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public updateInventory(inventoryId: string, userInventory: UserInventory, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).updateInventory(inventoryId, userInventory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateProfileRequest} updateProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    public updateProfile(updateProfileRequest: UpdateProfileRequest, options?: RawAxiosRequestConfig) {
        return InventoryApiFp(this.configuration).updateProfile(updateProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LeaderboardApi - axios parameter creator
 * @export
 */
export const LeaderboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} leaderboardScheduleId 
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardScore: async (leaderboardScheduleId: string, gameId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'leaderboardScheduleId' is not null or undefined
            assertParamExists('getLeaderboardScore', 'leaderboardScheduleId', leaderboardScheduleId)
            // verify required parameter 'gameId' is not null or undefined
            assertParamExists('getLeaderboardScore', 'gameId', gameId)
            const localVarPath = `/leaderboard/scores`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (leaderboardScheduleId !== undefined) {
                localVarQueryParameter['leaderboardScheduleId'] = leaderboardScheduleId;
            }

            if (gameId !== undefined) {
                localVarQueryParameter['gameId'] = gameId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} eventId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMostRecentLeaderboardSchedules: async (eventId: string, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getMostRecentLeaderboardSchedules', 'eventId', eventId)
            const localVarPath = `/leaderboard/recent-schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeaderboardApi - functional programming interface
 * @export
 */
export const LeaderboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeaderboardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} leaderboardScheduleId 
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeaderboardScore(leaderboardScheduleId: string, gameId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaderboardScore>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeaderboardScore(leaderboardScheduleId, gameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaderboardApi.getLeaderboardScore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} eventId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMostRecentLeaderboardSchedules(eventId: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LeaderboardScheduleDetailed>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMostRecentLeaderboardSchedules(eventId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaderboardApi.getMostRecentLeaderboardSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LeaderboardApi - factory interface
 * @export
 */
export const LeaderboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeaderboardApiFp(configuration)
    return {
        /**
         * 
         * @param {string} leaderboardScheduleId 
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardScore(leaderboardScheduleId: string, gameId: string, options?: RawAxiosRequestConfig): AxiosPromise<LeaderboardScore> {
            return localVarFp.getLeaderboardScore(leaderboardScheduleId, gameId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} eventId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMostRecentLeaderboardSchedules(eventId: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<LeaderboardScheduleDetailed>> {
            return localVarFp.getMostRecentLeaderboardSchedules(eventId, page, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeaderboardApi - object-oriented interface
 * @export
 * @class LeaderboardApi
 * @extends {BaseAPI}
 */
export class LeaderboardApi extends BaseAPI {
    /**
     * 
     * @param {string} leaderboardScheduleId 
     * @param {string} gameId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public getLeaderboardScore(leaderboardScheduleId: string, gameId: string, options?: RawAxiosRequestConfig) {
        return LeaderboardApiFp(this.configuration).getLeaderboardScore(leaderboardScheduleId, gameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} eventId 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public getMostRecentLeaderboardSchedules(eventId: string, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return LeaderboardApiFp(this.configuration).getMostRecentLeaderboardSchedules(eventId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LeaderboardResultApi - axios parameter creator
 * @export
 */
export const LeaderboardResultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get leaderboard results for a given event
         * @param {string} eventId The ID of the event to get leaderboard results for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardResults: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getLeaderboardResults', 'eventId', eventId)
            const localVarPath = `/leaderboard-results`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeaderboardResultApi - functional programming interface
 * @export
 */
export const LeaderboardResultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeaderboardResultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get leaderboard results for a given event
         * @param {string} eventId The ID of the event to get leaderboard results for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeaderboardResults(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeaderboardResults(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaderboardResultApi.getLeaderboardResults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LeaderboardResultApi - factory interface
 * @export
 */
export const LeaderboardResultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeaderboardResultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get leaderboard results for a given event
         * @param {string} eventId The ID of the event to get leaderboard results for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardResults(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<any>> {
            return localVarFp.getLeaderboardResults(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeaderboardResultApi - object-oriented interface
 * @export
 * @class LeaderboardResultApi
 * @extends {BaseAPI}
 */
export class LeaderboardResultApi extends BaseAPI {
    /**
     * 
     * @summary Get leaderboard results for a given event
     * @param {string} eventId The ID of the event to get leaderboard results for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardResultApi
     */
    public getLeaderboardResults(eventId: string, options?: RawAxiosRequestConfig) {
        return LeaderboardResultApiFp(this.configuration).getLeaderboardResults(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ClaimPrizeRequest} claimPrizeRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        claimPrize: async (claimPrizeRequest: ClaimPrizeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'claimPrizeRequest' is not null or undefined
            assertParamExists('claimPrize', 'claimPrizeRequest', claimPrizeRequest)
            const localVarPath = `/notification/claim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(claimPrizeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClaimPrizeRequest} claimPrizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimPrizeNew: async (claimPrizeRequest: ClaimPrizeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'claimPrizeRequest' is not null or undefined
            assertParamExists('claimPrizeNew', 'claimPrizeRequest', claimPrizeRequest)
            const localVarPath = `/notification/claim-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(claimPrizeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreatePrizeDeliveredNotificationRequest} createPrizeDeliveredNotificationRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createPrizeDeliveredNotification: async (createPrizeDeliveredNotificationRequest: CreatePrizeDeliveredNotificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPrizeDeliveredNotificationRequest' is not null or undefined
            assertParamExists('createPrizeDeliveredNotification', 'createPrizeDeliveredNotificationRequest', createPrizeDeliveredNotificationRequest)
            const localVarPath = `/notification/prize-delivered-notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tsoa_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "tsoa_auth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPrizeDeliveredNotificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteById', 'id', id)
            const localVarPath = `/notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {GetNotificationsOrderByCreatedEnum} [orderByCreated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (page?: number, limit?: number, orderByCreated?: GetNotificationsOrderByCreatedEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderByCreated !== undefined) {
                localVarQueryParameter['orderByCreated'] = orderByCreated;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateNotificationsRequest} updateNotificationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotifications: async (updateNotificationsRequest: UpdateNotificationsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateNotificationsRequest' is not null or undefined
            assertParamExists('updateNotifications', 'updateNotificationsRequest', updateNotificationsRequest)
            const localVarPath = `/notification/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ClaimPrizeRequest} claimPrizeRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async claimPrize(claimPrizeRequest: ClaimPrizeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePrizeDeliveredNotification200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claimPrize(claimPrizeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.claimPrize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ClaimPrizeRequest} claimPrizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claimPrizeNew(claimPrizeRequest: ClaimPrizeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClaimPrizeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claimPrizeNew(claimPrizeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.claimPrizeNew']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreatePrizeDeliveredNotificationRequest} createPrizeDeliveredNotificationRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createPrizeDeliveredNotification(createPrizeDeliveredNotificationRequest: CreatePrizeDeliveredNotificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePrizeDeliveredNotification200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPrizeDeliveredNotification(createPrizeDeliveredNotificationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.createPrizeDeliveredNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.deleteById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {GetNotificationsOrderByCreatedEnum} [orderByCreated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(page?: number, limit?: number, orderByCreated?: GetNotificationsOrderByCreatedEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedNotificationDetailed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(page, limit, orderByCreated, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.getNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateNotificationsRequest} updateNotificationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotifications(updateNotificationsRequest: UpdateNotificationsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotifications(updateNotificationsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.updateNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * 
         * @param {ClaimPrizeRequest} claimPrizeRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        claimPrize(claimPrizeRequest: ClaimPrizeRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatePrizeDeliveredNotification200Response> {
            return localVarFp.claimPrize(claimPrizeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClaimPrizeRequest} claimPrizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimPrizeNew(claimPrizeRequest: ClaimPrizeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClaimPrizeResponse> {
            return localVarFp.claimPrizeNew(claimPrizeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreatePrizeDeliveredNotificationRequest} createPrizeDeliveredNotificationRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createPrizeDeliveredNotification(createPrizeDeliveredNotificationRequest: CreatePrizeDeliveredNotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatePrizeDeliveredNotification200Response> {
            return localVarFp.createPrizeDeliveredNotification(createPrizeDeliveredNotificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {GetNotificationsOrderByCreatedEnum} [orderByCreated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(page?: number, limit?: number, orderByCreated?: GetNotificationsOrderByCreatedEnum, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedNotificationDetailed> {
            return localVarFp.getNotifications(page, limit, orderByCreated, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateNotificationsRequest} updateNotificationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotifications(updateNotificationsRequest: UpdateNotificationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateNotifications(updateNotificationsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * 
     * @param {ClaimPrizeRequest} claimPrizeRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public claimPrize(claimPrizeRequest: ClaimPrizeRequest, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).claimPrize(claimPrizeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClaimPrizeRequest} claimPrizeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public claimPrizeNew(claimPrizeRequest: ClaimPrizeRequest, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).claimPrizeNew(claimPrizeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreatePrizeDeliveredNotificationRequest} createPrizeDeliveredNotificationRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public createPrizeDeliveredNotification(createPrizeDeliveredNotificationRequest: CreatePrizeDeliveredNotificationRequest, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).createPrizeDeliveredNotification(createPrizeDeliveredNotificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public deleteById(id: string, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).deleteById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {GetNotificationsOrderByCreatedEnum} [orderByCreated] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public getNotifications(page?: number, limit?: number, orderByCreated?: GetNotificationsOrderByCreatedEnum, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).getNotifications(page, limit, orderByCreated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateNotificationsRequest} updateNotificationsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public updateNotifications(updateNotificationsRequest: UpdateNotificationsRequest, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).updateNotifications(updateNotificationsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetNotificationsOrderByCreatedEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetNotificationsOrderByCreatedEnum = typeof GetNotificationsOrderByCreatedEnum[keyof typeof GetNotificationsOrderByCreatedEnum];


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<ProductType>} [productTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: async (productTypes?: Array<ProductType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (productTypes) {
                localVarQueryParameter['productTypes'] = productTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<ProductType>} [productTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProducts(productTypes?: Array<ProductType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProducts(productTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.getProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<ProductType>} [productTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(productTypes?: Array<ProductType>, options?: RawAxiosRequestConfig): AxiosPromise<Array<Product>> {
            return localVarFp.getProducts(productTypes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @param {Array<ProductType>} [productTypes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProducts(productTypes?: Array<ProductType>, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).getProducts(productTypes, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuestsApi - axios parameter creator
 * @export
 */
export const QuestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} eventId 
         * @param {QuestType} questType 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {Array<ActivityType>} [activityTypes] 
         * @param {boolean} [processed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuests: async (eventId: string, questType: QuestType, page?: number, limit?: number, activityTypes?: Array<ActivityType>, processed?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getQuests', 'eventId', eventId)
            // verify required parameter 'questType' is not null or undefined
            assertParamExists('getQuests', 'questType', questType)
            const localVarPath = `/quests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (questType !== undefined) {
                localVarQueryParameter['questType'] = questType;
            }

            if (activityTypes) {
                localVarQueryParameter['activityTypes'] = activityTypes;
            }

            if (processed !== undefined) {
                localVarQueryParameter['processed'] = processed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestsApi - functional programming interface
 * @export
 */
export const QuestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} eventId 
         * @param {QuestType} questType 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {Array<ActivityType>} [activityTypes] 
         * @param {boolean} [processed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuests(eventId: string, questType: QuestType, page?: number, limit?: number, activityTypes?: Array<ActivityType>, processed?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedQuestGoal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuests(eventId, questType, page, limit, activityTypes, processed, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestsApi.getQuests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuestsApi - factory interface
 * @export
 */
export const QuestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} eventId 
         * @param {QuestType} questType 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {Array<ActivityType>} [activityTypes] 
         * @param {boolean} [processed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuests(eventId: string, questType: QuestType, page?: number, limit?: number, activityTypes?: Array<ActivityType>, processed?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedQuestGoal> {
            return localVarFp.getQuests(eventId, questType, page, limit, activityTypes, processed, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuestsApi - object-oriented interface
 * @export
 * @class QuestsApi
 * @extends {BaseAPI}
 */
export class QuestsApi extends BaseAPI {
    /**
     * 
     * @param {string} eventId 
     * @param {QuestType} questType 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {Array<ActivityType>} [activityTypes] 
     * @param {boolean} [processed] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestsApi
     */
    public getQuests(eventId: string, questType: QuestType, page?: number, limit?: number, activityTypes?: Array<ActivityType>, processed?: boolean, options?: RawAxiosRequestConfig) {
        return QuestsApiFp(this.configuration).getQuests(eventId, questType, page, limit, activityTypes, processed, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuestsNewApi - axios parameter creator
 * @export
 */
export const QuestsNewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameQuestTemplates: async (gameId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameId' is not null or undefined
            assertParamExists('getGameQuestTemplates', 'gameId', gameId)
            const localVarPath = `/quests-new/game-quest-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (gameId !== undefined) {
                localVarQueryParameter['gameId'] = gameId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} eventId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {Array<QuestType>} [questTypes] 
         * @param {Array<ActivityType>} [activityTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestsNew: async (eventId: string, page?: number, limit?: number, questTypes?: Array<QuestType>, activityTypes?: Array<ActivityType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getQuestsNew', 'eventId', eventId)
            const localVarPath = `/quests-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (questTypes) {
                localVarQueryParameter['questTypes'] = questTypes;
            }

            if (activityTypes) {
                localVarQueryParameter['activityTypes'] = activityTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<ActivityType>} activityTypes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialQuestTemplates: async (activityTypes: Array<ActivityType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityTypes' is not null or undefined
            assertParamExists('getSocialQuestTemplates', 'activityTypes', activityTypes)
            const localVarPath = `/quests-new/social-quest-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (activityTypes) {
                localVarQueryParameter['activityTypes'] = activityTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestsNewApi - functional programming interface
 * @export
 */
export const QuestsNewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestsNewApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGameQuestTemplates(gameId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameQuestTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGameQuestTemplates(gameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestsNewApi.getGameQuestTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} eventId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {Array<QuestType>} [questTypes] 
         * @param {Array<ActivityType>} [activityTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestsNew(eventId: string, page?: number, limit?: number, questTypes?: Array<QuestType>, activityTypes?: Array<ActivityType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAny>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestsNew(eventId, page, limit, questTypes, activityTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestsNewApi.getQuestsNew']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<ActivityType>} activityTypes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSocialQuestTemplates(activityTypes: Array<ActivityType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameQuestTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSocialQuestTemplates(activityTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestsNewApi.getSocialQuestTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuestsNewApi - factory interface
 * @export
 */
export const QuestsNewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestsNewApiFp(configuration)
    return {
        /**
         * 
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameQuestTemplates(gameId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GameQuestTemplate>> {
            return localVarFp.getGameQuestTemplates(gameId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} eventId 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {Array<QuestType>} [questTypes] 
         * @param {Array<ActivityType>} [activityTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestsNew(eventId: string, page?: number, limit?: number, questTypes?: Array<QuestType>, activityTypes?: Array<ActivityType>, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedAny> {
            return localVarFp.getQuestsNew(eventId, page, limit, questTypes, activityTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<ActivityType>} activityTypes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialQuestTemplates(activityTypes: Array<ActivityType>, options?: RawAxiosRequestConfig): AxiosPromise<Array<GameQuestTemplate>> {
            return localVarFp.getSocialQuestTemplates(activityTypes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuestsNewApi - object-oriented interface
 * @export
 * @class QuestsNewApi
 * @extends {BaseAPI}
 */
export class QuestsNewApi extends BaseAPI {
    /**
     * 
     * @param {string} gameId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestsNewApi
     */
    public getGameQuestTemplates(gameId: string, options?: RawAxiosRequestConfig) {
        return QuestsNewApiFp(this.configuration).getGameQuestTemplates(gameId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} eventId 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {Array<QuestType>} [questTypes] 
     * @param {Array<ActivityType>} [activityTypes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestsNewApi
     */
    public getQuestsNew(eventId: string, page?: number, limit?: number, questTypes?: Array<QuestType>, activityTypes?: Array<ActivityType>, options?: RawAxiosRequestConfig) {
        return QuestsNewApiFp(this.configuration).getQuestsNew(eventId, page, limit, questTypes, activityTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<ActivityType>} activityTypes 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestsNewApi
     */
    public getSocialQuestTemplates(activityTypes: Array<ActivityType>, options?: RawAxiosRequestConfig) {
        return QuestsNewApiFp(this.configuration).getSocialQuestTemplates(activityTypes, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SocialApi - axios parameter creator
 * @export
 */
export const SocialApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If there is no goalId, still save the user connection details. If there is a goalId, complete the quest/goal and reward the user. If the quest is completed, update the leaderboard score.
         * @param {CompleteSocialQuestRequest} completeSocialQuestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSocialQuest: async (completeSocialQuestRequest: CompleteSocialQuestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completeSocialQuestRequest' is not null or undefined
            assertParamExists('completeSocialQuest', 'completeSocialQuestRequest', completeSocialQuestRequest)
            const localVarPath = `/social/complete-social`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeSocialQuestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SocialQuestCreateInput} socialQuestCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSociaQuest: async (socialQuestCreateInput: SocialQuestCreateInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'socialQuestCreateInput' is not null or undefined
            assertParamExists('createSociaQuest', 'socialQuestCreateInput', socialQuestCreateInput)
            const localVarPath = `/social/quest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(socialQuestCreateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SocialApi - functional programming interface
 * @export
 */
export const SocialApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SocialApiAxiosParamCreator(configuration)
    return {
        /**
         * If there is no goalId, still save the user connection details. If there is a goalId, complete the quest/goal and reward the user. If the quest is completed, update the leaderboard score.
         * @param {CompleteSocialQuestRequest} completeSocialQuestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeSocialQuest(completeSocialQuestRequest: CompleteSocialQuestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompleteSocialQuestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeSocialQuest(completeSocialQuestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SocialApi.completeSocialQuest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SocialQuestCreateInput} socialQuestCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSociaQuest(socialQuestCreateInput: SocialQuestCreateInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Goal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSociaQuest(socialQuestCreateInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SocialApi.createSociaQuest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SocialApi - factory interface
 * @export
 */
export const SocialApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SocialApiFp(configuration)
    return {
        /**
         * If there is no goalId, still save the user connection details. If there is a goalId, complete the quest/goal and reward the user. If the quest is completed, update the leaderboard score.
         * @param {CompleteSocialQuestRequest} completeSocialQuestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSocialQuest(completeSocialQuestRequest: CompleteSocialQuestRequest, options?: RawAxiosRequestConfig): AxiosPromise<CompleteSocialQuestResponse> {
            return localVarFp.completeSocialQuest(completeSocialQuestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SocialQuestCreateInput} socialQuestCreateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSociaQuest(socialQuestCreateInput: SocialQuestCreateInput, options?: RawAxiosRequestConfig): AxiosPromise<Goal> {
            return localVarFp.createSociaQuest(socialQuestCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SocialApi - object-oriented interface
 * @export
 * @class SocialApi
 * @extends {BaseAPI}
 */
export class SocialApi extends BaseAPI {
    /**
     * If there is no goalId, still save the user connection details. If there is a goalId, complete the quest/goal and reward the user. If the quest is completed, update the leaderboard score.
     * @param {CompleteSocialQuestRequest} completeSocialQuestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialApi
     */
    public completeSocialQuest(completeSocialQuestRequest: CompleteSocialQuestRequest, options?: RawAxiosRequestConfig) {
        return SocialApiFp(this.configuration).completeSocialQuest(completeSocialQuestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SocialQuestCreateInput} socialQuestCreateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialApi
     */
    public createSociaQuest(socialQuestCreateInput: SocialQuestCreateInput, options?: RawAxiosRequestConfig) {
        return SocialApiFp(this.configuration).createSociaQuest(socialQuestCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SocialNewApi - axios parameter creator
 * @export
 */
export const SocialNewApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CompleteSocialQuestRequestNew} completeSocialQuestRequestNew 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSocialQuestNew: async (completeSocialQuestRequestNew: CompleteSocialQuestRequestNew, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completeSocialQuestRequestNew' is not null or undefined
            assertParamExists('completeSocialQuestNew', 'completeSocialQuestRequestNew', completeSocialQuestRequestNew)
            const localVarPath = `/social-new/complete-social-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeSocialQuestRequestNew, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {Array<ConnectionType>} [connectionTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectedSocialsNew: async (id?: string, connectionTypes?: Array<ConnectionType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/social-new/connected-socials-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (connectionTypes) {
                localVarQueryParameter['connectionTypes'] = connectionTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConnectionType} connectionType 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeConnectedSocialNew: async (connectionType: ConnectionType, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionType' is not null or undefined
            assertParamExists('removeConnectedSocialNew', 'connectionType', connectionType)
            const localVarPath = `/social-new/connected-social-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (connectionType !== undefined) {
                localVarQueryParameter['connectionType'] = connectionType;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SocialNewApi - functional programming interface
 * @export
 */
export const SocialNewApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SocialNewApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CompleteSocialQuestRequestNew} completeSocialQuestRequestNew 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeSocialQuestNew(completeSocialQuestRequestNew: CompleteSocialQuestRequestNew, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgressNew>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeSocialQuestNew(completeSocialQuestRequestNew, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SocialNewApi.completeSocialQuestNew']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {Array<ConnectionType>} [connectionTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectedSocialsNew(id?: string, connectionTypes?: Array<ConnectionType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserConnection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectedSocialsNew(id, connectionTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SocialNewApi.getConnectedSocialsNew']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ConnectionType} connectionType 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeConnectedSocialNew(connectionType: ConnectionType, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeConnectedSocialNew(connectionType, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SocialNewApi.removeConnectedSocialNew']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SocialNewApi - factory interface
 * @export
 */
export const SocialNewApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SocialNewApiFp(configuration)
    return {
        /**
         * 
         * @param {CompleteSocialQuestRequestNew} completeSocialQuestRequestNew 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSocialQuestNew(completeSocialQuestRequestNew: CompleteSocialQuestRequestNew, options?: RawAxiosRequestConfig): AxiosPromise<ProgressNew> {
            return localVarFp.completeSocialQuestNew(completeSocialQuestRequestNew, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {Array<ConnectionType>} [connectionTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectedSocialsNew(id?: string, connectionTypes?: Array<ConnectionType>, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserConnection>> {
            return localVarFp.getConnectedSocialsNew(id, connectionTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ConnectionType} connectionType 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeConnectedSocialNew(connectionType: ConnectionType, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeConnectedSocialNew(connectionType, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SocialNewApi - object-oriented interface
 * @export
 * @class SocialNewApi
 * @extends {BaseAPI}
 */
export class SocialNewApi extends BaseAPI {
    /**
     * 
     * @param {CompleteSocialQuestRequestNew} completeSocialQuestRequestNew 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialNewApi
     */
    public completeSocialQuestNew(completeSocialQuestRequestNew: CompleteSocialQuestRequestNew, options?: RawAxiosRequestConfig) {
        return SocialNewApiFp(this.configuration).completeSocialQuestNew(completeSocialQuestRequestNew, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {Array<ConnectionType>} [connectionTypes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialNewApi
     */
    public getConnectedSocialsNew(id?: string, connectionTypes?: Array<ConnectionType>, options?: RawAxiosRequestConfig) {
        return SocialNewApiFp(this.configuration).getConnectedSocialsNew(id, connectionTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConnectionType} connectionType 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialNewApi
     */
    public removeConnectedSocialNew(connectionType: ConnectionType, userId?: string, options?: RawAxiosRequestConfig) {
        return SocialNewApiFp(this.configuration).removeConnectedSocialNew(connectionType, userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<ProductType>} [sellProductType] 
         * @param {string} [sellProductId] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions: async (sellProductType?: Array<ProductType>, sellProductId?: string, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (sellProductType) {
                localVarQueryParameter['sellProductType'] = sellProductType;
            }

            if (sellProductId !== undefined) {
                localVarQueryParameter['sellProductId'] = sellProductId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<ProductType>} [sellProductType] 
         * @param {string} [sellProductId] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransactions(sellProductType?: Array<ProductType>, sellProductId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTransactionDetailed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTransactions(sellProductType, sellProductId, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.getAllTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<ProductType>} [sellProductType] 
         * @param {string} [sellProductId] 
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions(sellProductType?: Array<ProductType>, sellProductId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedTransactionDetailed> {
            return localVarFp.getAllTransactions(sellProductType, sellProductId, page, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
    /**
     * 
     * @param {Array<ProductType>} [sellProductType] 
     * @param {string} [sellProductId] 
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public getAllTransactions(sellProductType?: Array<ProductType>, sellProductId?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).getAllTransactions(sellProductType, sellProductId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAccounts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/linked-accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferrals: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/referrals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [email] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id?: string, email?: string, code?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} gameId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersMergedWith: async (gameId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameId' is not null or undefined
            assertParamExists('getUsersMergedWith', 'gameId', gameId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersMergedWith', 'userId', userId)
            const localVarPath = `/user/{gameId}/{userId}`
                .replace(`{${"gameId"}}`, encodeURIComponent(String(gameId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<GameCodeType>} gameCodeType 
         * @param {string} gameId 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWinCodeHistory: async (gameCodeType: Array<GameCodeType>, gameId: string, eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameCodeType' is not null or undefined
            assertParamExists('getWinCodeHistory', 'gameCodeType', gameCodeType)
            // verify required parameter 'gameId' is not null or undefined
            assertParamExists('getWinCodeHistory', 'gameId', gameId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getWinCodeHistory', 'eventId', eventId)
            const localVarPath = `/user/code-use-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (gameCodeType) {
                localVarQueryParameter['gameCodeType'] = gameCodeType;
            }

            if (gameId !== undefined) {
                localVarQueryParameter['gameId'] = gameId;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('register', 'registerRequest', registerRequest)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateRequest} updateRequest 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (updateRequest: UpdateRequest, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateRequest' is not null or undefined
            assertParamExists('update', 'updateRequest', updateRequest)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReferral: async (referralCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'referralCode' is not null or undefined
            assertParamExists('updateReferral', 'referralCode', referralCode)
            const localVarPath = `/user/referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (referralCode !== undefined) {
                localVarQueryParameter['referralCode'] = referralCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only 1 external user for a given game can be linked to an internal user (mergedWith). Meaning you cannot link internalId1 to externalId2 from fake-game if internalId1 is already merged with externalId1 from fake-game.
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMergedWith: async (gameId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameId' is not null or undefined
            assertParamExists('userMergedWith', 'gameId', gameId)
            const localVarPath = `/user/merged-with`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (gameId !== undefined) {
                localVarQueryParameter['gameId'] = gameId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedAccounts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LinkedAccount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedAccounts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getLinkedAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferrals(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferrals(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getReferrals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [email] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id?: string, email?: string, code?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, email, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} gameId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersMergedWith(gameId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersMergedWith(gameId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUsersMergedWith']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<GameCodeType>} gameCodeType 
         * @param {string} gameId 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWinCodeHistory(gameCodeType: Array<GameCodeType>, gameId: string, eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameCode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWinCodeHistory(gameCodeType, gameId, eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getWinCodeHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateRequest} updateRequest 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(updateRequest: UpdateRequest, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(updateRequest, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReferral(referralCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReferral(referralCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateReferral']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Only 1 external user for a given game can be linked to an internal user (mergedWith). Meaning you cannot link internalId1 to externalId2 from fake-game if internalId1 is already merged with externalId1 from fake-game.
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userMergedWith(gameId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userMergedWith(gameId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userMergedWith']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMe(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.deleteMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAccounts(options?: RawAxiosRequestConfig): AxiosPromise<Array<LinkedAccount>> {
            return localVarFp.getLinkedAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferrals(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.getReferrals(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [email] 
         * @param {string} [code] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id?: string, email?: string, code?: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUser(id, email, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} gameId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersMergedWith(gameId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.getUsersMergedWith(gameId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<GameCodeType>} gameCodeType 
         * @param {string} gameId 
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWinCodeHistory(gameCodeType: Array<GameCodeType>, gameId: string, eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GameCode>> {
            return localVarFp.getWinCodeHistory(gameCodeType, gameId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.register(registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateRequest} updateRequest 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(updateRequest: UpdateRequest, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.update(updateRequest, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReferral(referralCode: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateReferral(referralCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Only 1 external user for a given game can be linked to an internal user (mergedWith). Meaning you cannot link internalId1 to externalId2 from fake-game if internalId1 is already merged with externalId1 from fake-game.
         * @param {string} gameId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMergedWith(gameId: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userMergedWith(gameId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteMe(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getLinkedAccounts(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getLinkedAccounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMe(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getReferrals(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getReferrals(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {string} [email] 
     * @param {string} [code] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(id?: string, email?: string, code?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(id, email, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} gameId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsersMergedWith(gameId: string, userId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsersMergedWith(gameId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<GameCodeType>} gameCodeType 
     * @param {string} gameId 
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getWinCodeHistory(gameCodeType: Array<GameCodeType>, gameId: string, eventId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getWinCodeHistory(gameCodeType, gameId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).register(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateRequest} updateRequest 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public update(updateRequest: UpdateRequest, userId?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).update(updateRequest, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} referralCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateReferral(referralCode: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateReferral(referralCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only 1 external user for a given game can be linked to an internal user (mergedWith). Meaning you cannot link internalId1 to externalId2 from fake-game if internalId1 is already merged with externalId1 from fake-game.
     * @param {string} gameId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userMergedWith(gameId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userMergedWith(gameId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserConnectionApi - axios parameter creator
 * @export
 */
export const UserConnectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateUserConnectionRequest} createUserConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectSocial: async (createUserConnectionRequest: CreateUserConnectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserConnectionRequest' is not null or undefined
            assertParamExists('connectSocial', 'createUserConnectionRequest', createUserConnectionRequest)
            const localVarPath = `/user-connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<ConnectionType>} connectionTypes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserConnections: async (connectionTypes: Array<ConnectionType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionTypes' is not null or undefined
            assertParamExists('getUserConnections', 'connectionTypes', connectionTypes)
            const localVarPath = `/user-connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (connectionTypes) {
                localVarQueryParameter['connectionTypes'] = connectionTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConnectionType} connectionType 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeConnectedSocial: async (connectionType: ConnectionType, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectionType' is not null or undefined
            assertParamExists('removeConnectedSocial', 'connectionType', connectionType)
            const localVarPath = `/user-connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)

            if (connectionType !== undefined) {
                localVarQueryParameter['connectionType'] = connectionType;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserConnectionApi - functional programming interface
 * @export
 */
export const UserConnectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserConnectionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateUserConnectionRequest} createUserConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectSocial(createUserConnectionRequest: CreateUserConnectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectSocial(createUserConnectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserConnectionApi.connectSocial']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<ConnectionType>} connectionTypes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserConnections(connectionTypes: Array<ConnectionType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetUserConnectionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserConnections(connectionTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserConnectionApi.getUserConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ConnectionType} connectionType 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeConnectedSocial(connectionType: ConnectionType, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeConnectedSocial(connectionType, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserConnectionApi.removeConnectedSocial']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserConnectionApi - factory interface
 * @export
 */
export const UserConnectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserConnectionApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateUserConnectionRequest} createUserConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectSocial(createUserConnectionRequest: CreateUserConnectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserConnectionResponse> {
            return localVarFp.connectSocial(createUserConnectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<ConnectionType>} connectionTypes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserConnections(connectionTypes: Array<ConnectionType>, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetUserConnectionResponse>> {
            return localVarFp.getUserConnections(connectionTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ConnectionType} connectionType 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeConnectedSocial(connectionType: ConnectionType, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeConnectedSocial(connectionType, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserConnectionApi - object-oriented interface
 * @export
 * @class UserConnectionApi
 * @extends {BaseAPI}
 */
export class UserConnectionApi extends BaseAPI {
    /**
     * 
     * @param {CreateUserConnectionRequest} createUserConnectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserConnectionApi
     */
    public connectSocial(createUserConnectionRequest: CreateUserConnectionRequest, options?: RawAxiosRequestConfig) {
        return UserConnectionApiFp(this.configuration).connectSocial(createUserConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<ConnectionType>} connectionTypes 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserConnectionApi
     */
    public getUserConnections(connectionTypes: Array<ConnectionType>, options?: RawAxiosRequestConfig) {
        return UserConnectionApiFp(this.configuration).getUserConnections(connectionTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConnectionType} connectionType 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserConnectionApi
     */
    public removeConnectedSocial(connectionType: ConnectionType, userId?: string, options?: RawAxiosRequestConfig) {
        return UserConnectionApiFp(this.configuration).removeConnectedSocial(connectionType, userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserWalletApi - axios parameter creator
 * @export
 */
export const UserWalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeSolanaUserWalletToDB: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserWalletRequest} updateUserWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserWallet: async (updateUserWalletRequest: UpdateUserWalletRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserWalletRequest' is not null or undefined
            assertParamExists('updateUserWallet', 'updateUserWalletRequest', updateUserWalletRequest)
            const localVarPath = `/user-wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserWalletRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserWalletApi - functional programming interface
 * @export
 */
export const UserWalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserWalletApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWallets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserWallet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWallets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserWalletApi.getUserWallets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeSolanaUserWalletToDB(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeSolanaUserWalletToDB(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserWalletApi.storeSolanaUserWalletToDB']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateUserWalletRequest} updateUserWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserWallet(updateUserWalletRequest: UpdateUserWalletRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserWallet(updateUserWalletRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserWalletApi.updateUserWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserWalletApi - factory interface
 * @export
 */
export const UserWalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserWalletApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserWallet>> {
            return localVarFp.getUserWallets(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeSolanaUserWalletToDB(options?: RawAxiosRequestConfig): AxiosPromise<UserWallet> {
            return localVarFp.storeSolanaUserWalletToDB(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserWalletRequest} updateUserWalletRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserWallet(updateUserWalletRequest: UpdateUserWalletRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUserWallet(updateUserWalletRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserWalletApi - object-oriented interface
 * @export
 * @class UserWalletApi
 * @extends {BaseAPI}
 */
export class UserWalletApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletApi
     */
    public getUserWallets(options?: RawAxiosRequestConfig) {
        return UserWalletApiFp(this.configuration).getUserWallets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletApi
     */
    public storeSolanaUserWalletToDB(options?: RawAxiosRequestConfig) {
        return UserWalletApiFp(this.configuration).storeSolanaUserWalletToDB(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserWalletRequest} updateUserWalletRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletApi
     */
    public updateUserWallet(updateUserWalletRequest: UpdateUserWalletRequest, options?: RawAxiosRequestConfig) {
        return UserWalletApiFp(this.configuration).updateUserWallet(updateUserWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UtilityApi - axios parameter creator
 * @export
 */
export const UtilityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Does sanity checks and returns 200 OK if everything is working as expected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/utility/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilityApi - functional programming interface
 * @export
 */
export const UtilityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UtilityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Does sanity checks and returns 200 OK if everything is working as expected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilityApi.healthCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UtilityApi - factory interface
 * @export
 */
export const UtilityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UtilityApiFp(configuration)
    return {
        /**
         * 
         * @summary Does sanity checks and returns 200 OK if everything is working as expected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.healthCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UtilityApi - object-oriented interface
 * @export
 * @class UtilityApi
 * @extends {BaseAPI}
 */
export class UtilityApi extends BaseAPI {
    /**
     * 
     * @summary Does sanity checks and returns 200 OK if everything is working as expected.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilityApi
     */
    public healthCheck(options?: RawAxiosRequestConfig) {
        return UtilityApiFp(this.configuration).healthCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



