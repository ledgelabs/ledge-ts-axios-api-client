"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * @ledge/api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdminGameApiFp = exports.AdminGameApiAxiosParamCreator = exports.AdminEventNewApi = exports.AdminEventNewApiFactory = exports.AdminEventNewApiFp = exports.AdminEventNewApiAxiosParamCreator = exports.AdminEventApi = exports.AdminEventApiFactory = exports.AdminEventApiFp = exports.AdminEventApiAxiosParamCreator = exports.AdminBannerApi = exports.AdminBannerApiFactory = exports.AdminBannerApiFp = exports.AdminBannerApiAxiosParamCreator = exports.AdminAnnouncementApi = exports.AdminAnnouncementApiFactory = exports.AdminAnnouncementApiFp = exports.AdminAnnouncementApiAxiosParamCreator = exports.WalletType = exports.UserRoleType = exports.UserDrawStatus = exports.TransactionType = exports.StatusType = exports.ScheduleType = exports.ScheduleStatus = exports.QuestType = exports.QuestOrientation = exports.QuestDifficulty = exports.ProductType = exports.PrizeType = exports.NotificationType = exports.LobbyPrizeAssetTypeEnum = exports.LobbyItemsKeyEnum = exports.LinkType = exports.LeaderboardFactorType = exports.LeaderboardDisplay = exports.GoalAttributeKey = exports.Gender = exports.GameCodeType = exports.GameCodeStatus = exports.Frequency = exports.EventStatus = exports.CreateLeaderboardRewardArgsCashPrizeTopNPlayersEnum = exports.CreateEventGameAccess = exports.ConnectionType = exports.BlacklistSeverity = exports.BlacklistAction = exports.BannerLocation = exports.ActivityType = exports.AccessStatus = void 0;
exports.AuthApi = exports.AuthApiFactory = exports.AuthApiFp = exports.AuthApiAxiosParamCreator = exports.AdminUserRoleApi = exports.AdminUserRoleApiFactory = exports.AdminUserRoleApiFp = exports.AdminUserRoleApiAxiosParamCreator = exports.AdminRaffleResultsApi = exports.AdminRaffleResultsApiFactory = exports.AdminRaffleResultsApiFp = exports.AdminRaffleResultsApiAxiosParamCreator = exports.AdminQuestScheduleApi = exports.AdminQuestScheduleApiFactory = exports.AdminQuestScheduleApiFp = exports.AdminQuestScheduleApiAxiosParamCreator = exports.AdminQuestRewardApi = exports.AdminQuestRewardApiFactory = exports.AdminQuestRewardApiFp = exports.AdminQuestRewardApiAxiosParamCreator = exports.AdminQuestApi = exports.AdminQuestApiFactory = exports.AdminQuestApiFp = exports.AdminQuestApiAxiosParamCreator = exports.AdminProductApi = exports.AdminProductApiFactory = exports.AdminProductApiFp = exports.AdminProductApiAxiosParamCreator = exports.AdminLeaderboardScheduleApi = exports.AdminLeaderboardScheduleApiFactory = exports.AdminLeaderboardScheduleApiFp = exports.AdminLeaderboardScheduleApiAxiosParamCreator = exports.AdminLeaderboardRewardApi = exports.AdminLeaderboardRewardApiFactory = exports.AdminLeaderboardRewardApiFp = exports.AdminLeaderboardRewardApiAxiosParamCreator = exports.AdminLeaderboardFactorApi = exports.AdminLeaderboardFactorApiFactory = exports.AdminLeaderboardFactorApiFp = exports.AdminLeaderboardFactorApiAxiosParamCreator = exports.AdminLeaderboardApi = exports.AdminLeaderboardApiFactory = exports.AdminLeaderboardApiFp = exports.AdminLeaderboardApiAxiosParamCreator = exports.AdminGameLinkApi = exports.AdminGameLinkApiFactory = exports.AdminGameLinkApiFp = exports.AdminGameLinkApiAxiosParamCreator = exports.AdminGameApi = exports.AdminGameApiFactory = void 0;
exports.QuestsApiAxiosParamCreator = exports.ProductApi = exports.ProductApiFactory = exports.ProductApiFp = exports.ProductApiAxiosParamCreator = exports.GetNotificationsOrderByCreatedEnum = exports.NotificationApi = exports.NotificationApiFactory = exports.NotificationApiFp = exports.NotificationApiAxiosParamCreator = exports.LeaderboardResultApi = exports.LeaderboardResultApiFactory = exports.LeaderboardResultApiFp = exports.LeaderboardResultApiAxiosParamCreator = exports.LeaderboardApi = exports.LeaderboardApiFactory = exports.LeaderboardApiFp = exports.LeaderboardApiAxiosParamCreator = exports.InventoryApi = exports.InventoryApiFactory = exports.InventoryApiFp = exports.InventoryApiAxiosParamCreator = exports.GuestApi = exports.GuestApiFactory = exports.GuestApiFp = exports.GuestApiAxiosParamCreator = exports.GamesApi = exports.GamesApiFactory = exports.GamesApiFp = exports.GamesApiAxiosParamCreator = exports.GameCodeApi = exports.GameCodeApiFactory = exports.GameCodeApiFp = exports.GameCodeApiAxiosParamCreator = exports.EventsNewApi = exports.EventsNewApiFactory = exports.EventsNewApiFp = exports.EventsNewApiAxiosParamCreator = exports.EventsApi = exports.EventsApiFactory = exports.EventsApiFp = exports.EventsApiAxiosParamCreator = exports.DrawApi = exports.DrawApiFactory = exports.DrawApiFp = exports.DrawApiAxiosParamCreator = exports.BannersApi = exports.BannersApiFactory = exports.BannersApiFp = exports.BannersApiAxiosParamCreator = void 0;
exports.UtilityApi = exports.UtilityApiFactory = exports.UtilityApiFp = exports.UtilityApiAxiosParamCreator = exports.UserWalletApi = exports.UserWalletApiFactory = exports.UserWalletApiFp = exports.UserWalletApiAxiosParamCreator = exports.UserConnectionApi = exports.UserConnectionApiFactory = exports.UserConnectionApiFp = exports.UserConnectionApiAxiosParamCreator = exports.UserApi = exports.UserApiFactory = exports.UserApiFp = exports.UserApiAxiosParamCreator = exports.TransactionApi = exports.TransactionApiFactory = exports.TransactionApiFp = exports.TransactionApiAxiosParamCreator = exports.SocialNewApi = exports.SocialNewApiFactory = exports.SocialNewApiFp = exports.SocialNewApiAxiosParamCreator = exports.SocialApi = exports.SocialApiFactory = exports.SocialApiFp = exports.SocialApiAxiosParamCreator = exports.QuestsNewApi = exports.QuestsNewApiFactory = exports.QuestsNewApiFp = exports.QuestsNewApiAxiosParamCreator = exports.QuestsApi = exports.QuestsApiFactory = exports.QuestsApiFp = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 *
 * @export
 * @enum {string}
 */
exports.AccessStatus = {
    Active: 'ACTIVE',
    Disabled: 'DISABLED'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ActivityType = {
    UserSignUp: 'USER_SIGN_UP',
    Referral: 'REFERRAL',
    ExternalMilestone: 'EXTERNAL_MILESTONE',
    ExternalCumulative: 'EXTERNAL_CUMULATIVE',
    EmailSocialAuth: 'EMAIL_SOCIAL_AUTH',
    XSocialAuth: 'X_SOCIAL_AUTH',
    DiscordSocialAuth: 'DISCORD_SOCIAL_AUTH',
    XSocialOpenlink: 'X_SOCIAL_OPENLINK',
    XSocialLike: 'X_SOCIAL_LIKE',
    XSocialFollow: 'X_SOCIAL_FOLLOW',
    XSocialShare: 'X_SOCIAL_SHARE',
    XSocialHashtag: 'X_SOCIAL_HASHTAG',
    XSocialRetweet: 'X_SOCIAL_RETWEET',
    DiscordSocialJoinServer: 'DISCORD_SOCIAL_JOIN_SERVER',
    OpenLink: 'OPEN_LINK'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.BannerLocation = {
    HomePage: 'HOME_PAGE',
    EventPage: 'EVENT_PAGE'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.BlacklistAction = {
    Ban: 'BAN',
    Unban: 'UNBAN'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.BlacklistSeverity = {
    Game: 'GAME'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ConnectionType = {
    Discord: 'discord',
    X: 'x',
    Email: 'email',
    Google: 'google'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.CreateEventGameAccess = {
    Hidden: 'HIDDEN',
    Creator: 'CREATOR'
};
exports.CreateLeaderboardRewardArgsCashPrizeTopNPlayersEnum = {
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_10: 10
};
/**
 *
 * @export
 * @enum {string}
 */
exports.EventStatus = {
    Live: 'LIVE',
    Ended: 'ENDED',
    Tba: 'TBA',
    Starting: 'STARTING',
    Locked: 'LOCKED',
    Draft: 'DRAFT'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.Frequency = {
    Once: 'ONCE',
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Yearly: 'YEARLY'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.GameCodeStatus = {
    Used: 'USED',
    NotUsed: 'NOT_USED'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.GameCodeType = {
    Linking: 'LINKING',
    LeaderboardWin: 'LEADERBOARD_WIN'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.Gender = {
    Male: 'male',
    Female: 'female',
    Other: 'other',
    Unknown: 'unknown'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.GoalAttributeKey = {
    TargetUserId: 'TARGET_USER_ID'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.LeaderboardDisplay = {
    V1: 'V1',
    Hidden: 'HIDDEN'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.LeaderboardFactorType = {
    Cumulative: 'CUMULATIVE',
    Milestone: 'MILESTONE',
    QuestCompleted: 'QUEST_COMPLETED'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.LinkType = {
    X: 'X',
    Discord: 'DISCORD',
    Website: 'WEBSITE',
    Facebook: 'FACEBOOK',
    Youtube: 'YOUTUBE',
    Linkedin: 'LINKEDIN',
    Instagram: 'INSTAGRAM',
    Tiktok: 'TIKTOK',
    Reddit: 'REDDIT',
    Twitch: 'TWITCH',
    Game: 'GAME'
};
exports.LobbyItemsKeyEnum = {
    GameMode: 'Game Mode',
    PrizePool: 'Prize Pool',
    Raffle: 'Raffle',
    Joiners: 'Joiners'
};
exports.LobbyPrizeAssetTypeEnum = {
    Icon: 'icon',
    Image: 'image'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.NotificationType = {
    Event: 'EVENT',
    CaseReward: 'CASE_REWARD',
    ReferralCodeUsed: 'REFERRAL_CODE_USED',
    UnusedReferralsRemaining: 'UNUSED_REFERRALS_REMAINING',
    UnopenedCase: 'UNOPENED_CASE',
    LeaderboardWinner: 'LEADERBOARD_WINNER',
    RaffleWinner: 'RAFFLE_WINNER',
    EmailNotConnected: 'EMAIL_NOT_CONNECTED',
    PrizeClaimed: 'PRIZE_CLAIMED',
    PrizeDelivered: 'PRIZE_DELIVERED',
    ExportWallet: 'EXPORT_WALLET'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.PrizeType = {
    Blitz: 'blitz',
    Cash: 'cash',
    Custom: 'custom'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ProductType = {
    Ticket: 'TICKET',
    ExpiredTicket: 'EXPIRED_TICKET',
    CryptoEthereum: 'CRYPTO_ETHEREUM',
    CryptoUsdc: 'CRYPTO_USDC',
    Usd: 'USD',
    Nft: 'NFT',
    InGameItem: 'IN_GAME_ITEM',
    PhysicalProduct: 'PHYSICAL_PRODUCT',
    Token: 'TOKEN',
    GiftCard: 'GIFT_CARD',
    Avatar: 'AVATAR',
    Banner: 'BANNER',
    Other: 'OTHER'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.QuestDifficulty = {
    Easy: 'EASY',
    Medium: 'MEDIUM',
    Hard: 'HARD'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.QuestOrientation = {
    Horizontal: 'HORIZONTAL',
    Vertical: 'VERTICAL'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.QuestType = {
    DailyIndividual: 'DAILY_INDIVIDUAL',
    SocialIndividual: 'SOCIAL_INDIVIDUAL'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ScheduleStatus = {
    NotProcessed: 'NOT_PROCESSED',
    Error: 'ERROR',
    Processed: 'PROCESSED'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ScheduleType = {
    Event: 'EVENT',
    Leaderboard: 'LEADERBOARD',
    Raffle: 'RAFFLE',
    Quest: 'QUEST',
    GameQuestTemplate: 'GAME_QUEST_TEMPLATE'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.StatusType = {
    NotClaimed: 'NOT_CLAIMED',
    Claimed: 'CLAIMED',
    Processing: 'PROCESSING',
    Delivered: 'DELIVERED',
    Expired: 'EXPIRED'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.TransactionType = {
    QuestReward: 'QUEST_REWARD',
    LeaderboardReward: 'LEADERBOARD_REWARD',
    RaffleReward: 'RAFFLE_REWARD',
    Reward: 'REWARD',
    Marketplace: 'MARKETPLACE',
    Draw: 'DRAW',
    ExpiredRaffleTicket: 'EXPIRED_RAFFLE_TICKET'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.UserDrawStatus = {
    Claimed: 'CLAIMED',
    NotClaimed: 'NOT_CLAIMED',
    Expired: 'EXPIRED'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.UserRoleType = {
    Creator: 'CREATOR',
    Verified: 'VERIFIED',
    LedgeAdmin: 'LEDGE_ADMIN'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.WalletType = {
    Ethereum: 'ETHEREUM',
    Solana: 'SOLANA'
};
/**
 * AdminAnnouncementApi - axios parameter creator
 * @export
 */
const AdminAnnouncementApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement: (body_1, ...args_1) => __awaiter(this, [body_1, ...args_1], void 0, function* (body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createAnnouncement', 'body', body);
            const localVarPath = `/admin/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteAnnouncement', 'id', id);
            const localVarPath = `/admin/announcements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAnnouncements: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/admin/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} announcementId
         * @param {PartialCreateAnnouncementArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement: (announcementId_1, body_1, ...args_1) => __awaiter(this, [announcementId_1, body_1, ...args_1], void 0, function* (announcementId, body, options = {}) {
            // verify required parameter 'announcementId' is not null or undefined
            (0, common_1.assertParamExists)('updateAnnouncement', 'announcementId', announcementId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateAnnouncement', 'body', body);
            const localVarPath = `/admin/announcements/{announcementId}`
                .replace(`{${"announcementId"}}`, encodeURIComponent(String(announcementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminAnnouncementApiAxiosParamCreator = AdminAnnouncementApiAxiosParamCreator;
/**
 * AdminAnnouncementApi - functional programming interface
 * @export
 */
const AdminAnnouncementApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminAnnouncementApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createAnnouncement(body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminAnnouncementApi.createAnnouncement']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAnnouncement(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminAnnouncementApi.deleteAnnouncement']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAnnouncements(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllAnnouncements(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminAnnouncementApi.getAllAnnouncements']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} announcementId
         * @param {PartialCreateAnnouncementArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement(announcementId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAnnouncement(announcementId, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminAnnouncementApi.updateAnnouncement']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminAnnouncementApiFp = AdminAnnouncementApiFp;
/**
 * AdminAnnouncementApi - factory interface
 * @export
 */
const AdminAnnouncementApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminAnnouncementApiFp)(configuration);
    return {
        /**
         *
         * @param {PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnouncement(body, options) {
            return localVarFp.createAnnouncement(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnouncement(id, options) {
            return localVarFp.deleteAnnouncement(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAnnouncements(options) {
            return localVarFp.getAllAnnouncements(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} announcementId
         * @param {PartialCreateAnnouncementArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnouncement(announcementId, body, options) {
            return localVarFp.updateAnnouncement(announcementId, body, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminAnnouncementApiFactory = AdminAnnouncementApiFactory;
/**
 * AdminAnnouncementApi - object-oriented interface
 * @export
 * @class AdminAnnouncementApi
 * @extends {BaseAPI}
 */
class AdminAnnouncementApi extends base_1.BaseAPI {
    /**
     *
     * @param {PickPrismaAnnouncementUncheckedCreateInputMessageOrStatus} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAnnouncementApi
     */
    createAnnouncement(body, options) {
        return (0, exports.AdminAnnouncementApiFp)(this.configuration).createAnnouncement(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAnnouncementApi
     */
    deleteAnnouncement(id, options) {
        return (0, exports.AdminAnnouncementApiFp)(this.configuration).deleteAnnouncement(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAnnouncementApi
     */
    getAllAnnouncements(options) {
        return (0, exports.AdminAnnouncementApiFp)(this.configuration).getAllAnnouncements(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} announcementId
     * @param {PartialCreateAnnouncementArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAnnouncementApi
     */
    updateAnnouncement(announcementId, body, options) {
        return (0, exports.AdminAnnouncementApiFp)(this.configuration).updateAnnouncement(announcementId, body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminAnnouncementApi = AdminAnnouncementApi;
/**
 * AdminBannerApi - axios parameter creator
 * @export
 */
const AdminBannerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {CreateBannerArgs} createBannerArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBanner: (createBannerArgs_1, ...args_1) => __awaiter(this, [createBannerArgs_1, ...args_1], void 0, function* (createBannerArgs, options = {}) {
            // verify required parameter 'createBannerArgs' is not null or undefined
            (0, common_1.assertParamExists)('createBanner', 'createBannerArgs', createBannerArgs);
            const localVarPath = `/admin/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createBannerArgs, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBanner: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteBanner', 'id', id);
            const localVarPath = `/admin/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners: (eventId_1, ...args_1) => __awaiter(this, [eventId_1, ...args_1], void 0, function* (eventId, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('getAllBanners', 'eventId', eventId);
            const localVarPath = `/admin/banners/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} bannerId
         * @param {PartialCreateBannerArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBanner: (bannerId_1, body_1, ...args_1) => __awaiter(this, [bannerId_1, body_1, ...args_1], void 0, function* (bannerId, body, options = {}) {
            // verify required parameter 'bannerId' is not null or undefined
            (0, common_1.assertParamExists)('updateBanner', 'bannerId', bannerId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateBanner', 'body', body);
            const localVarPath = `/admin/banners/{bannerId}`
                .replace(`{${"bannerId"}}`, encodeURIComponent(String(bannerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
         * @param {string} id banner id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBannerImages: (id_1, imageType_1, file_1, replaceUrl_1, ...args_1) => __awaiter(this, [id_1, imageType_1, file_1, replaceUrl_1, ...args_1], void 0, function* (id, imageType, file, replaceUrl, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('uploadBannerImages', 'id', id);
            // verify required parameter 'imageType' is not null or undefined
            (0, common_1.assertParamExists)('uploadBannerImages', 'imageType', imageType);
            // verify required parameter 'file' is not null or undefined
            (0, common_1.assertParamExists)('uploadBannerImages', 'file', file);
            const localVarPath = `/admin/banners/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (imageType !== undefined) {
                localVarFormParams.append('imageType', imageType);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            if (replaceUrl !== undefined) {
                localVarFormParams.append('replaceUrl', replaceUrl);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminBannerApiAxiosParamCreator = AdminBannerApiAxiosParamCreator;
/**
 * AdminBannerApi - functional programming interface
 * @export
 */
const AdminBannerApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminBannerApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {CreateBannerArgs} createBannerArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBanner(createBannerArgs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBanner(createBannerArgs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminBannerApi.createBanner']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBanner(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteBanner(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminBannerApi.deleteBanner']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners(eventId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllBanners(eventId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminBannerApi.getAllBanners']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} bannerId
         * @param {PartialCreateBannerArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBanner(bannerId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateBanner(bannerId, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminBannerApi.updateBanner']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
         * @param {string} id banner id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBannerImages(id, imageType, file, replaceUrl, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadBannerImages(id, imageType, file, replaceUrl, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminBannerApi.uploadBannerImages']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminBannerApiFp = AdminBannerApiFp;
/**
 * AdminBannerApi - factory interface
 * @export
 */
const AdminBannerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminBannerApiFp)(configuration);
    return {
        /**
         *
         * @param {CreateBannerArgs} createBannerArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBanner(createBannerArgs, options) {
            return localVarFp.createBanner(createBannerArgs, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBanner(id, options) {
            return localVarFp.deleteBanner(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBanners(eventId, options) {
            return localVarFp.getAllBanners(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} bannerId
         * @param {PartialCreateBannerArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBanner(bannerId, body, options) {
            return localVarFp.updateBanner(bannerId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
         * @param {string} id banner id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBannerImages(id, imageType, file, replaceUrl, options) {
            return localVarFp.uploadBannerImages(id, imageType, file, replaceUrl, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminBannerApiFactory = AdminBannerApiFactory;
/**
 * AdminBannerApi - object-oriented interface
 * @export
 * @class AdminBannerApi
 * @extends {BaseAPI}
 */
class AdminBannerApi extends base_1.BaseAPI {
    /**
     *
     * @param {CreateBannerArgs} createBannerArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminBannerApi
     */
    createBanner(createBannerArgs, options) {
        return (0, exports.AdminBannerApiFp)(this.configuration).createBanner(createBannerArgs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminBannerApi
     */
    deleteBanner(id, options) {
        return (0, exports.AdminBannerApiFp)(this.configuration).deleteBanner(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminBannerApi
     */
    getAllBanners(eventId, options) {
        return (0, exports.AdminBannerApiFp)(this.configuration).getAllBanners(eventId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} bannerId
     * @param {PartialCreateBannerArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminBannerApi
     */
    updateBanner(bannerId, body, options) {
        return (0, exports.AdminBannerApiFp)(this.configuration).updateBanner(bannerId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
     * @param {string} id banner id
     * @param {string} imageType corresponds to the DB column name
     * @param {File} file image to upload to S3
     * @param {string} [replaceUrl] optional url to replace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminBannerApi
     */
    uploadBannerImages(id, imageType, file, replaceUrl, options) {
        return (0, exports.AdminBannerApiFp)(this.configuration).uploadBannerImages(id, imageType, file, replaceUrl, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminBannerApi = AdminBannerApi;
/**
 * AdminEventApi - axios parameter creator
 * @export
 */
const AdminEventApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This endpoint is for the old system
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetEvent: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('adminGetEvent', 'id', id);
            const localVarPath = `/admin/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetEvents: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/admin/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint is for the old system
         * @param {CreateEventArgs} createEventArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: (createEventArgs_1, ...args_1) => __awaiter(this, [createEventArgs_1, ...args_1], void 0, function* (createEventArgs, options = {}) {
            // verify required parameter 'createEventArgs' is not null or undefined
            (0, common_1.assertParamExists)('createEvent', 'createEventArgs', createEventArgs);
            const localVarPath = `/admin/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createEventArgs, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint is for the old system
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteEvent', 'id', id);
            const localVarPath = `/admin/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint is for the old system
         * @param {string} eventId
         * @param {PartialCreateEventArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: (eventId_1, body_1, ...args_1) => __awaiter(this, [eventId_1, body_1, ...args_1], void 0, function* (eventId, body, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('updateEvent', 'eventId', eventId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateEvent', 'body', body);
            const localVarPath = `/admin/events/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
         * @param {string} id event id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadEventImages: (id_1, imageType_1, file_1, replaceUrl_1, ...args_1) => __awaiter(this, [id_1, imageType_1, file_1, replaceUrl_1, ...args_1], void 0, function* (id, imageType, file, replaceUrl, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('uploadEventImages', 'id', id);
            // verify required parameter 'imageType' is not null or undefined
            (0, common_1.assertParamExists)('uploadEventImages', 'imageType', imageType);
            // verify required parameter 'file' is not null or undefined
            (0, common_1.assertParamExists)('uploadEventImages', 'file', file);
            const localVarPath = `/admin/events/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (imageType !== undefined) {
                localVarFormParams.append('imageType', imageType);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            if (replaceUrl !== undefined) {
                localVarFormParams.append('replaceUrl', replaceUrl);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminEventApiAxiosParamCreator = AdminEventApiAxiosParamCreator;
/**
 * AdminEventApi - functional programming interface
 * @export
 */
const AdminEventApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminEventApiAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint is for the old system
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetEvent(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminGetEvent(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminEventApi.adminGetEvent']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetEvents(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminGetEvents(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminEventApi.adminGetEvents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint is for the old system
         * @param {CreateEventArgs} createEventArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(createEventArgs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createEvent(createEventArgs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminEventApi.createEvent']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint is for the old system
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteEvent(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminEventApi.deleteEvent']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint is for the old system
         * @param {string} eventId
         * @param {PartialCreateEventArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(eventId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateEvent(eventId, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminEventApi.updateEvent']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
         * @param {string} id event id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadEventImages(id, imageType, file, replaceUrl, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadEventImages(id, imageType, file, replaceUrl, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminEventApi.uploadEventImages']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminEventApiFp = AdminEventApiFp;
/**
 * AdminEventApi - factory interface
 * @export
 */
const AdminEventApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminEventApiFp)(configuration);
    return {
        /**
         * This endpoint is for the old system
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetEvent(id, options) {
            return localVarFp.adminGetEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetEvents(options) {
            return localVarFp.adminGetEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is for the old system
         * @param {CreateEventArgs} createEventArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(createEventArgs, options) {
            return localVarFp.createEvent(createEventArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is for the old system
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(id, options) {
            return localVarFp.deleteEvent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is for the old system
         * @param {string} eventId
         * @param {PartialCreateEventArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(eventId, body, options) {
            return localVarFp.updateEvent(eventId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
         * @param {string} id event id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadEventImages(id, imageType, file, replaceUrl, options) {
            return localVarFp.uploadEventImages(id, imageType, file, replaceUrl, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminEventApiFactory = AdminEventApiFactory;
/**
 * AdminEventApi - object-oriented interface
 * @export
 * @class AdminEventApi
 * @extends {BaseAPI}
 */
class AdminEventApi extends base_1.BaseAPI {
    /**
     * This endpoint is for the old system
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventApi
     */
    adminGetEvent(id, options) {
        return (0, exports.AdminEventApiFp)(this.configuration).adminGetEvent(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventApi
     */
    adminGetEvents(options) {
        return (0, exports.AdminEventApiFp)(this.configuration).adminGetEvents(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint is for the old system
     * @param {CreateEventArgs} createEventArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventApi
     */
    createEvent(createEventArgs, options) {
        return (0, exports.AdminEventApiFp)(this.configuration).createEvent(createEventArgs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint is for the old system
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventApi
     */
    deleteEvent(id, options) {
        return (0, exports.AdminEventApiFp)(this.configuration).deleteEvent(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint is for the old system
     * @param {string} eventId
     * @param {PartialCreateEventArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventApi
     */
    updateEvent(eventId, body, options) {
        return (0, exports.AdminEventApiFp)(this.configuration).updateEvent(eventId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint is for the old system Uploads an image to S3 and updates the event\'s image URL in the database.
     * @param {string} id event id
     * @param {string} imageType corresponds to the DB column name
     * @param {File} file image to upload to S3
     * @param {string} [replaceUrl] optional url to replace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventApi
     */
    uploadEventImages(id, imageType, file, replaceUrl, options) {
        return (0, exports.AdminEventApiFp)(this.configuration).uploadEventImages(id, imageType, file, replaceUrl, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminEventApi = AdminEventApi;
/**
 * AdminEventNewApi - axios parameter creator
 * @export
 */
const AdminEventNewApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetails: (eventId_1, ...args_1) => __awaiter(this, [eventId_1, ...args_1], void 0, function* (eventId, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('getEventDetails', 'eventId', eventId);
            const localVarPath = `/admin/events-new/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/admin/events-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminEventNewApiAxiosParamCreator = AdminEventNewApiAxiosParamCreator;
/**
 * AdminEventNewApi - functional programming interface
 * @export
 */
const AdminEventNewApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminEventNewApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetails(eventId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEventDetails(eventId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminEventNewApi.getEventDetails']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listEvents(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminEventNewApi.listEvents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminEventNewApiFp = AdminEventNewApiFp;
/**
 * AdminEventNewApi - factory interface
 * @export
 */
const AdminEventNewApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminEventNewApiFp)(configuration);
    return {
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetails(eventId, options) {
            return localVarFp.getEventDetails(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(options) {
            return localVarFp.listEvents(options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminEventNewApiFactory = AdminEventNewApiFactory;
/**
 * AdminEventNewApi - object-oriented interface
 * @export
 * @class AdminEventNewApi
 * @extends {BaseAPI}
 */
class AdminEventNewApi extends base_1.BaseAPI {
    /**
     *
     * @param {string} eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventNewApi
     */
    getEventDetails(eventId, options) {
        return (0, exports.AdminEventNewApiFp)(this.configuration).getEventDetails(eventId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminEventNewApi
     */
    listEvents(options) {
        return (0, exports.AdminEventNewApiFp)(this.configuration).listEvents(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminEventNewApi = AdminEventNewApi;
/**
 * AdminGameApi - axios parameter creator
 * @export
 */
const AdminGameApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Stores newly created external api key for a game.
         * @param {string} id game id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalApiKey: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('createExternalApiKey', 'id', id);
            const localVarPath = `/admin/games/{id}/external-api-key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {CreateGameArgs} createGameArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGame: (createGameArgs_1, ...args_1) => __awaiter(this, [createGameArgs_1, ...args_1], void 0, function* (createGameArgs, options = {}) {
            // verify required parameter 'createGameArgs' is not null or undefined
            (0, common_1.assertParamExists)('createGame', 'createGameArgs', createGameArgs);
            const localVarPath = `/admin/games`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createGameArgs, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGame: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteGame', 'id', id);
            const localVarPath = `/admin/games/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the external api keys for a game.
         * @param {string} id game id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExternalApiKey: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getAllExternalApiKey', 'id', id);
            const localVarPath = `/admin/games/{id}/external-api-keys`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGames: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/admin/games`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameById: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getGameById', 'id', id);
            const localVarPath = `/admin/games/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an existing external api key for a game.
         * @param {string} id api key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExternalApiKey: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateExternalApiKey', 'id', id);
            const localVarPath = `/admin/games/{id}/external-api-key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an existing external api key for a game.
         * @param {Array<UpdateApiKeyArgs>} updateApiKeyArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExternalApiKeyBulk: (updateApiKeyArgs_1, ...args_1) => __awaiter(this, [updateApiKeyArgs_1, ...args_1], void 0, function* (updateApiKeyArgs, options = {}) {
            // verify required parameter 'updateApiKeyArgs' is not null or undefined
            (0, common_1.assertParamExists)('updateExternalApiKeyBulk', 'updateApiKeyArgs', updateApiKeyArgs);
            const localVarPath = `/admin/games/external-api-key/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateApiKeyArgs, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {PartialCreateGameArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGame: (id_1, body_1, ...args_1) => __awaiter(this, [id_1, body_1, ...args_1], void 0, function* (id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateGame', 'id', id);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateGame', 'body', body);
            const localVarPath = `/admin/games`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Uploads an image to S3 and updates the game\'s image URL in the database.
         * @param {string} id game id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGameImages: (id_1, imageType_1, file_1, replaceUrl_1, ...args_1) => __awaiter(this, [id_1, imageType_1, file_1, replaceUrl_1, ...args_1], void 0, function* (id, imageType, file, replaceUrl, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('uploadGameImages', 'id', id);
            // verify required parameter 'imageType' is not null or undefined
            (0, common_1.assertParamExists)('uploadGameImages', 'imageType', imageType);
            // verify required parameter 'file' is not null or undefined
            (0, common_1.assertParamExists)('uploadGameImages', 'file', file);
            const localVarPath = `/admin/games/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (imageType !== undefined) {
                localVarFormParams.append('imageType', imageType);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            if (replaceUrl !== undefined) {
                localVarFormParams.append('replaceUrl', replaceUrl);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminGameApiAxiosParamCreator = AdminGameApiAxiosParamCreator;
/**
 * AdminGameApi - functional programming interface
 * @export
 */
const AdminGameApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminGameApiAxiosParamCreator)(configuration);
    return {
        /**
         * Stores newly created external api key for a game.
         * @param {string} id game id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalApiKey(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createExternalApiKey(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameApi.createExternalApiKey']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {CreateGameArgs} createGameArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGame(createGameArgs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createGame(createGameArgs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameApi.createGame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGame(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteGame(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameApi.deleteGame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the external api keys for a game.
         * @param {string} id game id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExternalApiKey(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllExternalApiKey(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameApi.getAllExternalApiKey']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGames(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllGames(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameApi.getAllGames']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameById(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGameById(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameApi.getGameById']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates an existing external api key for a game.
         * @param {string} id api key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExternalApiKey(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateExternalApiKey(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameApi.updateExternalApiKey']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Updates an existing external api key for a game.
         * @param {Array<UpdateApiKeyArgs>} updateApiKeyArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExternalApiKeyBulk(updateApiKeyArgs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateExternalApiKeyBulk(updateApiKeyArgs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameApi.updateExternalApiKeyBulk']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {PartialCreateGameArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGame(id, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateGame(id, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameApi.updateGame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Uploads an image to S3 and updates the game\'s image URL in the database.
         * @param {string} id game id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGameImages(id, imageType, file, replaceUrl, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadGameImages(id, imageType, file, replaceUrl, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameApi.uploadGameImages']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminGameApiFp = AdminGameApiFp;
/**
 * AdminGameApi - factory interface
 * @export
 */
const AdminGameApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminGameApiFp)(configuration);
    return {
        /**
         * Stores newly created external api key for a game.
         * @param {string} id game id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalApiKey(id, options) {
            return localVarFp.createExternalApiKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {CreateGameArgs} createGameArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGame(createGameArgs, options) {
            return localVarFp.createGame(createGameArgs, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGame(id, options) {
            return localVarFp.deleteGame(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the external api keys for a game.
         * @param {string} id game id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExternalApiKey(id, options) {
            return localVarFp.getAllExternalApiKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGames(options) {
            return localVarFp.getAllGames(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameById(id, options) {
            return localVarFp.getGameById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing external api key for a game.
         * @param {string} id api key id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExternalApiKey(id, options) {
            return localVarFp.updateExternalApiKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing external api key for a game.
         * @param {Array<UpdateApiKeyArgs>} updateApiKeyArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExternalApiKeyBulk(updateApiKeyArgs, options) {
            return localVarFp.updateExternalApiKeyBulk(updateApiKeyArgs, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {PartialCreateGameArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGame(id, body, options) {
            return localVarFp.updateGame(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads an image to S3 and updates the game\'s image URL in the database.
         * @param {string} id game id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGameImages(id, imageType, file, replaceUrl, options) {
            return localVarFp.uploadGameImages(id, imageType, file, replaceUrl, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminGameApiFactory = AdminGameApiFactory;
/**
 * AdminGameApi - object-oriented interface
 * @export
 * @class AdminGameApi
 * @extends {BaseAPI}
 */
class AdminGameApi extends base_1.BaseAPI {
    /**
     * Stores newly created external api key for a game.
     * @param {string} id game id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    createExternalApiKey(id, options) {
        return (0, exports.AdminGameApiFp)(this.configuration).createExternalApiKey(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {CreateGameArgs} createGameArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    createGame(createGameArgs, options) {
        return (0, exports.AdminGameApiFp)(this.configuration).createGame(createGameArgs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    deleteGame(id, options) {
        return (0, exports.AdminGameApiFp)(this.configuration).deleteGame(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the external api keys for a game.
     * @param {string} id game id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    getAllExternalApiKey(id, options) {
        return (0, exports.AdminGameApiFp)(this.configuration).getAllExternalApiKey(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    getAllGames(options) {
        return (0, exports.AdminGameApiFp)(this.configuration).getAllGames(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    getGameById(id, options) {
        return (0, exports.AdminGameApiFp)(this.configuration).getGameById(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing external api key for a game.
     * @param {string} id api key id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    updateExternalApiKey(id, options) {
        return (0, exports.AdminGameApiFp)(this.configuration).updateExternalApiKey(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing external api key for a game.
     * @param {Array<UpdateApiKeyArgs>} updateApiKeyArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    updateExternalApiKeyBulk(updateApiKeyArgs, options) {
        return (0, exports.AdminGameApiFp)(this.configuration).updateExternalApiKeyBulk(updateApiKeyArgs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {PartialCreateGameArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    updateGame(id, body, options) {
        return (0, exports.AdminGameApiFp)(this.configuration).updateGame(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Uploads an image to S3 and updates the game\'s image URL in the database.
     * @param {string} id game id
     * @param {string} imageType corresponds to the DB column name
     * @param {File} file image to upload to S3
     * @param {string} [replaceUrl] optional url to replace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameApi
     */
    uploadGameImages(id, imageType, file, replaceUrl, options) {
        return (0, exports.AdminGameApiFp)(this.configuration).uploadGameImages(id, imageType, file, replaceUrl, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminGameApi = AdminGameApi;
/**
 * AdminGameLinkApi - axios parameter creator
 * @export
 */
const AdminGameLinkApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} gameId
         * @param {PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGameLink: (gameId_1, body_1, ...args_1) => __awaiter(this, [gameId_1, body_1, ...args_1], void 0, function* (gameId, body, options = {}) {
            // verify required parameter 'gameId' is not null or undefined
            (0, common_1.assertParamExists)('createGameLink', 'gameId', gameId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createGameLink', 'body', body);
            const localVarPath = `/admin/game-links/{gameId}`
                .replace(`{${"gameId"}}`, encodeURIComponent(String(gameId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGameLink: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteGameLink', 'id', id);
            const localVarPath = `/admin/game-links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameLinks: (gameId_1, ...args_1) => __awaiter(this, [gameId_1, ...args_1], void 0, function* (gameId, options = {}) {
            // verify required parameter 'gameId' is not null or undefined
            (0, common_1.assertParamExists)('getGameLinks', 'gameId', gameId);
            const localVarPath = `/admin/game-links/{gameId}`
                .replace(`{${"gameId"}}`, encodeURIComponent(String(gameId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {PartialCreateGameLinkArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGameLink: (id_1, body_1, ...args_1) => __awaiter(this, [id_1, body_1, ...args_1], void 0, function* (id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateGameLink', 'id', id);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateGameLink', 'body', body);
            const localVarPath = `/admin/game-links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {Array<UpdateGameLinksBulkArgs>} updateGameLinksBulkArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGameLinks: (updateGameLinksBulkArgs_1, ...args_1) => __awaiter(this, [updateGameLinksBulkArgs_1, ...args_1], void 0, function* (updateGameLinksBulkArgs, options = {}) {
            // verify required parameter 'updateGameLinksBulkArgs' is not null or undefined
            (0, common_1.assertParamExists)('updateGameLinks', 'updateGameLinksBulkArgs', updateGameLinksBulkArgs);
            const localVarPath = `/admin/game-links/bulkUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateGameLinksBulkArgs, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminGameLinkApiAxiosParamCreator = AdminGameLinkApiAxiosParamCreator;
/**
 * AdminGameLinkApi - functional programming interface
 * @export
 */
const AdminGameLinkApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminGameLinkApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {string} gameId
         * @param {PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGameLink(gameId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createGameLink(gameId, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameLinkApi.createGameLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGameLink(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteGameLink(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameLinkApi.deleteGameLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameLinks(gameId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGameLinks(gameId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameLinkApi.getGameLinks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {PartialCreateGameLinkArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGameLink(id, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateGameLink(id, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameLinkApi.updateGameLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {Array<UpdateGameLinksBulkArgs>} updateGameLinksBulkArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGameLinks(updateGameLinksBulkArgs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateGameLinks(updateGameLinksBulkArgs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminGameLinkApi.updateGameLinks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminGameLinkApiFp = AdminGameLinkApiFp;
/**
 * AdminGameLinkApi - factory interface
 * @export
 */
const AdminGameLinkApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminGameLinkApiFp)(configuration);
    return {
        /**
         *
         * @param {string} gameId
         * @param {PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGameLink(gameId, body, options) {
            return localVarFp.createGameLink(gameId, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGameLink(id, options) {
            return localVarFp.deleteGameLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameLinks(gameId, options) {
            return localVarFp.getGameLinks(gameId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {PartialCreateGameLinkArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGameLink(id, body, options) {
            return localVarFp.updateGameLink(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Array<UpdateGameLinksBulkArgs>} updateGameLinksBulkArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGameLinks(updateGameLinksBulkArgs, options) {
            return localVarFp.updateGameLinks(updateGameLinksBulkArgs, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminGameLinkApiFactory = AdminGameLinkApiFactory;
/**
 * AdminGameLinkApi - object-oriented interface
 * @export
 * @class AdminGameLinkApi
 * @extends {BaseAPI}
 */
class AdminGameLinkApi extends base_1.BaseAPI {
    /**
     *
     * @param {string} gameId
     * @param {PickPrismaGameLinksUncheckedCreateInputLinkTypeOrUrlOrOrderOrStatusOrGameId} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameLinkApi
     */
    createGameLink(gameId, body, options) {
        return (0, exports.AdminGameLinkApiFp)(this.configuration).createGameLink(gameId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameLinkApi
     */
    deleteGameLink(id, options) {
        return (0, exports.AdminGameLinkApiFp)(this.configuration).deleteGameLink(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} gameId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameLinkApi
     */
    getGameLinks(gameId, options) {
        return (0, exports.AdminGameLinkApiFp)(this.configuration).getGameLinks(gameId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {PartialCreateGameLinkArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameLinkApi
     */
    updateGameLink(id, body, options) {
        return (0, exports.AdminGameLinkApiFp)(this.configuration).updateGameLink(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {Array<UpdateGameLinksBulkArgs>} updateGameLinksBulkArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGameLinkApi
     */
    updateGameLinks(updateGameLinksBulkArgs, options) {
        return (0, exports.AdminGameLinkApiFp)(this.configuration).updateGameLinks(updateGameLinksBulkArgs, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminGameLinkApi = AdminGameLinkApi;
/**
 * AdminLeaderboardApi - axios parameter creator
 * @export
 */
const AdminLeaderboardApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {CreateLeaderboardArgs} createLeaderboardArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboard: (createLeaderboardArgs_1, ...args_1) => __awaiter(this, [createLeaderboardArgs_1, ...args_1], void 0, function* (createLeaderboardArgs, options = {}) {
            // verify required parameter 'createLeaderboardArgs' is not null or undefined
            (0, common_1.assertParamExists)('createLeaderboard', 'createLeaderboardArgs', createLeaderboardArgs);
            const localVarPath = `/admin/leaderboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createLeaderboardArgs, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboard: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteLeaderboard', 'id', id);
            const localVarPath = `/admin/leaderboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Note: although its possible for an event to have multiple leaderboards, this endpoint will only return the first one found b/c currently we only do events with one leaderboard. That typically means 1 leaderboard schedule starting/ending at the same time as the event itself. Get a leaderboard by event id
         * @param {string} eventId - The event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboard: (eventId_1, ...args_1) => __awaiter(this, [eventId_1, ...args_1], void 0, function* (eventId, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('getLeaderboard', 'eventId', eventId);
            const localVarPath = `/admin/leaderboards/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {SaveLeaderboardArgs} saveLeaderboardArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboard: (saveLeaderboardArgs_1, ...args_1) => __awaiter(this, [saveLeaderboardArgs_1, ...args_1], void 0, function* (saveLeaderboardArgs, options = {}) {
            // verify required parameter 'saveLeaderboardArgs' is not null or undefined
            (0, common_1.assertParamExists)('saveLeaderboard', 'saveLeaderboardArgs', saveLeaderboardArgs);
            const localVarPath = `/admin/leaderboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(saveLeaderboardArgs, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {PartialCreateLeaderboardArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboard: (id_1, body_1, ...args_1) => __awaiter(this, [id_1, body_1, ...args_1], void 0, function* (id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateLeaderboard', 'id', id);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateLeaderboard', 'body', body);
            const localVarPath = `/admin/leaderboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminLeaderboardApiAxiosParamCreator = AdminLeaderboardApiAxiosParamCreator;
/**
 * AdminLeaderboardApi - functional programming interface
 * @export
 */
const AdminLeaderboardApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminLeaderboardApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {CreateLeaderboardArgs} createLeaderboardArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboard(createLeaderboardArgs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createLeaderboard(createLeaderboardArgs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardApi.createLeaderboard']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboard(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteLeaderboard(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardApi.deleteLeaderboard']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Note: although its possible for an event to have multiple leaderboards, this endpoint will only return the first one found b/c currently we only do events with one leaderboard. That typically means 1 leaderboard schedule starting/ending at the same time as the event itself. Get a leaderboard by event id
         * @param {string} eventId - The event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboard(eventId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLeaderboard(eventId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardApi.getLeaderboard']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {SaveLeaderboardArgs} saveLeaderboardArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboard(saveLeaderboardArgs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.saveLeaderboard(saveLeaderboardArgs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardApi.saveLeaderboard']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {PartialCreateLeaderboardArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboard(id, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateLeaderboard(id, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardApi.updateLeaderboard']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminLeaderboardApiFp = AdminLeaderboardApiFp;
/**
 * AdminLeaderboardApi - factory interface
 * @export
 */
const AdminLeaderboardApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminLeaderboardApiFp)(configuration);
    return {
        /**
         *
         * @param {CreateLeaderboardArgs} createLeaderboardArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboard(createLeaderboardArgs, options) {
            return localVarFp.createLeaderboard(createLeaderboardArgs, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboard(id, options) {
            return localVarFp.deleteLeaderboard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Note: although its possible for an event to have multiple leaderboards, this endpoint will only return the first one found b/c currently we only do events with one leaderboard. That typically means 1 leaderboard schedule starting/ending at the same time as the event itself. Get a leaderboard by event id
         * @param {string} eventId - The event id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboard(eventId, options) {
            return localVarFp.getLeaderboard(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SaveLeaderboardArgs} saveLeaderboardArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboard(saveLeaderboardArgs, options) {
            return localVarFp.saveLeaderboard(saveLeaderboardArgs, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {PartialCreateLeaderboardArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboard(id, body, options) {
            return localVarFp.updateLeaderboard(id, body, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminLeaderboardApiFactory = AdminLeaderboardApiFactory;
/**
 * AdminLeaderboardApi - object-oriented interface
 * @export
 * @class AdminLeaderboardApi
 * @extends {BaseAPI}
 */
class AdminLeaderboardApi extends base_1.BaseAPI {
    /**
     *
     * @param {CreateLeaderboardArgs} createLeaderboardArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardApi
     */
    createLeaderboard(createLeaderboardArgs, options) {
        return (0, exports.AdminLeaderboardApiFp)(this.configuration).createLeaderboard(createLeaderboardArgs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardApi
     */
    deleteLeaderboard(id, options) {
        return (0, exports.AdminLeaderboardApiFp)(this.configuration).deleteLeaderboard(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Note: although its possible for an event to have multiple leaderboards, this endpoint will only return the first one found b/c currently we only do events with one leaderboard. That typically means 1 leaderboard schedule starting/ending at the same time as the event itself. Get a leaderboard by event id
     * @param {string} eventId - The event id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardApi
     */
    getLeaderboard(eventId, options) {
        return (0, exports.AdminLeaderboardApiFp)(this.configuration).getLeaderboard(eventId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {SaveLeaderboardArgs} saveLeaderboardArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardApi
     */
    saveLeaderboard(saveLeaderboardArgs, options) {
        return (0, exports.AdminLeaderboardApiFp)(this.configuration).saveLeaderboard(saveLeaderboardArgs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {PartialCreateLeaderboardArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardApi
     */
    updateLeaderboard(id, body, options) {
        return (0, exports.AdminLeaderboardApiFp)(this.configuration).updateLeaderboard(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminLeaderboardApi = AdminLeaderboardApi;
/**
 * AdminLeaderboardFactorApi - axios parameter creator
 * @export
 */
const AdminLeaderboardFactorApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardFactor: (body_1, ...args_1) => __awaiter(this, [body_1, ...args_1], void 0, function* (body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createLeaderboardFactor', 'body', body);
            const localVarPath = `/admin/leaderboard-factors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardFactor: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteLeaderboardFactor', 'id', id);
            const localVarPath = `/admin/leaderboard-factors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} leaderboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardFactor: (leaderboardId_1, ...args_1) => __awaiter(this, [leaderboardId_1, ...args_1], void 0, function* (leaderboardId, options = {}) {
            // verify required parameter 'leaderboardId' is not null or undefined
            (0, common_1.assertParamExists)('getLeaderboardFactor', 'leaderboardId', leaderboardId);
            const localVarPath = `/admin/leaderboard-factors/{leaderboardId}`
                .replace(`{${"leaderboardId"}}`, encodeURIComponent(String(leaderboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboardFactor: (body_1, ...args_1) => __awaiter(this, [body_1, ...args_1], void 0, function* (body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('saveLeaderboardFactor', 'body', body);
            const localVarPath = `/admin/leaderboard-factors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {PartialCreateLeaderboardFactorArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardFactor: (id_1, body_1, ...args_1) => __awaiter(this, [id_1, body_1, ...args_1], void 0, function* (id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateLeaderboardFactor', 'id', id);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateLeaderboardFactor', 'body', body);
            const localVarPath = `/admin/leaderboard-factors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminLeaderboardFactorApiAxiosParamCreator = AdminLeaderboardFactorApiAxiosParamCreator;
/**
 * AdminLeaderboardFactorApi - functional programming interface
 * @export
 */
const AdminLeaderboardFactorApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminLeaderboardFactorApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardFactor(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createLeaderboardFactor(body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardFactorApi.createLeaderboardFactor']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardFactor(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteLeaderboardFactor(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardFactorApi.deleteLeaderboardFactor']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} leaderboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardFactor(leaderboardId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLeaderboardFactor(leaderboardId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardFactorApi.getLeaderboardFactor']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboardFactor(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.saveLeaderboardFactor(body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardFactorApi.saveLeaderboardFactor']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {PartialCreateLeaderboardFactorArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardFactor(id, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateLeaderboardFactor(id, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardFactorApi.updateLeaderboardFactor']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminLeaderboardFactorApiFp = AdminLeaderboardFactorApiFp;
/**
 * AdminLeaderboardFactorApi - factory interface
 * @export
 */
const AdminLeaderboardFactorApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminLeaderboardFactorApiFp)(configuration);
    return {
        /**
         *
         * @param {PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardFactor(body, options) {
            return localVarFp.createLeaderboardFactor(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardFactor(id, options) {
            return localVarFp.deleteLeaderboardFactor(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} leaderboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardFactor(leaderboardId, options) {
            return localVarFp.getLeaderboardFactor(leaderboardId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboardFactor(body, options) {
            return localVarFp.saveLeaderboardFactor(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {PartialCreateLeaderboardFactorArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardFactor(id, body, options) {
            return localVarFp.updateLeaderboardFactor(id, body, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminLeaderboardFactorApiFactory = AdminLeaderboardFactorApiFactory;
/**
 * AdminLeaderboardFactorApi - object-oriented interface
 * @export
 * @class AdminLeaderboardFactorApi
 * @extends {BaseAPI}
 */
class AdminLeaderboardFactorApi extends base_1.BaseAPI {
    /**
     *
     * @param {PickPrismaLeaderboardFactorUncheckedCreateInputObjectIdOrTypeOrLeaderboardId} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardFactorApi
     */
    createLeaderboardFactor(body, options) {
        return (0, exports.AdminLeaderboardFactorApiFp)(this.configuration).createLeaderboardFactor(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardFactorApi
     */
    deleteLeaderboardFactor(id, options) {
        return (0, exports.AdminLeaderboardFactorApiFp)(this.configuration).deleteLeaderboardFactor(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} leaderboardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardFactorApi
     */
    getLeaderboardFactor(leaderboardId, options) {
        return (0, exports.AdminLeaderboardFactorApiFp)(this.configuration).getLeaderboardFactor(leaderboardId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {PartialPickPrismaLeaderboardFactorUncheckedCreateInputIdOrObjectIdOrTypeOrLeaderboardId} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardFactorApi
     */
    saveLeaderboardFactor(body, options) {
        return (0, exports.AdminLeaderboardFactorApiFp)(this.configuration).saveLeaderboardFactor(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {PartialCreateLeaderboardFactorArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardFactorApi
     */
    updateLeaderboardFactor(id, body, options) {
        return (0, exports.AdminLeaderboardFactorApiFp)(this.configuration).updateLeaderboardFactor(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminLeaderboardFactorApi = AdminLeaderboardFactorApi;
/**
 * AdminLeaderboardRewardApi - axios parameter creator
 * @export
 */
const AdminLeaderboardRewardApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {CreateLeaderboardRewardsArgs} createLeaderboardRewardsArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardRewards: (createLeaderboardRewardsArgs_1, ...args_1) => __awaiter(this, [createLeaderboardRewardsArgs_1, ...args_1], void 0, function* (createLeaderboardRewardsArgs, options = {}) {
            // verify required parameter 'createLeaderboardRewardsArgs' is not null or undefined
            (0, common_1.assertParamExists)('createLeaderboardRewards', 'createLeaderboardRewardsArgs', createLeaderboardRewardsArgs);
            const localVarPath = `/admin/leaderboard-rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createLeaderboardRewardsArgs, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardReward: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteLeaderboardReward', 'id', id);
            const localVarPath = `/admin/leaderboard-rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} leaderboardScheduleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRewards: (leaderboardScheduleId_1, ...args_1) => __awaiter(this, [leaderboardScheduleId_1, ...args_1], void 0, function* (leaderboardScheduleId, options = {}) {
            // verify required parameter 'leaderboardScheduleId' is not null or undefined
            (0, common_1.assertParamExists)('getLeaderboardRewards', 'leaderboardScheduleId', leaderboardScheduleId);
            const localVarPath = `/admin/leaderboard-rewards/{leaderboardScheduleId}`
                .replace(`{${"leaderboardScheduleId"}}`, encodeURIComponent(String(leaderboardScheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} leaderboardScheduleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRewardsSummary: (leaderboardScheduleId_1, ...args_1) => __awaiter(this, [leaderboardScheduleId_1, ...args_1], void 0, function* (leaderboardScheduleId, options = {}) {
            // verify required parameter 'leaderboardScheduleId' is not null or undefined
            (0, common_1.assertParamExists)('getLeaderboardRewardsSummary', 'leaderboardScheduleId', leaderboardScheduleId);
            const localVarPath = `/admin/leaderboard-rewards/summary/{leaderboardScheduleId}`
                .replace(`{${"leaderboardScheduleId"}}`, encodeURIComponent(String(leaderboardScheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {CreateLeaderboardRewardsArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboardRewards: (body_1, ...args_1) => __awaiter(this, [body_1, ...args_1], void 0, function* (body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('saveLeaderboardRewards', 'body', body);
            const localVarPath = `/admin/leaderboard-rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardRewards: (id_1, body_1, ...args_1) => __awaiter(this, [id_1, body_1, ...args_1], void 0, function* (id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateLeaderboardRewards', 'id', id);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateLeaderboardRewards', 'body', body);
            const localVarPath = `/admin/leaderboard-rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminLeaderboardRewardApiAxiosParamCreator = AdminLeaderboardRewardApiAxiosParamCreator;
/**
 * AdminLeaderboardRewardApi - functional programming interface
 * @export
 */
const AdminLeaderboardRewardApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminLeaderboardRewardApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {CreateLeaderboardRewardsArgs} createLeaderboardRewardsArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardRewards(createLeaderboardRewardsArgs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createLeaderboardRewards(createLeaderboardRewardsArgs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardRewardApi.createLeaderboardRewards']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardReward(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteLeaderboardReward(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardRewardApi.deleteLeaderboardReward']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} leaderboardScheduleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRewards(leaderboardScheduleId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLeaderboardRewards(leaderboardScheduleId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardRewardApi.getLeaderboardRewards']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} leaderboardScheduleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRewardsSummary(leaderboardScheduleId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLeaderboardRewardsSummary(leaderboardScheduleId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardRewardApi.getLeaderboardRewardsSummary']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {CreateLeaderboardRewardsArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboardRewards(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.saveLeaderboardRewards(body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardRewardApi.saveLeaderboardRewards']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardRewards(id, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateLeaderboardRewards(id, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardRewardApi.updateLeaderboardRewards']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminLeaderboardRewardApiFp = AdminLeaderboardRewardApiFp;
/**
 * AdminLeaderboardRewardApi - factory interface
 * @export
 */
const AdminLeaderboardRewardApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminLeaderboardRewardApiFp)(configuration);
    return {
        /**
         *
         * @param {CreateLeaderboardRewardsArgs} createLeaderboardRewardsArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardRewards(createLeaderboardRewardsArgs, options) {
            return localVarFp.createLeaderboardRewards(createLeaderboardRewardsArgs, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardReward(id, options) {
            return localVarFp.deleteLeaderboardReward(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} leaderboardScheduleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRewards(leaderboardScheduleId, options) {
            return localVarFp.getLeaderboardRewards(leaderboardScheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} leaderboardScheduleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardRewardsSummary(leaderboardScheduleId, options) {
            return localVarFp.getLeaderboardRewardsSummary(leaderboardScheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {CreateLeaderboardRewardsArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLeaderboardRewards(body, options) {
            return localVarFp.saveLeaderboardRewards(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardRewards(id, body, options) {
            return localVarFp.updateLeaderboardRewards(id, body, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminLeaderboardRewardApiFactory = AdminLeaderboardRewardApiFactory;
/**
 * AdminLeaderboardRewardApi - object-oriented interface
 * @export
 * @class AdminLeaderboardRewardApi
 * @extends {BaseAPI}
 */
class AdminLeaderboardRewardApi extends base_1.BaseAPI {
    /**
     *
     * @param {CreateLeaderboardRewardsArgs} createLeaderboardRewardsArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardRewardApi
     */
    createLeaderboardRewards(createLeaderboardRewardsArgs, options) {
        return (0, exports.AdminLeaderboardRewardApiFp)(this.configuration).createLeaderboardRewards(createLeaderboardRewardsArgs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardRewardApi
     */
    deleteLeaderboardReward(id, options) {
        return (0, exports.AdminLeaderboardRewardApiFp)(this.configuration).deleteLeaderboardReward(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} leaderboardScheduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardRewardApi
     */
    getLeaderboardRewards(leaderboardScheduleId, options) {
        return (0, exports.AdminLeaderboardRewardApiFp)(this.configuration).getLeaderboardRewards(leaderboardScheduleId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} leaderboardScheduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardRewardApi
     */
    getLeaderboardRewardsSummary(leaderboardScheduleId, options) {
        return (0, exports.AdminLeaderboardRewardApiFp)(this.configuration).getLeaderboardRewardsSummary(leaderboardScheduleId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {CreateLeaderboardRewardsArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardRewardApi
     */
    saveLeaderboardRewards(body, options) {
        return (0, exports.AdminLeaderboardRewardApiFp)(this.configuration).saveLeaderboardRewards(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {PickPrismaLeaderboardRewardUncheckedCreateInputQuantityOrRewardPlaceOrProductIdOrLeaderboardScheduleId} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardRewardApi
     */
    updateLeaderboardRewards(id, body, options) {
        return (0, exports.AdminLeaderboardRewardApiFp)(this.configuration).updateLeaderboardRewards(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminLeaderboardRewardApi = AdminLeaderboardRewardApi;
/**
 * AdminLeaderboardScheduleApi - axios parameter creator
 * @export
 */
const AdminLeaderboardScheduleApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardSchedule: (body_1, ...args_1) => __awaiter(this, [body_1, ...args_1], void 0, function* (body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createLeaderboardSchedule', 'body', body);
            const localVarPath = `/admin/leaderboard-schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardSchedule: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteLeaderboardSchedule', 'id', id);
            const localVarPath = `/admin/leaderboard-schedules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} leaderboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardSchedules: (leaderboardId_1, ...args_1) => __awaiter(this, [leaderboardId_1, ...args_1], void 0, function* (leaderboardId, options = {}) {
            // verify required parameter 'leaderboardId' is not null or undefined
            (0, common_1.assertParamExists)('getLeaderboardSchedules', 'leaderboardId', leaderboardId);
            const localVarPath = `/admin/leaderboard-schedules/{leaderboardId}`
                .replace(`{${"leaderboardId"}}`, encodeURIComponent(String(leaderboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {PartialCreateLeaderboardScheduleArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardSchedule: (id_1, body_1, ...args_1) => __awaiter(this, [id_1, body_1, ...args_1], void 0, function* (id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateLeaderboardSchedule', 'id', id);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateLeaderboardSchedule', 'body', body);
            const localVarPath = `/admin/leaderboard-schedules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminLeaderboardScheduleApiAxiosParamCreator = AdminLeaderboardScheduleApiAxiosParamCreator;
/**
 * AdminLeaderboardScheduleApi - functional programming interface
 * @export
 */
const AdminLeaderboardScheduleApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminLeaderboardScheduleApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardSchedule(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createLeaderboardSchedule(body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardScheduleApi.createLeaderboardSchedule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardSchedule(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteLeaderboardSchedule(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardScheduleApi.deleteLeaderboardSchedule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} leaderboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardSchedules(leaderboardId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLeaderboardSchedules(leaderboardId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardScheduleApi.getLeaderboardSchedules']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {PartialCreateLeaderboardScheduleArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardSchedule(id, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateLeaderboardSchedule(id, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminLeaderboardScheduleApi.updateLeaderboardSchedule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminLeaderboardScheduleApiFp = AdminLeaderboardScheduleApiFp;
/**
 * AdminLeaderboardScheduleApi - factory interface
 * @export
 */
const AdminLeaderboardScheduleApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminLeaderboardScheduleApiFp)(configuration);
    return {
        /**
         *
         * @param {PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLeaderboardSchedule(body, options) {
            return localVarFp.createLeaderboardSchedule(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLeaderboardSchedule(id, options) {
            return localVarFp.deleteLeaderboardSchedule(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} leaderboardId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardSchedules(leaderboardId, options) {
            return localVarFp.getLeaderboardSchedules(leaderboardId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {PartialCreateLeaderboardScheduleArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLeaderboardSchedule(id, body, options) {
            return localVarFp.updateLeaderboardSchedule(id, body, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminLeaderboardScheduleApiFactory = AdminLeaderboardScheduleApiFactory;
/**
 * AdminLeaderboardScheduleApi - object-oriented interface
 * @export
 * @class AdminLeaderboardScheduleApi
 * @extends {BaseAPI}
 */
class AdminLeaderboardScheduleApi extends base_1.BaseAPI {
    /**
     *
     * @param {PickPrismaLeaderboardScheduleUncheckedCreateInputStartTimeOrEndTimeOrScheduleProcessedOrRewardsProcessedOrLeaderboardId} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardScheduleApi
     */
    createLeaderboardSchedule(body, options) {
        return (0, exports.AdminLeaderboardScheduleApiFp)(this.configuration).createLeaderboardSchedule(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardScheduleApi
     */
    deleteLeaderboardSchedule(id, options) {
        return (0, exports.AdminLeaderboardScheduleApiFp)(this.configuration).deleteLeaderboardSchedule(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} leaderboardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardScheduleApi
     */
    getLeaderboardSchedules(leaderboardId, options) {
        return (0, exports.AdminLeaderboardScheduleApiFp)(this.configuration).getLeaderboardSchedules(leaderboardId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {PartialCreateLeaderboardScheduleArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLeaderboardScheduleApi
     */
    updateLeaderboardSchedule(id, body, options) {
        return (0, exports.AdminLeaderboardScheduleApiFp)(this.configuration).updateLeaderboardSchedule(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminLeaderboardScheduleApi = AdminLeaderboardScheduleApi;
/**
 * AdminProductApi - axios parameter creator
 * @export
 */
const AdminProductApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {CreateProductArgs} createProductArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: (createProductArgs_1, ...args_1) => __awaiter(this, [createProductArgs_1, ...args_1], void 0, function* (createProductArgs, options = {}) {
            // verify required parameter 'createProductArgs' is not null or undefined
            (0, common_1.assertParamExists)('createProduct', 'createProductArgs', createProductArgs);
            const localVarPath = `/admin/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createProductArgs, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteProduct', 'id', id);
            const localVarPath = `/admin/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {Array<ProductType>} types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts: (types_1, ...args_1) => __awaiter(this, [types_1, ...args_1], void 0, function* (types, options = {}) {
            // verify required parameter 'types' is not null or undefined
            (0, common_1.assertParamExists)('getAllProducts', 'types', types);
            const localVarPath = `/admin/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (types) {
                localVarQueryParameter['types'] = types;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getProduct', 'id', id);
            const localVarPath = `/admin/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {PartialCreateProductArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: (id_1, body_1, ...args_1) => __awaiter(this, [id_1, body_1, ...args_1], void 0, function* (id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateProduct', 'id', id);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateProduct', 'body', body);
            const localVarPath = `/admin/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Uploads an image to S3 and updates the product\'s image URL in the database.
         * @param {string} id product id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProductImages: (id_1, imageType_1, file_1, replaceUrl_1, ...args_1) => __awaiter(this, [id_1, imageType_1, file_1, replaceUrl_1, ...args_1], void 0, function* (id, imageType, file, replaceUrl, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('uploadProductImages', 'id', id);
            // verify required parameter 'imageType' is not null or undefined
            (0, common_1.assertParamExists)('uploadProductImages', 'imageType', imageType);
            // verify required parameter 'file' is not null or undefined
            (0, common_1.assertParamExists)('uploadProductImages', 'file', file);
            const localVarPath = `/admin/products/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (imageType !== undefined) {
                localVarFormParams.append('imageType', imageType);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            if (replaceUrl !== undefined) {
                localVarFormParams.append('replaceUrl', replaceUrl);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminProductApiAxiosParamCreator = AdminProductApiAxiosParamCreator;
/**
 * AdminProductApi - functional programming interface
 * @export
 */
const AdminProductApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminProductApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {CreateProductArgs} createProductArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(createProductArgs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createProduct(createProductArgs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminProductApi.createProduct']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteProduct(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminProductApi.deleteProduct']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {Array<ProductType>} types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(types, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllProducts(types, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminProductApi.getAllProducts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProduct(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminProductApi.getProduct']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {PartialCreateProductArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateProduct(id, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminProductApi.updateProduct']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Uploads an image to S3 and updates the product\'s image URL in the database.
         * @param {string} id product id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProductImages(id, imageType, file, replaceUrl, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadProductImages(id, imageType, file, replaceUrl, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminProductApi.uploadProductImages']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminProductApiFp = AdminProductApiFp;
/**
 * AdminProductApi - factory interface
 * @export
 */
const AdminProductApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminProductApiFp)(configuration);
    return {
        /**
         *
         * @param {CreateProductArgs} createProductArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(createProductArgs, options) {
            return localVarFp.createProduct(createProductArgs, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id, options) {
            return localVarFp.deleteProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Array<ProductType>} types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProducts(types, options) {
            return localVarFp.getAllProducts(types, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id, options) {
            return localVarFp.getProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {PartialCreateProductArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id, body, options) {
            return localVarFp.updateProduct(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads an image to S3 and updates the product\'s image URL in the database.
         * @param {string} id product id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProductImages(id, imageType, file, replaceUrl, options) {
            return localVarFp.uploadProductImages(id, imageType, file, replaceUrl, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminProductApiFactory = AdminProductApiFactory;
/**
 * AdminProductApi - object-oriented interface
 * @export
 * @class AdminProductApi
 * @extends {BaseAPI}
 */
class AdminProductApi extends base_1.BaseAPI {
    /**
     *
     * @param {CreateProductArgs} createProductArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProductApi
     */
    createProduct(createProductArgs, options) {
        return (0, exports.AdminProductApiFp)(this.configuration).createProduct(createProductArgs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProductApi
     */
    deleteProduct(id, options) {
        return (0, exports.AdminProductApiFp)(this.configuration).deleteProduct(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {Array<ProductType>} types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProductApi
     */
    getAllProducts(types, options) {
        return (0, exports.AdminProductApiFp)(this.configuration).getAllProducts(types, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProductApi
     */
    getProduct(id, options) {
        return (0, exports.AdminProductApiFp)(this.configuration).getProduct(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {PartialCreateProductArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProductApi
     */
    updateProduct(id, body, options) {
        return (0, exports.AdminProductApiFp)(this.configuration).updateProduct(id, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Uploads an image to S3 and updates the product\'s image URL in the database.
     * @param {string} id product id
     * @param {string} imageType corresponds to the DB column name
     * @param {File} file image to upload to S3
     * @param {string} [replaceUrl] optional url to replace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProductApi
     */
    uploadProductImages(id, imageType, file, replaceUrl, options) {
        return (0, exports.AdminProductApiFp)(this.configuration).uploadProductImages(id, imageType, file, replaceUrl, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminProductApi = AdminProductApi;
/**
 * AdminQuestApi - axios parameter creator
 * @export
 */
const AdminQuestApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} eventId
         * @param {Array<QuestType>} questTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetQuests: (eventId_1, questTypes_1, ...args_1) => __awaiter(this, [eventId_1, questTypes_1, ...args_1], void 0, function* (eventId, questTypes, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('adminGetQuests', 'eventId', eventId);
            // verify required parameter 'questTypes' is not null or undefined
            (0, common_1.assertParamExists)('adminGetQuests', 'questTypes', questTypes);
            const localVarPath = `/admin/quests/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (questTypes) {
                localVarQueryParameter['questTypes'] = questTypes;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} gameId
         * @param {string} eventId
         * @param {CreateQuestGoalArgs} createQuestGoalArgs
         * @param {string} [questId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuest: (gameId_1, eventId_1, createQuestGoalArgs_1, questId_1, ...args_1) => __awaiter(this, [gameId_1, eventId_1, createQuestGoalArgs_1, questId_1, ...args_1], void 0, function* (gameId, eventId, createQuestGoalArgs, questId, options = {}) {
            // verify required parameter 'gameId' is not null or undefined
            (0, common_1.assertParamExists)('createQuest', 'gameId', gameId);
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('createQuest', 'eventId', eventId);
            // verify required parameter 'createQuestGoalArgs' is not null or undefined
            (0, common_1.assertParamExists)('createQuest', 'createQuestGoalArgs', createQuestGoalArgs);
            const localVarPath = `/admin/quests/{gameId}/{eventId}`
                .replace(`{${"gameId"}}`, encodeURIComponent(String(gameId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (questId !== undefined) {
                localVarQueryParameter['questId'] = questId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createQuestGoalArgs, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the underlying goal and quest.
         * @param {string} questId
         * @param {string} goalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuest: (questId_1, goalId_1, ...args_1) => __awaiter(this, [questId_1, goalId_1, ...args_1], void 0, function* (questId, goalId, options = {}) {
            // verify required parameter 'questId' is not null or undefined
            (0, common_1.assertParamExists)('deleteQuest', 'questId', questId);
            // verify required parameter 'goalId' is not null or undefined
            (0, common_1.assertParamExists)('deleteQuest', 'goalId', goalId);
            const localVarPath = `/admin/quests/{questId}/{goalId}`
                .replace(`{${"questId"}}`, encodeURIComponent(String(questId)))
                .replace(`{${"goalId"}}`, encodeURIComponent(String(goalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} questId
         * @param {string} goalId
         * @param {PartialCreateQuestGoalArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuest: (questId_1, goalId_1, body_1, ...args_1) => __awaiter(this, [questId_1, goalId_1, body_1, ...args_1], void 0, function* (questId, goalId, body, options = {}) {
            // verify required parameter 'questId' is not null or undefined
            (0, common_1.assertParamExists)('updateQuest', 'questId', questId);
            // verify required parameter 'goalId' is not null or undefined
            (0, common_1.assertParamExists)('updateQuest', 'goalId', goalId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateQuest', 'body', body);
            const localVarPath = `/admin/quests/{questId}/{goalId}`
                .replace(`{${"questId"}}`, encodeURIComponent(String(questId)))
                .replace(`{${"goalId"}}`, encodeURIComponent(String(goalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Uploads an image to S3 and updates the goal\'s (Quest) image URL in the database.
         * @param {string} id goal id not quest id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadQuestGoalImages: (id_1, imageType_1, file_1, replaceUrl_1, ...args_1) => __awaiter(this, [id_1, imageType_1, file_1, replaceUrl_1, ...args_1], void 0, function* (id, imageType, file, replaceUrl, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('uploadQuestGoalImages', 'id', id);
            // verify required parameter 'imageType' is not null or undefined
            (0, common_1.assertParamExists)('uploadQuestGoalImages', 'imageType', imageType);
            // verify required parameter 'file' is not null or undefined
            (0, common_1.assertParamExists)('uploadQuestGoalImages', 'file', file);
            const localVarPath = `/admin/quests/goal/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (imageType !== undefined) {
                localVarFormParams.append('imageType', imageType);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            if (replaceUrl !== undefined) {
                localVarFormParams.append('replaceUrl', replaceUrl);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminQuestApiAxiosParamCreator = AdminQuestApiAxiosParamCreator;
/**
 * AdminQuestApi - functional programming interface
 * @export
 */
const AdminQuestApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminQuestApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {string} eventId
         * @param {Array<QuestType>} questTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetQuests(eventId, questTypes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adminGetQuests(eventId, questTypes, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminQuestApi.adminGetQuests']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} gameId
         * @param {string} eventId
         * @param {CreateQuestGoalArgs} createQuestGoalArgs
         * @param {string} [questId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuest(gameId, eventId, createQuestGoalArgs, questId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createQuest(gameId, eventId, createQuestGoalArgs, questId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminQuestApi.createQuest']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes the underlying goal and quest.
         * @param {string} questId
         * @param {string} goalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuest(questId, goalId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteQuest(questId, goalId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminQuestApi.deleteQuest']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} questId
         * @param {string} goalId
         * @param {PartialCreateQuestGoalArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuest(questId, goalId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateQuest(questId, goalId, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminQuestApi.updateQuest']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Uploads an image to S3 and updates the goal\'s (Quest) image URL in the database.
         * @param {string} id goal id not quest id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadQuestGoalImages(id, imageType, file, replaceUrl, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadQuestGoalImages(id, imageType, file, replaceUrl, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminQuestApi.uploadQuestGoalImages']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminQuestApiFp = AdminQuestApiFp;
/**
 * AdminQuestApi - factory interface
 * @export
 */
const AdminQuestApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminQuestApiFp)(configuration);
    return {
        /**
         *
         * @param {string} eventId
         * @param {Array<QuestType>} questTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetQuests(eventId, questTypes, options) {
            return localVarFp.adminGetQuests(eventId, questTypes, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} gameId
         * @param {string} eventId
         * @param {CreateQuestGoalArgs} createQuestGoalArgs
         * @param {string} [questId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuest(gameId, eventId, createQuestGoalArgs, questId, options) {
            return localVarFp.createQuest(gameId, eventId, createQuestGoalArgs, questId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the underlying goal and quest.
         * @param {string} questId
         * @param {string} goalId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuest(questId, goalId, options) {
            return localVarFp.deleteQuest(questId, goalId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} questId
         * @param {string} goalId
         * @param {PartialCreateQuestGoalArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuest(questId, goalId, body, options) {
            return localVarFp.updateQuest(questId, goalId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads an image to S3 and updates the goal\'s (Quest) image URL in the database.
         * @param {string} id goal id not quest id
         * @param {string} imageType corresponds to the DB column name
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadQuestGoalImages(id, imageType, file, replaceUrl, options) {
            return localVarFp.uploadQuestGoalImages(id, imageType, file, replaceUrl, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminQuestApiFactory = AdminQuestApiFactory;
/**
 * AdminQuestApi - object-oriented interface
 * @export
 * @class AdminQuestApi
 * @extends {BaseAPI}
 */
class AdminQuestApi extends base_1.BaseAPI {
    /**
     *
     * @param {string} eventId
     * @param {Array<QuestType>} questTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestApi
     */
    adminGetQuests(eventId, questTypes, options) {
        return (0, exports.AdminQuestApiFp)(this.configuration).adminGetQuests(eventId, questTypes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} gameId
     * @param {string} eventId
     * @param {CreateQuestGoalArgs} createQuestGoalArgs
     * @param {string} [questId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestApi
     */
    createQuest(gameId, eventId, createQuestGoalArgs, questId, options) {
        return (0, exports.AdminQuestApiFp)(this.configuration).createQuest(gameId, eventId, createQuestGoalArgs, questId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the underlying goal and quest.
     * @param {string} questId
     * @param {string} goalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestApi
     */
    deleteQuest(questId, goalId, options) {
        return (0, exports.AdminQuestApiFp)(this.configuration).deleteQuest(questId, goalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} questId
     * @param {string} goalId
     * @param {PartialCreateQuestGoalArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestApi
     */
    updateQuest(questId, goalId, body, options) {
        return (0, exports.AdminQuestApiFp)(this.configuration).updateQuest(questId, goalId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Uploads an image to S3 and updates the goal\'s (Quest) image URL in the database.
     * @param {string} id goal id not quest id
     * @param {string} imageType corresponds to the DB column name
     * @param {File} file image to upload to S3
     * @param {string} [replaceUrl] optional url to replace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestApi
     */
    uploadQuestGoalImages(id, imageType, file, replaceUrl, options) {
        return (0, exports.AdminQuestApiFp)(this.configuration).uploadQuestGoalImages(id, imageType, file, replaceUrl, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminQuestApi = AdminQuestApi;
/**
 * AdminQuestRewardApi - axios parameter creator
 * @export
 */
const AdminQuestRewardApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Array<CreateQuestRewardArgs>} createQuestRewardArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManyQuestRewards: (createQuestRewardArgs_1, ...args_1) => __awaiter(this, [createQuestRewardArgs_1, ...args_1], void 0, function* (createQuestRewardArgs, options = {}) {
            // verify required parameter 'createQuestRewardArgs' is not null or undefined
            (0, common_1.assertParamExists)('createManyQuestRewards', 'createQuestRewardArgs', createQuestRewardArgs);
            const localVarPath = `/admin/quest-rewards/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createQuestRewardArgs, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {CreateQuestRewardArgs} createQuestRewardArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestReward: (createQuestRewardArgs_1, ...args_1) => __awaiter(this, [createQuestRewardArgs_1, ...args_1], void 0, function* (createQuestRewardArgs, options = {}) {
            // verify required parameter 'createQuestRewardArgs' is not null or undefined
            (0, common_1.assertParamExists)('createQuestReward', 'createQuestRewardArgs', createQuestRewardArgs);
            const localVarPath = `/admin/quest-rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createQuestRewardArgs, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestReward: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteQuestReward', 'id', id);
            const localVarPath = `/admin/quest-rewards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {PartialCreateQuestRewardArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestReward: (body_1, ...args_1) => __awaiter(this, [body_1, ...args_1], void 0, function* (body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateQuestReward', 'body', body);
            const localVarPath = `/admin/quest-rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminQuestRewardApiAxiosParamCreator = AdminQuestRewardApiAxiosParamCreator;
/**
 * AdminQuestRewardApi - functional programming interface
 * @export
 */
const AdminQuestRewardApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminQuestRewardApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {Array<CreateQuestRewardArgs>} createQuestRewardArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManyQuestRewards(createQuestRewardArgs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createManyQuestRewards(createQuestRewardArgs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminQuestRewardApi.createManyQuestRewards']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {CreateQuestRewardArgs} createQuestRewardArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestReward(createQuestRewardArgs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createQuestReward(createQuestRewardArgs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminQuestRewardApi.createQuestReward']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestReward(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteQuestReward(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminQuestRewardApi.deleteQuestReward']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {PartialCreateQuestRewardArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestReward(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateQuestReward(body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminQuestRewardApi.updateQuestReward']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminQuestRewardApiFp = AdminQuestRewardApiFp;
/**
 * AdminQuestRewardApi - factory interface
 * @export
 */
const AdminQuestRewardApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminQuestRewardApiFp)(configuration);
    return {
        /**
         *
         * @param {Array<CreateQuestRewardArgs>} createQuestRewardArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManyQuestRewards(createQuestRewardArgs, options) {
            return localVarFp.createManyQuestRewards(createQuestRewardArgs, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {CreateQuestRewardArgs} createQuestRewardArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestReward(createQuestRewardArgs, options) {
            return localVarFp.createQuestReward(createQuestRewardArgs, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestReward(id, options) {
            return localVarFp.deleteQuestReward(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PartialCreateQuestRewardArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestReward(body, options) {
            return localVarFp.updateQuestReward(body, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminQuestRewardApiFactory = AdminQuestRewardApiFactory;
/**
 * AdminQuestRewardApi - object-oriented interface
 * @export
 * @class AdminQuestRewardApi
 * @extends {BaseAPI}
 */
class AdminQuestRewardApi extends base_1.BaseAPI {
    /**
     *
     * @param {Array<CreateQuestRewardArgs>} createQuestRewardArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestRewardApi
     */
    createManyQuestRewards(createQuestRewardArgs, options) {
        return (0, exports.AdminQuestRewardApiFp)(this.configuration).createManyQuestRewards(createQuestRewardArgs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {CreateQuestRewardArgs} createQuestRewardArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestRewardApi
     */
    createQuestReward(createQuestRewardArgs, options) {
        return (0, exports.AdminQuestRewardApiFp)(this.configuration).createQuestReward(createQuestRewardArgs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestRewardApi
     */
    deleteQuestReward(id, options) {
        return (0, exports.AdminQuestRewardApiFp)(this.configuration).deleteQuestReward(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {PartialCreateQuestRewardArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestRewardApi
     */
    updateQuestReward(body, options) {
        return (0, exports.AdminQuestRewardApiFp)(this.configuration).updateQuestReward(body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminQuestRewardApi = AdminQuestRewardApi;
/**
 * AdminQuestScheduleApi - axios parameter creator
 * @export
 */
const AdminQuestScheduleApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {CreateQuestScheduleArgs} createQuestScheduleArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestSchedule: (createQuestScheduleArgs_1, ...args_1) => __awaiter(this, [createQuestScheduleArgs_1, ...args_1], void 0, function* (createQuestScheduleArgs, options = {}) {
            // verify required parameter 'createQuestScheduleArgs' is not null or undefined
            (0, common_1.assertParamExists)('createQuestSchedule', 'createQuestScheduleArgs', createQuestScheduleArgs);
            const localVarPath = `/admin/quest-schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createQuestScheduleArgs, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestSchedule: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteQuestSchedule', 'id', id);
            const localVarPath = `/admin/quest-schedules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} questId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestSchedules: (questId_1, ...args_1) => __awaiter(this, [questId_1, ...args_1], void 0, function* (questId, options = {}) {
            // verify required parameter 'questId' is not null or undefined
            (0, common_1.assertParamExists)('getQuestSchedules', 'questId', questId);
            const localVarPath = `/admin/quest-schedules/{questId}`
                .replace(`{${"questId"}}`, encodeURIComponent(String(questId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {PartialCreateQuestScheduleArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestSchedule: (id_1, body_1, ...args_1) => __awaiter(this, [id_1, body_1, ...args_1], void 0, function* (id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateQuestSchedule', 'id', id);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateQuestSchedule', 'body', body);
            const localVarPath = `/admin/quest-schedules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminQuestScheduleApiAxiosParamCreator = AdminQuestScheduleApiAxiosParamCreator;
/**
 * AdminQuestScheduleApi - functional programming interface
 * @export
 */
const AdminQuestScheduleApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminQuestScheduleApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {CreateQuestScheduleArgs} createQuestScheduleArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestSchedule(createQuestScheduleArgs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createQuestSchedule(createQuestScheduleArgs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminQuestScheduleApi.createQuestSchedule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestSchedule(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteQuestSchedule(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminQuestScheduleApi.deleteQuestSchedule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} questId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestSchedules(questId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getQuestSchedules(questId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminQuestScheduleApi.getQuestSchedules']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {PartialCreateQuestScheduleArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestSchedule(id, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateQuestSchedule(id, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminQuestScheduleApi.updateQuestSchedule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminQuestScheduleApiFp = AdminQuestScheduleApiFp;
/**
 * AdminQuestScheduleApi - factory interface
 * @export
 */
const AdminQuestScheduleApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminQuestScheduleApiFp)(configuration);
    return {
        /**
         *
         * @param {CreateQuestScheduleArgs} createQuestScheduleArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestSchedule(createQuestScheduleArgs, options) {
            return localVarFp.createQuestSchedule(createQuestScheduleArgs, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestSchedule(id, options) {
            return localVarFp.deleteQuestSchedule(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} questId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestSchedules(questId, options) {
            return localVarFp.getQuestSchedules(questId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {PartialCreateQuestScheduleArgs} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestSchedule(id, body, options) {
            return localVarFp.updateQuestSchedule(id, body, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminQuestScheduleApiFactory = AdminQuestScheduleApiFactory;
/**
 * AdminQuestScheduleApi - object-oriented interface
 * @export
 * @class AdminQuestScheduleApi
 * @extends {BaseAPI}
 */
class AdminQuestScheduleApi extends base_1.BaseAPI {
    /**
     *
     * @param {CreateQuestScheduleArgs} createQuestScheduleArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestScheduleApi
     */
    createQuestSchedule(createQuestScheduleArgs, options) {
        return (0, exports.AdminQuestScheduleApiFp)(this.configuration).createQuestSchedule(createQuestScheduleArgs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestScheduleApi
     */
    deleteQuestSchedule(id, options) {
        return (0, exports.AdminQuestScheduleApiFp)(this.configuration).deleteQuestSchedule(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} questId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestScheduleApi
     */
    getQuestSchedules(questId, options) {
        return (0, exports.AdminQuestScheduleApiFp)(this.configuration).getQuestSchedules(questId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {PartialCreateQuestScheduleArgs} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminQuestScheduleApi
     */
    updateQuestSchedule(id, body, options) {
        return (0, exports.AdminQuestScheduleApiFp)(this.configuration).updateQuestSchedule(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminQuestScheduleApi = AdminQuestScheduleApi;
/**
 * AdminRaffleResultsApi - axios parameter creator
 * @export
 */
const AdminRaffleResultsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Retrieve the raffle winners by draw schedule id
         * @param {string} drawScheduleId unique id per draw schedule (e.g \&quot;ledge-fortnite-event-draw-schedule\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaffleWinnersByDrawScheduleId: (drawScheduleId_1, ...args_1) => __awaiter(this, [drawScheduleId_1, ...args_1], void 0, function* (drawScheduleId, options = {}) {
            // verify required parameter 'drawScheduleId' is not null or undefined
            (0, common_1.assertParamExists)('getRaffleWinnersByDrawScheduleId', 'drawScheduleId', drawScheduleId);
            const localVarPath = `/admin/raffle-results/winners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (drawScheduleId !== undefined) {
                localVarQueryParameter['drawScheduleId'] = drawScheduleId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminRaffleResultsApiAxiosParamCreator = AdminRaffleResultsApiAxiosParamCreator;
/**
 * AdminRaffleResultsApi - functional programming interface
 * @export
 */
const AdminRaffleResultsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminRaffleResultsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve the raffle winners by draw schedule id
         * @param {string} drawScheduleId unique id per draw schedule (e.g \&quot;ledge-fortnite-event-draw-schedule\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaffleWinnersByDrawScheduleId(drawScheduleId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRaffleWinnersByDrawScheduleId(drawScheduleId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminRaffleResultsApi.getRaffleWinnersByDrawScheduleId']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminRaffleResultsApiFp = AdminRaffleResultsApiFp;
/**
 * AdminRaffleResultsApi - factory interface
 * @export
 */
const AdminRaffleResultsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminRaffleResultsApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve the raffle winners by draw schedule id
         * @param {string} drawScheduleId unique id per draw schedule (e.g \&quot;ledge-fortnite-event-draw-schedule\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaffleWinnersByDrawScheduleId(drawScheduleId, options) {
            return localVarFp.getRaffleWinnersByDrawScheduleId(drawScheduleId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminRaffleResultsApiFactory = AdminRaffleResultsApiFactory;
/**
 * AdminRaffleResultsApi - object-oriented interface
 * @export
 * @class AdminRaffleResultsApi
 * @extends {BaseAPI}
 */
class AdminRaffleResultsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Retrieve the raffle winners by draw schedule id
     * @param {string} drawScheduleId unique id per draw schedule (e.g \&quot;ledge-fortnite-event-draw-schedule\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRaffleResultsApi
     */
    getRaffleWinnersByDrawScheduleId(drawScheduleId, options) {
        return (0, exports.AdminRaffleResultsApiFp)(this.configuration).getRaffleWinnersByDrawScheduleId(drawScheduleId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminRaffleResultsApi = AdminRaffleResultsApi;
/**
 * AdminUserRoleApi - axios parameter creator
 * @export
 */
const AdminUserRoleApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new user role for a given user id. User\'s can have multiple roles.
         * @param {string} email
         * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserRole: (email_1, body_1, ...args_1) => __awaiter(this, [email_1, body_1, ...args_1], void 0, function* (email, body, options = {}) {
            // verify required parameter 'email' is not null or undefined
            (0, common_1.assertParamExists)('createUserRole', 'email', email);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createUserRole', 'body', body);
            const localVarPath = `/admin/user-roles/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRole: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteUserRole', 'id', id);
            const localVarPath = `/admin/user-roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {Array<UserRoleType>} [roles]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles: (roles_1, ...args_1) => __awaiter(this, [roles_1, ...args_1], void 0, function* (roles, options = {}) {
            const localVarPath = `/admin/user-roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a user\'s role type
         * @param {string} id - id of the user role to update
         * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRole: (id_1, body_1, ...args_1) => __awaiter(this, [id_1, body_1, ...args_1], void 0, function* (id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateUserRole', 'id', id);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateUserRole', 'body', body);
            const localVarPath = `/admin/user-roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminUserRoleApiAxiosParamCreator = AdminUserRoleApiAxiosParamCreator;
/**
 * AdminUserRoleApi - functional programming interface
 * @export
 */
const AdminUserRoleApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminUserRoleApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a new user role for a given user id. User\'s can have multiple roles.
         * @param {string} email
         * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserRole(email, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createUserRole(email, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminUserRoleApi.createUserRole']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRole(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserRole(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminUserRoleApi.deleteUserRole']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {Array<UserRoleType>} [roles]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(roles, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserRoles(roles, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminUserRoleApi.getUserRoles']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update a user\'s role type
         * @param {string} id - id of the user role to update
         * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRole(id, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserRole(id, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AdminUserRoleApi.updateUserRole']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AdminUserRoleApiFp = AdminUserRoleApiFp;
/**
 * AdminUserRoleApi - factory interface
 * @export
 */
const AdminUserRoleApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminUserRoleApiFp)(configuration);
    return {
        /**
         * Create a new user role for a given user id. User\'s can have multiple roles.
         * @param {string} email
         * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserRole(email, body, options) {
            return localVarFp.createUserRole(email, body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRole(id, options) {
            return localVarFp.deleteUserRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Array<UserRoleType>} [roles]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(roles, options) {
            return localVarFp.getUserRoles(roles, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user\'s role type
         * @param {string} id - id of the user role to update
         * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to update to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRole(id, body, options) {
            return localVarFp.updateUserRole(id, body, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminUserRoleApiFactory = AdminUserRoleApiFactory;
/**
 * AdminUserRoleApi - object-oriented interface
 * @export
 * @class AdminUserRoleApi
 * @extends {BaseAPI}
 */
class AdminUserRoleApi extends base_1.BaseAPI {
    /**
     * Create a new user role for a given user id. User\'s can have multiple roles.
     * @param {string} email
     * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserRoleApi
     */
    createUserRole(email, body, options) {
        return (0, exports.AdminUserRoleApiFp)(this.configuration).createUserRole(email, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserRoleApi
     */
    deleteUserRole(id, options) {
        return (0, exports.AdminUserRoleApiFp)(this.configuration).deleteUserRole(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {Array<UserRoleType>} [roles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserRoleApi
     */
    getUserRoles(roles, options) {
        return (0, exports.AdminUserRoleApiFp)(this.configuration).getUserRoles(roles, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a user\'s role type
     * @param {string} id - id of the user role to update
     * @param {PickPrismaUserRoleNewUncheckedCreateInputRole} body - includes the role type to update to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUserRoleApi
     */
    updateUserRole(id, body, options) {
        return (0, exports.AdminUserRoleApiFp)(this.configuration).updateUserRole(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminUserRoleApi = AdminUserRoleApi;
/**
 * AuthApi - axios parameter creator
 * @export
 */
const AuthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Call on redis service to store access token to enable social client app (e.g discord bot) to use it in subsequent API requests.
         * @param {ConnectionType} applicationType
         * @param {string} socialUserId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppToken: (applicationType_1, socialUserId_1, ...args_1) => __awaiter(this, [applicationType_1, socialUserId_1, ...args_1], void 0, function* (applicationType, socialUserId, options = {}) {
            // verify required parameter 'applicationType' is not null or undefined
            (0, common_1.assertParamExists)('createAppToken', 'applicationType', applicationType);
            // verify required parameter 'socialUserId' is not null or undefined
            (0, common_1.assertParamExists)('createAppToken', 'socialUserId', socialUserId);
            const localVarPath = `/auth/token/{applicationType}/{socialUserId}`
                .replace(`{${"applicationType"}}`, encodeURIComponent(String(applicationType)))
                .replace(`{${"socialUserId"}}`, encodeURIComponent(String(socialUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Not currently in use. Use case: - Game Studio Devs can call this API from Ledge App to create their own API key and access our external API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basic required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AuthApiAxiosParamCreator = AuthApiAxiosParamCreator;
/**
 * AuthApi - functional programming interface
 * @export
 */
const AuthApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AuthApiAxiosParamCreator)(configuration);
    return {
        /**
         * Call on redis service to store access token to enable social client app (e.g discord bot) to use it in subsequent API requests.
         * @param {ConnectionType} applicationType
         * @param {string} socialUserId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppToken(applicationType, socialUserId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createAppToken(applicationType, socialUserId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AuthApi.createAppToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Not currently in use. Use case: - Game Studio Devs can call this API from Ledge App to create their own API key and access our external API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getToken(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['AuthApi.getToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.AuthApiFp = AuthApiFp;
/**
 * AuthApi - factory interface
 * @export
 */
const AuthApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AuthApiFp)(configuration);
    return {
        /**
         * Call on redis service to store access token to enable social client app (e.g discord bot) to use it in subsequent API requests.
         * @param {ConnectionType} applicationType
         * @param {string} socialUserId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAppToken(applicationType, socialUserId, options) {
            return localVarFp.createAppToken(applicationType, socialUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Not currently in use. Use case: - Game Studio Devs can call this API from Ledge App to create their own API key and access our external API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(options) {
            return localVarFp.getToken(options).then((request) => request(axios, basePath));
        },
    };
};
exports.AuthApiFactory = AuthApiFactory;
/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
class AuthApi extends base_1.BaseAPI {
    /**
     * Call on redis service to store access token to enable social client app (e.g discord bot) to use it in subsequent API requests.
     * @param {ConnectionType} applicationType
     * @param {string} socialUserId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    createAppToken(applicationType, socialUserId, options) {
        return (0, exports.AuthApiFp)(this.configuration).createAppToken(applicationType, socialUserId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Not currently in use. Use case: - Game Studio Devs can call this API from Ledge App to create their own API key and access our external API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    getToken(options) {
        return (0, exports.AuthApiFp)(this.configuration).getToken(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AuthApi = AuthApi;
/**
 * BannersApi - axios parameter creator
 * @export
 */
const BannersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {BannerLocation} bannerLocation
         * @param {string} [eventId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanners: (bannerLocation_1, eventId_1, ...args_1) => __awaiter(this, [bannerLocation_1, eventId_1, ...args_1], void 0, function* (bannerLocation, eventId, options = {}) {
            // verify required parameter 'bannerLocation' is not null or undefined
            (0, common_1.assertParamExists)('getBanners', 'bannerLocation', bannerLocation);
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (bannerLocation !== undefined) {
                localVarQueryParameter['bannerLocation'] = bannerLocation;
            }
            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BannersApiAxiosParamCreator = BannersApiAxiosParamCreator;
/**
 * BannersApi - functional programming interface
 * @export
 */
const BannersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BannersApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {BannerLocation} bannerLocation
         * @param {string} [eventId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanners(bannerLocation, eventId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBanners(bannerLocation, eventId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BannersApi.getBanners']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.BannersApiFp = BannersApiFp;
/**
 * BannersApi - factory interface
 * @export
 */
const BannersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BannersApiFp)(configuration);
    return {
        /**
         *
         * @param {BannerLocation} bannerLocation
         * @param {string} [eventId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanners(bannerLocation, eventId, options) {
            return localVarFp.getBanners(bannerLocation, eventId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.BannersApiFactory = BannersApiFactory;
/**
 * BannersApi - object-oriented interface
 * @export
 * @class BannersApi
 * @extends {BaseAPI}
 */
class BannersApi extends base_1.BaseAPI {
    /**
     *
     * @param {BannerLocation} bannerLocation
     * @param {string} [eventId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannersApi
     */
    getBanners(bannerLocation, eventId, options) {
        return (0, exports.BannersApiFp)(this.configuration).getBanners(bannerLocation, eventId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BannersApi = BannersApi;
/**
 * DrawApi - axios parameter creator
 * @export
 */
const DrawApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} gameId
         * @param {string} drawScheduleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimReward: (gameId_1, drawScheduleId_1, ...args_1) => __awaiter(this, [gameId_1, drawScheduleId_1, ...args_1], void 0, function* (gameId, drawScheduleId, options = {}) {
            // verify required parameter 'gameId' is not null or undefined
            (0, common_1.assertParamExists)('claimReward', 'gameId', gameId);
            // verify required parameter 'drawScheduleId' is not null or undefined
            (0, common_1.assertParamExists)('claimReward', 'drawScheduleId', drawScheduleId);
            const localVarPath = `/draw/claim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (gameId !== undefined) {
                localVarQueryParameter['gameId'] = gameId;
            }
            if (drawScheduleId !== undefined) {
                localVarQueryParameter['drawScheduleId'] = drawScheduleId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextActiveDrawSchedule: (eventId_1, ...args_1) => __awaiter(this, [eventId_1, ...args_1], void 0, function* (eventId, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('getNextActiveDrawSchedule', 'eventId', eventId);
            const localVarPath = `/draw/drawSchedule/active/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousDrawSchedules: (objectId_1, ...args_1) => __awaiter(this, [objectId_1, ...args_1], void 0, function* (objectId, options = {}) {
            // verify required parameter 'objectId' is not null or undefined
            (0, common_1.assertParamExists)('getPreviousDrawSchedules', 'objectId', objectId);
            const localVarPath = `/draw/drawSchedule/previous/{objectId}`
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Since a raffle result (UserDraw) claimable period expires in n days after an event ends, before fetching the raffle result, we need to check and update the UserDraw status accordingly.
         * @param {string} gameId
         * @param {string} drawScheduleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaffleResult: (gameId_1, drawScheduleId_1, ...args_1) => __awaiter(this, [gameId_1, drawScheduleId_1, ...args_1], void 0, function* (gameId, drawScheduleId, options = {}) {
            // verify required parameter 'gameId' is not null or undefined
            (0, common_1.assertParamExists)('getRaffleResult', 'gameId', gameId);
            // verify required parameter 'drawScheduleId' is not null or undefined
            (0, common_1.assertParamExists)('getRaffleResult', 'drawScheduleId', drawScheduleId);
            const localVarPath = `/draw/raffle-result/{gameId}/{drawScheduleId}`
                .replace(`{${"gameId"}}`, encodeURIComponent(String(gameId)))
                .replace(`{${"drawScheduleId"}}`, encodeURIComponent(String(drawScheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProcessedDrawSchedule: (eventId_1, ...args_1) => __awaiter(this, [eventId_1, ...args_1], void 0, function* (eventId, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('getRecentProcessedDrawSchedule', 'eventId', eventId);
            const localVarPath = `/draw/recent-draw-schedule/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.DrawApiAxiosParamCreator = DrawApiAxiosParamCreator;
/**
 * DrawApi - functional programming interface
 * @export
 */
const DrawApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DrawApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {string} gameId
         * @param {string} drawScheduleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimReward(gameId, drawScheduleId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.claimReward(gameId, drawScheduleId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DrawApi.claimReward']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextActiveDrawSchedule(eventId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getNextActiveDrawSchedule(eventId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DrawApi.getNextActiveDrawSchedule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousDrawSchedules(objectId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPreviousDrawSchedules(objectId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DrawApi.getPreviousDrawSchedules']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Since a raffle result (UserDraw) claimable period expires in n days after an event ends, before fetching the raffle result, we need to check and update the UserDraw status accordingly.
         * @param {string} gameId
         * @param {string} drawScheduleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaffleResult(gameId, drawScheduleId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRaffleResult(gameId, drawScheduleId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DrawApi.getRaffleResult']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProcessedDrawSchedule(eventId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRecentProcessedDrawSchedule(eventId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DrawApi.getRecentProcessedDrawSchedule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.DrawApiFp = DrawApiFp;
/**
 * DrawApi - factory interface
 * @export
 */
const DrawApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DrawApiFp)(configuration);
    return {
        /**
         *
         * @param {string} gameId
         * @param {string} drawScheduleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimReward(gameId, drawScheduleId, options) {
            return localVarFp.claimReward(gameId, drawScheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextActiveDrawSchedule(eventId, options) {
            return localVarFp.getNextActiveDrawSchedule(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreviousDrawSchedules(objectId, options) {
            return localVarFp.getPreviousDrawSchedules(objectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Since a raffle result (UserDraw) claimable period expires in n days after an event ends, before fetching the raffle result, we need to check and update the UserDraw status accordingly.
         * @param {string} gameId
         * @param {string} drawScheduleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaffleResult(gameId, drawScheduleId, options) {
            return localVarFp.getRaffleResult(gameId, drawScheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProcessedDrawSchedule(eventId, options) {
            return localVarFp.getRecentProcessedDrawSchedule(eventId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.DrawApiFactory = DrawApiFactory;
/**
 * DrawApi - object-oriented interface
 * @export
 * @class DrawApi
 * @extends {BaseAPI}
 */
class DrawApi extends base_1.BaseAPI {
    /**
     *
     * @param {string} gameId
     * @param {string} drawScheduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrawApi
     */
    claimReward(gameId, drawScheduleId, options) {
        return (0, exports.DrawApiFp)(this.configuration).claimReward(gameId, drawScheduleId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrawApi
     */
    getNextActiveDrawSchedule(eventId, options) {
        return (0, exports.DrawApiFp)(this.configuration).getNextActiveDrawSchedule(eventId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} objectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrawApi
     */
    getPreviousDrawSchedules(objectId, options) {
        return (0, exports.DrawApiFp)(this.configuration).getPreviousDrawSchedules(objectId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Since a raffle result (UserDraw) claimable period expires in n days after an event ends, before fetching the raffle result, we need to check and update the UserDraw status accordingly.
     * @param {string} gameId
     * @param {string} drawScheduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrawApi
     */
    getRaffleResult(gameId, drawScheduleId, options) {
        return (0, exports.DrawApiFp)(this.configuration).getRaffleResult(gameId, drawScheduleId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DrawApi
     */
    getRecentProcessedDrawSchedule(eventId, options) {
        return (0, exports.DrawApiFp)(this.configuration).getRecentProcessedDrawSchedule(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DrawApi = DrawApi;
/**
 * EventsApi - axios parameter creator
 * @export
 */
const EventsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Generates a specified number of leaderboard win codes for the given game. Requires `write:game-code` permission.
         * @param {GenerateLeaderboardWinCodesRequest} generateLeaderboardWinCodesRequest numOfCodes: the number of codes to generate, eventId: the id of the event to generate codes for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLeaderboardWinCodes: (generateLeaderboardWinCodesRequest_1, ...args_1) => __awaiter(this, [generateLeaderboardWinCodesRequest_1, ...args_1], void 0, function* (generateLeaderboardWinCodesRequest, options = {}) {
            // verify required parameter 'generateLeaderboardWinCodesRequest' is not null or undefined
            (0, common_1.assertParamExists)('generateLeaderboardWinCodes', 'generateLeaderboardWinCodesRequest', generateLeaderboardWinCodesRequest);
            const localVarPath = `/events/generate-lb-win-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication tsoa_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "tsoa_auth", ["write:game-code"], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(generateLeaderboardWinCodesRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all events sorted and filtered by status and end time. See repository for more details. Also map event details to include lobby details.
         * @param {Array<EventStatus>} includeStatuses
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvents: (includeStatuses_1, page_1, limit_1, ...args_1) => __awaiter(this, [includeStatuses_1, page_1, limit_1, ...args_1], void 0, function* (includeStatuses, page, limit, options = {}) {
            // verify required parameter 'includeStatuses' is not null or undefined
            (0, common_1.assertParamExists)('getAllEvents', 'includeStatuses', includeStatuses);
            const localVarPath = `/events/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (includeStatuses) {
                localVarQueryParameter['includeStatuses'] = includeStatuses;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: (eventId_1, ...args_1) => __awaiter(this, [eventId_1, ...args_1], void 0, function* (eventId, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('getEvent', 'eventId', eventId);
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEvent: (gameId_1, ...args_1) => __awaiter(this, [gameId_1, ...args_1], void 0, function* (gameId, options = {}) {
            // verify required parameter 'gameId' is not null or undefined
            (0, common_1.assertParamExists)('getLatestEvent', 'gameId', gameId);
            const localVarPath = `/events/latest/{gameId}`
                .replace(`{${"gameId"}}`, encodeURIComponent(String(gameId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the joined status and timestamp of a user for a specific event.
         * @param {string} eventId The ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserJoinedStatus: (eventId_1, ...args_1) => __awaiter(this, [eventId_1, ...args_1], void 0, function* (eventId, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('getUserJoinedStatus', 'eventId', eventId);
            const localVarPath = `/events/join/{eventId}/status`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Join an event with the specified eventId, userId, and timestamp.
         * @param {string} eventId The ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinEvent: (eventId_1, ...args_1) => __awaiter(this, [eventId_1, ...args_1], void 0, function* (eventId, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('joinEvent', 'eventId', eventId);
            const localVarPath = `/events/join/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.EventsApiAxiosParamCreator = EventsApiAxiosParamCreator;
/**
 * EventsApi - functional programming interface
 * @export
 */
const EventsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.EventsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Generates a specified number of leaderboard win codes for the given game. Requires `write:game-code` permission.
         * @param {GenerateLeaderboardWinCodesRequest} generateLeaderboardWinCodesRequest numOfCodes: the number of codes to generate, eventId: the id of the event to generate codes for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLeaderboardWinCodes(generateLeaderboardWinCodesRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.generateLeaderboardWinCodes(generateLeaderboardWinCodesRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.generateLeaderboardWinCodes']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all events sorted and filtered by status and end time. See repository for more details. Also map event details to include lobby details.
         * @param {Array<EventStatus>} includeStatuses
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvents(includeStatuses, page, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllEvents(includeStatuses, page, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.getAllEvents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(eventId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEvent(eventId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.getEvent']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEvent(gameId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLatestEvent(gameId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.getLatestEvent']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get the joined status and timestamp of a user for a specific event.
         * @param {string} eventId The ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserJoinedStatus(eventId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserJoinedStatus(eventId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.getUserJoinedStatus']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Join an event with the specified eventId, userId, and timestamp.
         * @param {string} eventId The ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinEvent(eventId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.joinEvent(eventId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EventsApi.joinEvent']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.EventsApiFp = EventsApiFp;
/**
 * EventsApi - factory interface
 * @export
 */
const EventsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.EventsApiFp)(configuration);
    return {
        /**
         * Generates a specified number of leaderboard win codes for the given game. Requires `write:game-code` permission.
         * @param {GenerateLeaderboardWinCodesRequest} generateLeaderboardWinCodesRequest numOfCodes: the number of codes to generate, eventId: the id of the event to generate codes for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLeaderboardWinCodes(generateLeaderboardWinCodesRequest, options) {
            return localVarFp.generateLeaderboardWinCodes(generateLeaderboardWinCodesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all events sorted and filtered by status and end time. See repository for more details. Also map event details to include lobby details.
         * @param {Array<EventStatus>} includeStatuses
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEvents(includeStatuses, page, limit, options) {
            return localVarFp.getAllEvents(includeStatuses, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(eventId, options) {
            return localVarFp.getEvent(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEvent(gameId, options) {
            return localVarFp.getLatestEvent(gameId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the joined status and timestamp of a user for a specific event.
         * @param {string} eventId The ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserJoinedStatus(eventId, options) {
            return localVarFp.getUserJoinedStatus(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Join an event with the specified eventId, userId, and timestamp.
         * @param {string} eventId The ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinEvent(eventId, options) {
            return localVarFp.joinEvent(eventId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.EventsApiFactory = EventsApiFactory;
/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
class EventsApi extends base_1.BaseAPI {
    /**
     * Generates a specified number of leaderboard win codes for the given game. Requires `write:game-code` permission.
     * @param {GenerateLeaderboardWinCodesRequest} generateLeaderboardWinCodesRequest numOfCodes: the number of codes to generate, eventId: the id of the event to generate codes for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    generateLeaderboardWinCodes(generateLeaderboardWinCodesRequest, options) {
        return (0, exports.EventsApiFp)(this.configuration).generateLeaderboardWinCodes(generateLeaderboardWinCodesRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all events sorted and filtered by status and end time. See repository for more details. Also map event details to include lobby details.
     * @param {Array<EventStatus>} includeStatuses
     * @param {number} [page]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getAllEvents(includeStatuses, page, limit, options) {
        return (0, exports.EventsApiFp)(this.configuration).getAllEvents(includeStatuses, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getEvent(eventId, options) {
        return (0, exports.EventsApiFp)(this.configuration).getEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} gameId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getLatestEvent(gameId, options) {
        return (0, exports.EventsApiFp)(this.configuration).getLatestEvent(gameId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the joined status and timestamp of a user for a specific event.
     * @param {string} eventId The ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    getUserJoinedStatus(eventId, options) {
        return (0, exports.EventsApiFp)(this.configuration).getUserJoinedStatus(eventId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Join an event with the specified eventId, userId, and timestamp.
     * @param {string} eventId The ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    joinEvent(eventId, options) {
        return (0, exports.EventsApiFp)(this.configuration).joinEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.EventsApi = EventsApi;
/**
 * EventsNewApi - axios parameter creator
 * @export
 */
const EventsNewApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Array<EventStatus>} [statuses]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserEvents: (statuses_1, ...args_1) => __awaiter(this, [statuses_1, ...args_1], void 0, function* (statuses, options = {}) {
            const localVarPath = `/events-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Requires `creator` role.
         * @param {SaveEventDetailsArgs} saveEventDetailsArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEvent: (saveEventDetailsArgs_1, ...args_1) => __awaiter(this, [saveEventDetailsArgs_1, ...args_1], void 0, function* (saveEventDetailsArgs, options = {}) {
            // verify required parameter 'saveEventDetailsArgs' is not null or undefined
            (0, common_1.assertParamExists)('saveEvent', 'saveEventDetailsArgs', saveEventDetailsArgs);
            const localVarPath = `/events-new/save`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(saveEventDetailsArgs, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Uploads an image to S3 and updates the event\'s thumbnail URL in the database.
         * @param {string} eventId event id
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadThumbnail: (eventId_1, file_1, replaceUrl_1, ...args_1) => __awaiter(this, [eventId_1, file_1, replaceUrl_1, ...args_1], void 0, function* (eventId, file, replaceUrl, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('uploadThumbnail', 'eventId', eventId);
            // verify required parameter 'file' is not null or undefined
            (0, common_1.assertParamExists)('uploadThumbnail', 'file', file);
            const localVarPath = `/events-new/{eventId}/thumbnail`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            if (replaceUrl !== undefined) {
                localVarFormParams.append('replaceUrl', replaceUrl);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.EventsNewApiAxiosParamCreator = EventsNewApiAxiosParamCreator;
/**
 * EventsNewApi - functional programming interface
 * @export
 */
const EventsNewApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.EventsNewApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {Array<EventStatus>} [statuses]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserEvents(statuses, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listUserEvents(statuses, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EventsNewApi.listUserEvents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Requires `creator` role.
         * @param {SaveEventDetailsArgs} saveEventDetailsArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEvent(saveEventDetailsArgs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.saveEvent(saveEventDetailsArgs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EventsNewApi.saveEvent']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Uploads an image to S3 and updates the event\'s thumbnail URL in the database.
         * @param {string} eventId event id
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadThumbnail(eventId, file, replaceUrl, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadThumbnail(eventId, file, replaceUrl, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['EventsNewApi.uploadThumbnail']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.EventsNewApiFp = EventsNewApiFp;
/**
 * EventsNewApi - factory interface
 * @export
 */
const EventsNewApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.EventsNewApiFp)(configuration);
    return {
        /**
         *
         * @param {Array<EventStatus>} [statuses]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserEvents(statuses, options) {
            return localVarFp.listUserEvents(statuses, options).then((request) => request(axios, basePath));
        },
        /**
         * Requires `creator` role.
         * @param {SaveEventDetailsArgs} saveEventDetailsArgs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEvent(saveEventDetailsArgs, options) {
            return localVarFp.saveEvent(saveEventDetailsArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads an image to S3 and updates the event\'s thumbnail URL in the database.
         * @param {string} eventId event id
         * @param {File} file image to upload to S3
         * @param {string} [replaceUrl] optional url to replace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadThumbnail(eventId, file, replaceUrl, options) {
            return localVarFp.uploadThumbnail(eventId, file, replaceUrl, options).then((request) => request(axios, basePath));
        },
    };
};
exports.EventsNewApiFactory = EventsNewApiFactory;
/**
 * EventsNewApi - object-oriented interface
 * @export
 * @class EventsNewApi
 * @extends {BaseAPI}
 */
class EventsNewApi extends base_1.BaseAPI {
    /**
     *
     * @param {Array<EventStatus>} [statuses]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsNewApi
     */
    listUserEvents(statuses, options) {
        return (0, exports.EventsNewApiFp)(this.configuration).listUserEvents(statuses, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Requires `creator` role.
     * @param {SaveEventDetailsArgs} saveEventDetailsArgs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsNewApi
     */
    saveEvent(saveEventDetailsArgs, options) {
        return (0, exports.EventsNewApiFp)(this.configuration).saveEvent(saveEventDetailsArgs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Uploads an image to S3 and updates the event\'s thumbnail URL in the database.
     * @param {string} eventId event id
     * @param {File} file image to upload to S3
     * @param {string} [replaceUrl] optional url to replace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsNewApi
     */
    uploadThumbnail(eventId, file, replaceUrl, options) {
        return (0, exports.EventsNewApiFp)(this.configuration).uploadThumbnail(eventId, file, replaceUrl, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.EventsNewApi = EventsNewApi;
/**
 * GameCodeApi - axios parameter creator
 * @export
 */
const GameCodeApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {ProcessGameCodeRequest} processGameCodeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processGameCode: (processGameCodeRequest_1, ...args_1) => __awaiter(this, [processGameCodeRequest_1, ...args_1], void 0, function* (processGameCodeRequest, options = {}) {
            // verify required parameter 'processGameCodeRequest' is not null or undefined
            (0, common_1.assertParamExists)('processGameCode', 'processGameCodeRequest', processGameCodeRequest);
            const localVarPath = `/gameCode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(processGameCodeRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} linkingCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLinkingCode: (linkingCode_1, ...args_1) => __awaiter(this, [linkingCode_1, ...args_1], void 0, function* (linkingCode, options = {}) {
            // verify required parameter 'linkingCode' is not null or undefined
            (0, common_1.assertParamExists)('validateLinkingCode', 'linkingCode', linkingCode);
            const localVarPath = `/gameCode/validate-linking-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (linkingCode !== undefined) {
                localVarQueryParameter['linkingCode'] = linkingCode;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.GameCodeApiAxiosParamCreator = GameCodeApiAxiosParamCreator;
/**
 * GameCodeApi - functional programming interface
 * @export
 */
const GameCodeApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.GameCodeApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {ProcessGameCodeRequest} processGameCodeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processGameCode(processGameCodeRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.processGameCode(processGameCodeRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['GameCodeApi.processGameCode']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} linkingCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLinkingCode(linkingCode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.validateLinkingCode(linkingCode, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['GameCodeApi.validateLinkingCode']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.GameCodeApiFp = GameCodeApiFp;
/**
 * GameCodeApi - factory interface
 * @export
 */
const GameCodeApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.GameCodeApiFp)(configuration);
    return {
        /**
         *
         * @param {ProcessGameCodeRequest} processGameCodeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processGameCode(processGameCodeRequest, options) {
            return localVarFp.processGameCode(processGameCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} linkingCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLinkingCode(linkingCode, options) {
            return localVarFp.validateLinkingCode(linkingCode, options).then((request) => request(axios, basePath));
        },
    };
};
exports.GameCodeApiFactory = GameCodeApiFactory;
/**
 * GameCodeApi - object-oriented interface
 * @export
 * @class GameCodeApi
 * @extends {BaseAPI}
 */
class GameCodeApi extends base_1.BaseAPI {
    /**
     *
     * @param {ProcessGameCodeRequest} processGameCodeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameCodeApi
     */
    processGameCode(processGameCodeRequest, options) {
        return (0, exports.GameCodeApiFp)(this.configuration).processGameCode(processGameCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} linkingCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameCodeApi
     */
    validateLinkingCode(linkingCode, options) {
        return (0, exports.GameCodeApiFp)(this.configuration).validateLinkingCode(linkingCode, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.GameCodeApi = GameCodeApi;
/**
 * GamesApi - axios parameter creator
 * @export
 */
const GamesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This endpoint returns games in which Ledge users can create events for.
         * @param {number} [page] - The current page index (default is 0).
         * @param {number} [limit] - The number of items per page (default is 10).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventGames: (page_1, limit_1, ...args_1) => __awaiter(this, [page_1, limit_1, ...args_1], void 0, function* (page, limit, options = {}) {
            const localVarPath = `/games/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGame: (eventId_1, ...args_1) => __awaiter(this, [eventId_1, ...args_1], void 0, function* (eventId, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('getGame', 'eventId', eventId);
            const localVarPath = `/games/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.GamesApiAxiosParamCreator = GamesApiAxiosParamCreator;
/**
 * GamesApi - functional programming interface
 * @export
 */
const GamesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.GamesApiAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint returns games in which Ledge users can create events for.
         * @param {number} [page] - The current page index (default is 0).
         * @param {number} [limit] - The number of items per page (default is 10).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventGames(page, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEventGames(page, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['GamesApi.getEventGames']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGame(eventId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGame(eventId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['GamesApi.getGame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.GamesApiFp = GamesApiFp;
/**
 * GamesApi - factory interface
 * @export
 */
const GamesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.GamesApiFp)(configuration);
    return {
        /**
         * This endpoint returns games in which Ledge users can create events for.
         * @param {number} [page] - The current page index (default is 0).
         * @param {number} [limit] - The number of items per page (default is 10).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventGames(page, limit, options) {
            return localVarFp.getEventGames(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGame(eventId, options) {
            return localVarFp.getGame(eventId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.GamesApiFactory = GamesApiFactory;
/**
 * GamesApi - object-oriented interface
 * @export
 * @class GamesApi
 * @extends {BaseAPI}
 */
class GamesApi extends base_1.BaseAPI {
    /**
     * This endpoint returns games in which Ledge users can create events for.
     * @param {number} [page] - The current page index (default is 0).
     * @param {number} [limit] - The number of items per page (default is 10).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamesApi
     */
    getEventGames(page, limit, options) {
        return (0, exports.GamesApiFp)(this.configuration).getEventGames(page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GamesApi
     */
    getGame(eventId, options) {
        return (0, exports.GamesApiFp)(this.configuration).getGame(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.GamesApi = GamesApi;
/**
 * GuestApi - axios parameter creator
 * @export
 */
const GuestApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveAnnouncement: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/guest/active-announcement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.GuestApiAxiosParamCreator = GuestApiAxiosParamCreator;
/**
 * GuestApi - functional programming interface
 * @export
 */
const GuestApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.GuestApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveAnnouncement(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getActiveAnnouncement(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['GuestApi.getActiveAnnouncement']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.GuestApiFp = GuestApiFp;
/**
 * GuestApi - factory interface
 * @export
 */
const GuestApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.GuestApiFp)(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveAnnouncement(options) {
            return localVarFp.getActiveAnnouncement(options).then((request) => request(axios, basePath));
        },
    };
};
exports.GuestApiFactory = GuestApiFactory;
/**
 * GuestApi - object-oriented interface
 * @export
 * @class GuestApi
 * @extends {BaseAPI}
 */
class GuestApi extends base_1.BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    getActiveAnnouncement(options) {
        return (0, exports.GuestApiFp)(this.configuration).getActiveAnnouncement(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.GuestApi = GuestApi;
/**
 * InventoryApi - axios parameter creator
 * @export
 */
const InventoryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Array<ProductType>} productTypes
         * @param {boolean} [isDefault]
         * @param {boolean} [isSeen]
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventory: (productTypes_1, isDefault_1, isSeen_1, userId_1, ...args_1) => __awaiter(this, [productTypes_1, isDefault_1, isSeen_1, userId_1, ...args_1], void 0, function* (productTypes, isDefault, isSeen, userId, options = {}) {
            // verify required parameter 'productTypes' is not null or undefined
            (0, common_1.assertParamExists)('getInventory', 'productTypes', productTypes);
            const localVarPath = `/inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (productTypes) {
                localVarQueryParameter['productTypes'] = productTypes;
            }
            if (isDefault !== undefined) {
                localVarQueryParameter['isDefault'] = isDefault;
            }
            if (isSeen !== undefined) {
                localVarQueryParameter['isSeen'] = isSeen;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This should return current user\'s raffle entires and return total entries for given productId. productId CAN come from Draw table ticketId
         * @param {string} [productId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCount: (productId_1, ...args_1) => __awaiter(this, [productId_1, ...args_1], void 0, function* (productId, options = {}) {
            const localVarPath = `/inventory/item-counts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductIdCount: (productId_1, ...args_1) => __awaiter(this, [productId_1, ...args_1], void 0, function* (productId, options = {}) {
            // verify required parameter 'productId' is not null or undefined
            (0, common_1.assertParamExists)('getProductIdCount', 'productId', productId);
            const localVarPath = `/inventory/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {ProductType} spinType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpinCase: (spinType_1, ...args_1) => __awaiter(this, [spinType_1, ...args_1], void 0, function* (spinType, options = {}) {
            // verify required parameter 'spinType' is not null or undefined
            (0, common_1.assertParamExists)('getSpinCase', 'spinType', spinType);
            const localVarPath = `/inventory/SpinCase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (spinType !== undefined) {
                localVarQueryParameter['spinType'] = spinType;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} inventoryId
         * @param {UserInventory} userInventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventory: (inventoryId_1, userInventory_1, ...args_1) => __awaiter(this, [inventoryId_1, userInventory_1, ...args_1], void 0, function* (inventoryId, userInventory, options = {}) {
            // verify required parameter 'inventoryId' is not null or undefined
            (0, common_1.assertParamExists)('updateInventory', 'inventoryId', inventoryId);
            // verify required parameter 'userInventory' is not null or undefined
            (0, common_1.assertParamExists)('updateInventory', 'userInventory', userInventory);
            const localVarPath = `/inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (inventoryId !== undefined) {
                localVarQueryParameter['inventoryId'] = inventoryId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(userInventory, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {UpdateProfileRequest} updateProfileRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile: (updateProfileRequest_1, ...args_1) => __awaiter(this, [updateProfileRequest_1, ...args_1], void 0, function* (updateProfileRequest, options = {}) {
            // verify required parameter 'updateProfileRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateProfile', 'updateProfileRequest', updateProfileRequest);
            const localVarPath = `/inventory/update-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateProfileRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InventoryApiAxiosParamCreator = InventoryApiAxiosParamCreator;
/**
 * InventoryApi - functional programming interface
 * @export
 */
const InventoryApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.InventoryApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {Array<ProductType>} productTypes
         * @param {boolean} [isDefault]
         * @param {boolean} [isSeen]
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventory(productTypes, isDefault, isSeen, userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInventory(productTypes, isDefault, isSeen, userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InventoryApi.getInventory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * This should return current user\'s raffle entires and return total entries for given productId. productId CAN come from Draw table ticketId
         * @param {string} [productId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCount(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getItemCount(productId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InventoryApi.getItemCount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductIdCount(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProductIdCount(productId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InventoryApi.getProductIdCount']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {ProductType} spinType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpinCase(spinType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSpinCase(spinType, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InventoryApi.getSpinCase']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} inventoryId
         * @param {UserInventory} userInventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventory(inventoryId, userInventory, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateInventory(inventoryId, userInventory, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InventoryApi.updateInventory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {UpdateProfileRequest} updateProfileRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(updateProfileRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateProfile(updateProfileRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InventoryApi.updateProfile']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.InventoryApiFp = InventoryApiFp;
/**
 * InventoryApi - factory interface
 * @export
 */
const InventoryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.InventoryApiFp)(configuration);
    return {
        /**
         *
         * @param {Array<ProductType>} productTypes
         * @param {boolean} [isDefault]
         * @param {boolean} [isSeen]
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventory(productTypes, isDefault, isSeen, userId, options) {
            return localVarFp.getInventory(productTypes, isDefault, isSeen, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * This should return current user\'s raffle entires and return total entries for given productId. productId CAN come from Draw table ticketId
         * @param {string} [productId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCount(productId, options) {
            return localVarFp.getItemCount(productId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductIdCount(productId, options) {
            return localVarFp.getProductIdCount(productId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ProductType} spinType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpinCase(spinType, options) {
            return localVarFp.getSpinCase(spinType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} inventoryId
         * @param {UserInventory} userInventory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventory(inventoryId, userInventory, options) {
            return localVarFp.updateInventory(inventoryId, userInventory, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UpdateProfileRequest} updateProfileRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(updateProfileRequest, options) {
            return localVarFp.updateProfile(updateProfileRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.InventoryApiFactory = InventoryApiFactory;
/**
 * InventoryApi - object-oriented interface
 * @export
 * @class InventoryApi
 * @extends {BaseAPI}
 */
class InventoryApi extends base_1.BaseAPI {
    /**
     *
     * @param {Array<ProductType>} productTypes
     * @param {boolean} [isDefault]
     * @param {boolean} [isSeen]
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    getInventory(productTypes, isDefault, isSeen, userId, options) {
        return (0, exports.InventoryApiFp)(this.configuration).getInventory(productTypes, isDefault, isSeen, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This should return current user\'s raffle entires and return total entries for given productId. productId CAN come from Draw table ticketId
     * @param {string} [productId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    getItemCount(productId, options) {
        return (0, exports.InventoryApiFp)(this.configuration).getItemCount(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    getProductIdCount(productId, options) {
        return (0, exports.InventoryApiFp)(this.configuration).getProductIdCount(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ProductType} spinType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    getSpinCase(spinType, options) {
        return (0, exports.InventoryApiFp)(this.configuration).getSpinCase(spinType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} inventoryId
     * @param {UserInventory} userInventory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    updateInventory(inventoryId, userInventory, options) {
        return (0, exports.InventoryApiFp)(this.configuration).updateInventory(inventoryId, userInventory, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {UpdateProfileRequest} updateProfileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryApi
     */
    updateProfile(updateProfileRequest, options) {
        return (0, exports.InventoryApiFp)(this.configuration).updateProfile(updateProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InventoryApi = InventoryApi;
/**
 * LeaderboardApi - axios parameter creator
 * @export
 */
const LeaderboardApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} leaderboardScheduleId
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardScore: (leaderboardScheduleId_1, gameId_1, ...args_1) => __awaiter(this, [leaderboardScheduleId_1, gameId_1, ...args_1], void 0, function* (leaderboardScheduleId, gameId, options = {}) {
            // verify required parameter 'leaderboardScheduleId' is not null or undefined
            (0, common_1.assertParamExists)('getLeaderboardScore', 'leaderboardScheduleId', leaderboardScheduleId);
            // verify required parameter 'gameId' is not null or undefined
            (0, common_1.assertParamExists)('getLeaderboardScore', 'gameId', gameId);
            const localVarPath = `/leaderboard/scores`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (leaderboardScheduleId !== undefined) {
                localVarQueryParameter['leaderboardScheduleId'] = leaderboardScheduleId;
            }
            if (gameId !== undefined) {
                localVarQueryParameter['gameId'] = gameId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} eventId
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMostRecentLeaderboardSchedules: (eventId_1, page_1, limit_1, ...args_1) => __awaiter(this, [eventId_1, page_1, limit_1, ...args_1], void 0, function* (eventId, page, limit, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('getMostRecentLeaderboardSchedules', 'eventId', eventId);
            const localVarPath = `/leaderboard/recent-schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.LeaderboardApiAxiosParamCreator = LeaderboardApiAxiosParamCreator;
/**
 * LeaderboardApi - functional programming interface
 * @export
 */
const LeaderboardApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.LeaderboardApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {string} leaderboardScheduleId
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardScore(leaderboardScheduleId, gameId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLeaderboardScore(leaderboardScheduleId, gameId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LeaderboardApi.getLeaderboardScore']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} eventId
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMostRecentLeaderboardSchedules(eventId, page, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMostRecentLeaderboardSchedules(eventId, page, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LeaderboardApi.getMostRecentLeaderboardSchedules']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.LeaderboardApiFp = LeaderboardApiFp;
/**
 * LeaderboardApi - factory interface
 * @export
 */
const LeaderboardApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.LeaderboardApiFp)(configuration);
    return {
        /**
         *
         * @param {string} leaderboardScheduleId
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardScore(leaderboardScheduleId, gameId, options) {
            return localVarFp.getLeaderboardScore(leaderboardScheduleId, gameId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} eventId
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMostRecentLeaderboardSchedules(eventId, page, limit, options) {
            return localVarFp.getMostRecentLeaderboardSchedules(eventId, page, limit, options).then((request) => request(axios, basePath));
        },
    };
};
exports.LeaderboardApiFactory = LeaderboardApiFactory;
/**
 * LeaderboardApi - object-oriented interface
 * @export
 * @class LeaderboardApi
 * @extends {BaseAPI}
 */
class LeaderboardApi extends base_1.BaseAPI {
    /**
     *
     * @param {string} leaderboardScheduleId
     * @param {string} gameId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    getLeaderboardScore(leaderboardScheduleId, gameId, options) {
        return (0, exports.LeaderboardApiFp)(this.configuration).getLeaderboardScore(leaderboardScheduleId, gameId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} eventId
     * @param {number} [page]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    getMostRecentLeaderboardSchedules(eventId, page, limit, options) {
        return (0, exports.LeaderboardApiFp)(this.configuration).getMostRecentLeaderboardSchedules(eventId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.LeaderboardApi = LeaderboardApi;
/**
 * LeaderboardResultApi - axios parameter creator
 * @export
 */
const LeaderboardResultApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get leaderboard results for a given event
         * @param {string} eventId The ID of the event to get leaderboard results for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardResults: (eventId_1, ...args_1) => __awaiter(this, [eventId_1, ...args_1], void 0, function* (eventId, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('getLeaderboardResults', 'eventId', eventId);
            const localVarPath = `/leaderboard-results`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.LeaderboardResultApiAxiosParamCreator = LeaderboardResultApiAxiosParamCreator;
/**
 * LeaderboardResultApi - functional programming interface
 * @export
 */
const LeaderboardResultApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.LeaderboardResultApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Get leaderboard results for a given event
         * @param {string} eventId The ID of the event to get leaderboard results for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardResults(eventId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLeaderboardResults(eventId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['LeaderboardResultApi.getLeaderboardResults']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.LeaderboardResultApiFp = LeaderboardResultApiFp;
/**
 * LeaderboardResultApi - factory interface
 * @export
 */
const LeaderboardResultApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.LeaderboardResultApiFp)(configuration);
    return {
        /**
         *
         * @summary Get leaderboard results for a given event
         * @param {string} eventId The ID of the event to get leaderboard results for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboardResults(eventId, options) {
            return localVarFp.getLeaderboardResults(eventId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.LeaderboardResultApiFactory = LeaderboardResultApiFactory;
/**
 * LeaderboardResultApi - object-oriented interface
 * @export
 * @class LeaderboardResultApi
 * @extends {BaseAPI}
 */
class LeaderboardResultApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get leaderboard results for a given event
     * @param {string} eventId The ID of the event to get leaderboard results for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardResultApi
     */
    getLeaderboardResults(eventId, options) {
        return (0, exports.LeaderboardResultApiFp)(this.configuration).getLeaderboardResults(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.LeaderboardResultApi = LeaderboardResultApi;
/**
 * NotificationApi - axios parameter creator
 * @export
 */
const NotificationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {ClaimPrizeRequest} claimPrizeRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        claimPrize: (claimPrizeRequest_1, ...args_1) => __awaiter(this, [claimPrizeRequest_1, ...args_1], void 0, function* (claimPrizeRequest, options = {}) {
            // verify required parameter 'claimPrizeRequest' is not null or undefined
            (0, common_1.assertParamExists)('claimPrize', 'claimPrizeRequest', claimPrizeRequest);
            const localVarPath = `/notification/claim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(claimPrizeRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {ClaimPrizeRequest} claimPrizeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimPrizeNew: (claimPrizeRequest_1, ...args_1) => __awaiter(this, [claimPrizeRequest_1, ...args_1], void 0, function* (claimPrizeRequest, options = {}) {
            // verify required parameter 'claimPrizeRequest' is not null or undefined
            (0, common_1.assertParamExists)('claimPrizeNew', 'claimPrizeRequest', claimPrizeRequest);
            const localVarPath = `/notification/claim-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(claimPrizeRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {CreatePrizeDeliveredNotificationRequest} createPrizeDeliveredNotificationRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createPrizeDeliveredNotification: (createPrizeDeliveredNotificationRequest_1, ...args_1) => __awaiter(this, [createPrizeDeliveredNotificationRequest_1, ...args_1], void 0, function* (createPrizeDeliveredNotificationRequest, options = {}) {
            // verify required parameter 'createPrizeDeliveredNotificationRequest' is not null or undefined
            (0, common_1.assertParamExists)('createPrizeDeliveredNotification', 'createPrizeDeliveredNotificationRequest', createPrizeDeliveredNotificationRequest);
            const localVarPath = `/notification/prize-delivered-notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication tsoa_auth required
            // oauth required
            yield (0, common_1.setOAuthToObject)(localVarHeaderParameter, "tsoa_auth", [], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPrizeDeliveredNotificationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteById', 'id', id);
            const localVarPath = `/notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} [page]
         * @param {number} [limit]
         * @param {GetNotificationsOrderByCreatedEnum} [orderByCreated]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: (page_1, limit_1, orderByCreated_1, ...args_1) => __awaiter(this, [page_1, limit_1, orderByCreated_1, ...args_1], void 0, function* (page, limit, orderByCreated, options = {}) {
            const localVarPath = `/notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (orderByCreated !== undefined) {
                localVarQueryParameter['orderByCreated'] = orderByCreated;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {UpdateNotificationsRequest} updateNotificationsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotifications: (updateNotificationsRequest_1, ...args_1) => __awaiter(this, [updateNotificationsRequest_1, ...args_1], void 0, function* (updateNotificationsRequest, options = {}) {
            // verify required parameter 'updateNotificationsRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateNotifications', 'updateNotificationsRequest', updateNotificationsRequest);
            const localVarPath = `/notification/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateNotificationsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.NotificationApiAxiosParamCreator = NotificationApiAxiosParamCreator;
/**
 * NotificationApi - functional programming interface
 * @export
 */
const NotificationApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.NotificationApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {ClaimPrizeRequest} claimPrizeRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        claimPrize(claimPrizeRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.claimPrize(claimPrizeRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotificationApi.claimPrize']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {ClaimPrizeRequest} claimPrizeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimPrizeNew(claimPrizeRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.claimPrizeNew(claimPrizeRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotificationApi.claimPrizeNew']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {CreatePrizeDeliveredNotificationRequest} createPrizeDeliveredNotificationRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createPrizeDeliveredNotification(createPrizeDeliveredNotificationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPrizeDeliveredNotification(createPrizeDeliveredNotificationRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotificationApi.createPrizeDeliveredNotification']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteById(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotificationApi.deleteById']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {number} [page]
         * @param {number} [limit]
         * @param {GetNotificationsOrderByCreatedEnum} [orderByCreated]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(page, limit, orderByCreated, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getNotifications(page, limit, orderByCreated, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotificationApi.getNotifications']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {UpdateNotificationsRequest} updateNotificationsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotifications(updateNotificationsRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateNotifications(updateNotificationsRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['NotificationApi.updateNotifications']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.NotificationApiFp = NotificationApiFp;
/**
 * NotificationApi - factory interface
 * @export
 */
const NotificationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.NotificationApiFp)(configuration);
    return {
        /**
         *
         * @param {ClaimPrizeRequest} claimPrizeRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        claimPrize(claimPrizeRequest, options) {
            return localVarFp.claimPrize(claimPrizeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ClaimPrizeRequest} claimPrizeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimPrizeNew(claimPrizeRequest, options) {
            return localVarFp.claimPrizeNew(claimPrizeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {CreatePrizeDeliveredNotificationRequest} createPrizeDeliveredNotificationRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createPrizeDeliveredNotification(createPrizeDeliveredNotificationRequest, options) {
            return localVarFp.createPrizeDeliveredNotification(createPrizeDeliveredNotificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById(id, options) {
            return localVarFp.deleteById(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [page]
         * @param {number} [limit]
         * @param {GetNotificationsOrderByCreatedEnum} [orderByCreated]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(page, limit, orderByCreated, options) {
            return localVarFp.getNotifications(page, limit, orderByCreated, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UpdateNotificationsRequest} updateNotificationsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotifications(updateNotificationsRequest, options) {
            return localVarFp.updateNotifications(updateNotificationsRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.NotificationApiFactory = NotificationApiFactory;
/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
class NotificationApi extends base_1.BaseAPI {
    /**
     *
     * @param {ClaimPrizeRequest} claimPrizeRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    claimPrize(claimPrizeRequest, options) {
        return (0, exports.NotificationApiFp)(this.configuration).claimPrize(claimPrizeRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ClaimPrizeRequest} claimPrizeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    claimPrizeNew(claimPrizeRequest, options) {
        return (0, exports.NotificationApiFp)(this.configuration).claimPrizeNew(claimPrizeRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {CreatePrizeDeliveredNotificationRequest} createPrizeDeliveredNotificationRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    createPrizeDeliveredNotification(createPrizeDeliveredNotificationRequest, options) {
        return (0, exports.NotificationApiFp)(this.configuration).createPrizeDeliveredNotification(createPrizeDeliveredNotificationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    deleteById(id, options) {
        return (0, exports.NotificationApiFp)(this.configuration).deleteById(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} [page]
     * @param {number} [limit]
     * @param {GetNotificationsOrderByCreatedEnum} [orderByCreated]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    getNotifications(page, limit, orderByCreated, options) {
        return (0, exports.NotificationApiFp)(this.configuration).getNotifications(page, limit, orderByCreated, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {UpdateNotificationsRequest} updateNotificationsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    updateNotifications(updateNotificationsRequest, options) {
        return (0, exports.NotificationApiFp)(this.configuration).updateNotifications(updateNotificationsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.NotificationApi = NotificationApi;
/**
 * @export
 */
exports.GetNotificationsOrderByCreatedEnum = {
    Asc: 'asc',
    Desc: 'desc'
};
/**
 * ProductApi - axios parameter creator
 * @export
 */
const ProductApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Array<ProductType>} [productTypes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: (productTypes_1, ...args_1) => __awaiter(this, [productTypes_1, ...args_1], void 0, function* (productTypes, options = {}) {
            const localVarPath = `/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (productTypes) {
                localVarQueryParameter['productTypes'] = productTypes;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ProductApiAxiosParamCreator = ProductApiAxiosParamCreator;
/**
 * ProductApi - functional programming interface
 * @export
 */
const ProductApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ProductApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {Array<ProductType>} [productTypes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(productTypes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProducts(productTypes, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProductApi.getProducts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.ProductApiFp = ProductApiFp;
/**
 * ProductApi - factory interface
 * @export
 */
const ProductApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ProductApiFp)(configuration);
    return {
        /**
         *
         * @param {Array<ProductType>} [productTypes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(productTypes, options) {
            return localVarFp.getProducts(productTypes, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ProductApiFactory = ProductApiFactory;
/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
class ProductApi extends base_1.BaseAPI {
    /**
     *
     * @param {Array<ProductType>} [productTypes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    getProducts(productTypes, options) {
        return (0, exports.ProductApiFp)(this.configuration).getProducts(productTypes, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProductApi = ProductApi;
/**
 * QuestsApi - axios parameter creator
 * @export
 */
const QuestsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} eventId
         * @param {QuestType} questType
         * @param {number} [page]
         * @param {number} [limit]
         * @param {Array<ActivityType>} [activityTypes]
         * @param {boolean} [processed]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuests: (eventId_1, questType_1, page_1, limit_1, activityTypes_1, processed_1, ...args_1) => __awaiter(this, [eventId_1, questType_1, page_1, limit_1, activityTypes_1, processed_1, ...args_1], void 0, function* (eventId, questType, page, limit, activityTypes, processed, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('getQuests', 'eventId', eventId);
            // verify required parameter 'questType' is not null or undefined
            (0, common_1.assertParamExists)('getQuests', 'questType', questType);
            const localVarPath = `/quests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }
            if (questType !== undefined) {
                localVarQueryParameter['questType'] = questType;
            }
            if (activityTypes) {
                localVarQueryParameter['activityTypes'] = activityTypes;
            }
            if (processed !== undefined) {
                localVarQueryParameter['processed'] = processed;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.QuestsApiAxiosParamCreator = QuestsApiAxiosParamCreator;
/**
 * QuestsApi - functional programming interface
 * @export
 */
const QuestsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.QuestsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {string} eventId
         * @param {QuestType} questType
         * @param {number} [page]
         * @param {number} [limit]
         * @param {Array<ActivityType>} [activityTypes]
         * @param {boolean} [processed]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuests(eventId, questType, page, limit, activityTypes, processed, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getQuests(eventId, questType, page, limit, activityTypes, processed, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['QuestsApi.getQuests']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.QuestsApiFp = QuestsApiFp;
/**
 * QuestsApi - factory interface
 * @export
 */
const QuestsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.QuestsApiFp)(configuration);
    return {
        /**
         *
         * @param {string} eventId
         * @param {QuestType} questType
         * @param {number} [page]
         * @param {number} [limit]
         * @param {Array<ActivityType>} [activityTypes]
         * @param {boolean} [processed]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuests(eventId, questType, page, limit, activityTypes, processed, options) {
            return localVarFp.getQuests(eventId, questType, page, limit, activityTypes, processed, options).then((request) => request(axios, basePath));
        },
    };
};
exports.QuestsApiFactory = QuestsApiFactory;
/**
 * QuestsApi - object-oriented interface
 * @export
 * @class QuestsApi
 * @extends {BaseAPI}
 */
class QuestsApi extends base_1.BaseAPI {
    /**
     *
     * @param {string} eventId
     * @param {QuestType} questType
     * @param {number} [page]
     * @param {number} [limit]
     * @param {Array<ActivityType>} [activityTypes]
     * @param {boolean} [processed]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestsApi
     */
    getQuests(eventId, questType, page, limit, activityTypes, processed, options) {
        return (0, exports.QuestsApiFp)(this.configuration).getQuests(eventId, questType, page, limit, activityTypes, processed, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.QuestsApi = QuestsApi;
/**
 * QuestsNewApi - axios parameter creator
 * @export
 */
const QuestsNewApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameQuestTemplates: (gameId_1, ...args_1) => __awaiter(this, [gameId_1, ...args_1], void 0, function* (gameId, options = {}) {
            // verify required parameter 'gameId' is not null or undefined
            (0, common_1.assertParamExists)('getGameQuestTemplates', 'gameId', gameId);
            const localVarPath = `/quests-new/game-quest-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (gameId !== undefined) {
                localVarQueryParameter['gameId'] = gameId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} eventId
         * @param {number} [page]
         * @param {number} [limit]
         * @param {Array<QuestType>} [questTypes]
         * @param {Array<ActivityType>} [activityTypes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestsNew: (eventId_1, page_1, limit_1, questTypes_1, activityTypes_1, ...args_1) => __awaiter(this, [eventId_1, page_1, limit_1, questTypes_1, activityTypes_1, ...args_1], void 0, function* (eventId, page, limit, questTypes, activityTypes, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('getQuestsNew', 'eventId', eventId);
            const localVarPath = `/quests-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }
            if (questTypes) {
                localVarQueryParameter['questTypes'] = questTypes;
            }
            if (activityTypes) {
                localVarQueryParameter['activityTypes'] = activityTypes;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {Array<ActivityType>} activityTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialQuestTemplates: (activityTypes_1, ...args_1) => __awaiter(this, [activityTypes_1, ...args_1], void 0, function* (activityTypes, options = {}) {
            // verify required parameter 'activityTypes' is not null or undefined
            (0, common_1.assertParamExists)('getSocialQuestTemplates', 'activityTypes', activityTypes);
            const localVarPath = `/quests-new/social-quest-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (activityTypes) {
                localVarQueryParameter['activityTypes'] = activityTypes;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.QuestsNewApiAxiosParamCreator = QuestsNewApiAxiosParamCreator;
/**
 * QuestsNewApi - functional programming interface
 * @export
 */
const QuestsNewApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.QuestsNewApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameQuestTemplates(gameId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGameQuestTemplates(gameId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['QuestsNewApi.getGameQuestTemplates']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} eventId
         * @param {number} [page]
         * @param {number} [limit]
         * @param {Array<QuestType>} [questTypes]
         * @param {Array<ActivityType>} [activityTypes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestsNew(eventId, page, limit, questTypes, activityTypes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getQuestsNew(eventId, page, limit, questTypes, activityTypes, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['QuestsNewApi.getQuestsNew']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {Array<ActivityType>} activityTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialQuestTemplates(activityTypes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSocialQuestTemplates(activityTypes, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['QuestsNewApi.getSocialQuestTemplates']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.QuestsNewApiFp = QuestsNewApiFp;
/**
 * QuestsNewApi - factory interface
 * @export
 */
const QuestsNewApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.QuestsNewApiFp)(configuration);
    return {
        /**
         *
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameQuestTemplates(gameId, options) {
            return localVarFp.getGameQuestTemplates(gameId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} eventId
         * @param {number} [page]
         * @param {number} [limit]
         * @param {Array<QuestType>} [questTypes]
         * @param {Array<ActivityType>} [activityTypes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestsNew(eventId, page, limit, questTypes, activityTypes, options) {
            return localVarFp.getQuestsNew(eventId, page, limit, questTypes, activityTypes, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Array<ActivityType>} activityTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSocialQuestTemplates(activityTypes, options) {
            return localVarFp.getSocialQuestTemplates(activityTypes, options).then((request) => request(axios, basePath));
        },
    };
};
exports.QuestsNewApiFactory = QuestsNewApiFactory;
/**
 * QuestsNewApi - object-oriented interface
 * @export
 * @class QuestsNewApi
 * @extends {BaseAPI}
 */
class QuestsNewApi extends base_1.BaseAPI {
    /**
     *
     * @param {string} gameId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestsNewApi
     */
    getGameQuestTemplates(gameId, options) {
        return (0, exports.QuestsNewApiFp)(this.configuration).getGameQuestTemplates(gameId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} eventId
     * @param {number} [page]
     * @param {number} [limit]
     * @param {Array<QuestType>} [questTypes]
     * @param {Array<ActivityType>} [activityTypes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestsNewApi
     */
    getQuestsNew(eventId, page, limit, questTypes, activityTypes, options) {
        return (0, exports.QuestsNewApiFp)(this.configuration).getQuestsNew(eventId, page, limit, questTypes, activityTypes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {Array<ActivityType>} activityTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestsNewApi
     */
    getSocialQuestTemplates(activityTypes, options) {
        return (0, exports.QuestsNewApiFp)(this.configuration).getSocialQuestTemplates(activityTypes, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.QuestsNewApi = QuestsNewApi;
/**
 * SocialApi - axios parameter creator
 * @export
 */
const SocialApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * If there is no goalId, still save the user connection details. If there is a goalId, complete the quest/goal and reward the user. If the quest is completed, update the leaderboard score.
         * @param {CompleteSocialQuestRequest} completeSocialQuestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSocialQuest: (completeSocialQuestRequest_1, ...args_1) => __awaiter(this, [completeSocialQuestRequest_1, ...args_1], void 0, function* (completeSocialQuestRequest, options = {}) {
            // verify required parameter 'completeSocialQuestRequest' is not null or undefined
            (0, common_1.assertParamExists)('completeSocialQuest', 'completeSocialQuestRequest', completeSocialQuestRequest);
            const localVarPath = `/social/complete-social`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(completeSocialQuestRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {SocialQuestCreateInput} socialQuestCreateInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSociaQuest: (socialQuestCreateInput_1, ...args_1) => __awaiter(this, [socialQuestCreateInput_1, ...args_1], void 0, function* (socialQuestCreateInput, options = {}) {
            // verify required parameter 'socialQuestCreateInput' is not null or undefined
            (0, common_1.assertParamExists)('createSociaQuest', 'socialQuestCreateInput', socialQuestCreateInput);
            const localVarPath = `/social/quest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(socialQuestCreateInput, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SocialApiAxiosParamCreator = SocialApiAxiosParamCreator;
/**
 * SocialApi - functional programming interface
 * @export
 */
const SocialApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SocialApiAxiosParamCreator)(configuration);
    return {
        /**
         * If there is no goalId, still save the user connection details. If there is a goalId, complete the quest/goal and reward the user. If the quest is completed, update the leaderboard score.
         * @param {CompleteSocialQuestRequest} completeSocialQuestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSocialQuest(completeSocialQuestRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.completeSocialQuest(completeSocialQuestRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SocialApi.completeSocialQuest']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {SocialQuestCreateInput} socialQuestCreateInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSociaQuest(socialQuestCreateInput, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createSociaQuest(socialQuestCreateInput, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SocialApi.createSociaQuest']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.SocialApiFp = SocialApiFp;
/**
 * SocialApi - factory interface
 * @export
 */
const SocialApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SocialApiFp)(configuration);
    return {
        /**
         * If there is no goalId, still save the user connection details. If there is a goalId, complete the quest/goal and reward the user. If the quest is completed, update the leaderboard score.
         * @param {CompleteSocialQuestRequest} completeSocialQuestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSocialQuest(completeSocialQuestRequest, options) {
            return localVarFp.completeSocialQuest(completeSocialQuestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SocialQuestCreateInput} socialQuestCreateInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSociaQuest(socialQuestCreateInput, options) {
            return localVarFp.createSociaQuest(socialQuestCreateInput, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SocialApiFactory = SocialApiFactory;
/**
 * SocialApi - object-oriented interface
 * @export
 * @class SocialApi
 * @extends {BaseAPI}
 */
class SocialApi extends base_1.BaseAPI {
    /**
     * If there is no goalId, still save the user connection details. If there is a goalId, complete the quest/goal and reward the user. If the quest is completed, update the leaderboard score.
     * @param {CompleteSocialQuestRequest} completeSocialQuestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialApi
     */
    completeSocialQuest(completeSocialQuestRequest, options) {
        return (0, exports.SocialApiFp)(this.configuration).completeSocialQuest(completeSocialQuestRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {SocialQuestCreateInput} socialQuestCreateInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialApi
     */
    createSociaQuest(socialQuestCreateInput, options) {
        return (0, exports.SocialApiFp)(this.configuration).createSociaQuest(socialQuestCreateInput, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SocialApi = SocialApi;
/**
 * SocialNewApi - axios parameter creator
 * @export
 */
const SocialNewApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {CompleteSocialQuestRequestNew} completeSocialQuestRequestNew
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSocialQuestNew: (completeSocialQuestRequestNew_1, ...args_1) => __awaiter(this, [completeSocialQuestRequestNew_1, ...args_1], void 0, function* (completeSocialQuestRequestNew, options = {}) {
            // verify required parameter 'completeSocialQuestRequestNew' is not null or undefined
            (0, common_1.assertParamExists)('completeSocialQuestNew', 'completeSocialQuestRequestNew', completeSocialQuestRequestNew);
            const localVarPath = `/social-new/complete-social-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(completeSocialQuestRequestNew, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} [id]
         * @param {Array<ConnectionType>} [connectionTypes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectedSocialsNew: (id_1, connectionTypes_1, ...args_1) => __awaiter(this, [id_1, connectionTypes_1, ...args_1], void 0, function* (id, connectionTypes, options = {}) {
            const localVarPath = `/social-new/connected-socials-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (connectionTypes) {
                localVarQueryParameter['connectionTypes'] = connectionTypes;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {ConnectionType} connectionType
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeConnectedSocialNew: (connectionType_1, userId_1, ...args_1) => __awaiter(this, [connectionType_1, userId_1, ...args_1], void 0, function* (connectionType, userId, options = {}) {
            // verify required parameter 'connectionType' is not null or undefined
            (0, common_1.assertParamExists)('removeConnectedSocialNew', 'connectionType', connectionType);
            const localVarPath = `/social-new/connected-social-new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (connectionType !== undefined) {
                localVarQueryParameter['connectionType'] = connectionType;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SocialNewApiAxiosParamCreator = SocialNewApiAxiosParamCreator;
/**
 * SocialNewApi - functional programming interface
 * @export
 */
const SocialNewApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SocialNewApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {CompleteSocialQuestRequestNew} completeSocialQuestRequestNew
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSocialQuestNew(completeSocialQuestRequestNew, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.completeSocialQuestNew(completeSocialQuestRequestNew, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SocialNewApi.completeSocialQuestNew']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} [id]
         * @param {Array<ConnectionType>} [connectionTypes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectedSocialsNew(id, connectionTypes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getConnectedSocialsNew(id, connectionTypes, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SocialNewApi.getConnectedSocialsNew']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {ConnectionType} connectionType
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeConnectedSocialNew(connectionType, userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.removeConnectedSocialNew(connectionType, userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['SocialNewApi.removeConnectedSocialNew']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.SocialNewApiFp = SocialNewApiFp;
/**
 * SocialNewApi - factory interface
 * @export
 */
const SocialNewApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SocialNewApiFp)(configuration);
    return {
        /**
         *
         * @param {CompleteSocialQuestRequestNew} completeSocialQuestRequestNew
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeSocialQuestNew(completeSocialQuestRequestNew, options) {
            return localVarFp.completeSocialQuestNew(completeSocialQuestRequestNew, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [id]
         * @param {Array<ConnectionType>} [connectionTypes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectedSocialsNew(id, connectionTypes, options) {
            return localVarFp.getConnectedSocialsNew(id, connectionTypes, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ConnectionType} connectionType
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeConnectedSocialNew(connectionType, userId, options) {
            return localVarFp.removeConnectedSocialNew(connectionType, userId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SocialNewApiFactory = SocialNewApiFactory;
/**
 * SocialNewApi - object-oriented interface
 * @export
 * @class SocialNewApi
 * @extends {BaseAPI}
 */
class SocialNewApi extends base_1.BaseAPI {
    /**
     *
     * @param {CompleteSocialQuestRequestNew} completeSocialQuestRequestNew
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialNewApi
     */
    completeSocialQuestNew(completeSocialQuestRequestNew, options) {
        return (0, exports.SocialNewApiFp)(this.configuration).completeSocialQuestNew(completeSocialQuestRequestNew, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} [id]
     * @param {Array<ConnectionType>} [connectionTypes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialNewApi
     */
    getConnectedSocialsNew(id, connectionTypes, options) {
        return (0, exports.SocialNewApiFp)(this.configuration).getConnectedSocialsNew(id, connectionTypes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ConnectionType} connectionType
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SocialNewApi
     */
    removeConnectedSocialNew(connectionType, userId, options) {
        return (0, exports.SocialNewApiFp)(this.configuration).removeConnectedSocialNew(connectionType, userId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SocialNewApi = SocialNewApi;
/**
 * TransactionApi - axios parameter creator
 * @export
 */
const TransactionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Array<ProductType>} [sellProductType]
         * @param {string} [sellProductId]
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions: (sellProductType_1, sellProductId_1, page_1, limit_1, ...args_1) => __awaiter(this, [sellProductType_1, sellProductId_1, page_1, limit_1, ...args_1], void 0, function* (sellProductType, sellProductId, page, limit, options = {}) {
            const localVarPath = `/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (sellProductType) {
                localVarQueryParameter['sellProductType'] = sellProductType;
            }
            if (sellProductId !== undefined) {
                localVarQueryParameter['sellProductId'] = sellProductId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TransactionApiAxiosParamCreator = TransactionApiAxiosParamCreator;
/**
 * TransactionApi - functional programming interface
 * @export
 */
const TransactionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TransactionApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {Array<ProductType>} [sellProductType]
         * @param {string} [sellProductId]
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions(sellProductType, sellProductId, page, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllTransactions(sellProductType, sellProductId, page, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['TransactionApi.getAllTransactions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.TransactionApiFp = TransactionApiFp;
/**
 * TransactionApi - factory interface
 * @export
 */
const TransactionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TransactionApiFp)(configuration);
    return {
        /**
         *
         * @param {Array<ProductType>} [sellProductType]
         * @param {string} [sellProductId]
         * @param {number} [page]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions(sellProductType, sellProductId, page, limit, options) {
            return localVarFp.getAllTransactions(sellProductType, sellProductId, page, limit, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TransactionApiFactory = TransactionApiFactory;
/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
class TransactionApi extends base_1.BaseAPI {
    /**
     *
     * @param {Array<ProductType>} [sellProductType]
     * @param {string} [sellProductId]
     * @param {number} [page]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    getAllTransactions(sellProductType, sellProductId, page, limit, options) {
        return (0, exports.TransactionApiFp)(this.configuration).getAllTransactions(sellProductType, sellProductId, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TransactionApi = TransactionApi;
/**
 * UserApi - axios parameter creator
 * @export
 */
const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMe: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAccounts: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/user/linked-accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferrals: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/user/referrals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} [id]
         * @param {string} [email]
         * @param {string} [code]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: (id_1, email_1, code_1, ...args_1) => __awaiter(this, [id_1, email_1, code_1, ...args_1], void 0, function* (id, email, code, options = {}) {
            const localVarPath = `/user/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }
            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} gameId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersMergedWith: (gameId_1, userId_1, ...args_1) => __awaiter(this, [gameId_1, userId_1, ...args_1], void 0, function* (gameId, userId, options = {}) {
            // verify required parameter 'gameId' is not null or undefined
            (0, common_1.assertParamExists)('getUsersMergedWith', 'gameId', gameId);
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getUsersMergedWith', 'userId', userId);
            const localVarPath = `/user/{gameId}/{userId}`
                .replace(`{${"gameId"}}`, encodeURIComponent(String(gameId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {Array<GameCodeType>} gameCodeType
         * @param {string} gameId
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWinCodeHistory: (gameCodeType_1, gameId_1, eventId_1, ...args_1) => __awaiter(this, [gameCodeType_1, gameId_1, eventId_1, ...args_1], void 0, function* (gameCodeType, gameId, eventId, options = {}) {
            // verify required parameter 'gameCodeType' is not null or undefined
            (0, common_1.assertParamExists)('getWinCodeHistory', 'gameCodeType', gameCodeType);
            // verify required parameter 'gameId' is not null or undefined
            (0, common_1.assertParamExists)('getWinCodeHistory', 'gameId', gameId);
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('getWinCodeHistory', 'eventId', eventId);
            const localVarPath = `/user/code-use-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (gameCodeType) {
                localVarQueryParameter['gameCodeType'] = gameCodeType;
            }
            if (gameId !== undefined) {
                localVarQueryParameter['gameId'] = gameId;
            }
            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {RegisterRequest} registerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: (registerRequest_1, ...args_1) => __awaiter(this, [registerRequest_1, ...args_1], void 0, function* (registerRequest, options = {}) {
            // verify required parameter 'registerRequest' is not null or undefined
            (0, common_1.assertParamExists)('register', 'registerRequest', registerRequest);
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(registerRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {UpdateRequest} updateRequest
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: (updateRequest_1, userId_1, ...args_1) => __awaiter(this, [updateRequest_1, userId_1, ...args_1], void 0, function* (updateRequest, userId, options = {}) {
            // verify required parameter 'updateRequest' is not null or undefined
            (0, common_1.assertParamExists)('update', 'updateRequest', updateRequest);
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} referralCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReferral: (referralCode_1, ...args_1) => __awaiter(this, [referralCode_1, ...args_1], void 0, function* (referralCode, options = {}) {
            // verify required parameter 'referralCode' is not null or undefined
            (0, common_1.assertParamExists)('updateReferral', 'referralCode', referralCode);
            const localVarPath = `/user/referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (referralCode !== undefined) {
                localVarQueryParameter['referralCode'] = referralCode;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Only 1 external user for a given game can be linked to an internal user (mergedWith). Meaning you cannot link internalId1 to externalId2 from fake-game if internalId1 is already merged with externalId1 from fake-game.
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMergedWith: (gameId_1, ...args_1) => __awaiter(this, [gameId_1, ...args_1], void 0, function* (gameId, options = {}) {
            // verify required parameter 'gameId' is not null or undefined
            (0, common_1.assertParamExists)('userMergedWith', 'gameId', gameId);
            const localVarPath = `/user/merged-with`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (gameId !== undefined) {
                localVarQueryParameter['gameId'] = gameId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UserApiAxiosParamCreator = UserApiAxiosParamCreator;
/**
 * UserApi - functional programming interface
 * @export
 */
const UserApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UserApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMe(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteMe(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.deleteMe']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAccounts(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLinkedAccounts(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.getLinkedAccounts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMe(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.getMe']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferrals(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getReferrals(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.getReferrals']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} [id]
         * @param {string} [email]
         * @param {string} [code]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id, email, code, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUser(id, email, code, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.getUser']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} gameId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersMergedWith(gameId, userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsersMergedWith(gameId, userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.getUsersMergedWith']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {Array<GameCodeType>} gameCodeType
         * @param {string} gameId
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWinCodeHistory(gameCodeType, gameId, eventId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getWinCodeHistory(gameCodeType, gameId, eventId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.getWinCodeHistory']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {RegisterRequest} registerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.register(registerRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.register']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {UpdateRequest} updateRequest
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(updateRequest, userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.update(updateRequest, userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.update']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {string} referralCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReferral(referralCode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateReferral(referralCode, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.updateReferral']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Only 1 external user for a given game can be linked to an internal user (mergedWith). Meaning you cannot link internalId1 to externalId2 from fake-game if internalId1 is already merged with externalId1 from fake-game.
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMergedWith(gameId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.userMergedWith(gameId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserApi.userMergedWith']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.UserApiFp = UserApiFp;
/**
 * UserApi - factory interface
 * @export
 */
const UserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UserApiFp)(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMe(options) {
            return localVarFp.deleteMe(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedAccounts(options) {
            return localVarFp.getLinkedAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options) {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferrals(options) {
            return localVarFp.getReferrals(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [id]
         * @param {string} [email]
         * @param {string} [code]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id, email, code, options) {
            return localVarFp.getUser(id, email, code, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} gameId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersMergedWith(gameId, userId, options) {
            return localVarFp.getUsersMergedWith(gameId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Array<GameCodeType>} gameCodeType
         * @param {string} gameId
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWinCodeHistory(gameCodeType, gameId, eventId, options) {
            return localVarFp.getWinCodeHistory(gameCodeType, gameId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {RegisterRequest} registerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest, options) {
            return localVarFp.register(registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UpdateRequest} updateRequest
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(updateRequest, userId, options) {
            return localVarFp.update(updateRequest, userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} referralCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReferral(referralCode, options) {
            return localVarFp.updateReferral(referralCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Only 1 external user for a given game can be linked to an internal user (mergedWith). Meaning you cannot link internalId1 to externalId2 from fake-game if internalId1 is already merged with externalId1 from fake-game.
         * @param {string} gameId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMergedWith(gameId, options) {
            return localVarFp.userMergedWith(gameId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserApiFactory = UserApiFactory;
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends base_1.BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteMe(options) {
        return (0, exports.UserApiFp)(this.configuration).deleteMe(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getLinkedAccounts(options) {
        return (0, exports.UserApiFp)(this.configuration).getLinkedAccounts(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getMe(options) {
        return (0, exports.UserApiFp)(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getReferrals(options) {
        return (0, exports.UserApiFp)(this.configuration).getReferrals(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} [id]
     * @param {string} [email]
     * @param {string} [code]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(id, email, code, options) {
        return (0, exports.UserApiFp)(this.configuration).getUser(id, email, code, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} gameId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUsersMergedWith(gameId, userId, options) {
        return (0, exports.UserApiFp)(this.configuration).getUsersMergedWith(gameId, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {Array<GameCodeType>} gameCodeType
     * @param {string} gameId
     * @param {string} eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getWinCodeHistory(gameCodeType, gameId, eventId, options) {
        return (0, exports.UserApiFp)(this.configuration).getWinCodeHistory(gameCodeType, gameId, eventId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {RegisterRequest} registerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    register(registerRequest, options) {
        return (0, exports.UserApiFp)(this.configuration).register(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {UpdateRequest} updateRequest
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    update(updateRequest, userId, options) {
        return (0, exports.UserApiFp)(this.configuration).update(updateRequest, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} referralCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateReferral(referralCode, options) {
        return (0, exports.UserApiFp)(this.configuration).updateReferral(referralCode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Only 1 external user for a given game can be linked to an internal user (mergedWith). Meaning you cannot link internalId1 to externalId2 from fake-game if internalId1 is already merged with externalId1 from fake-game.
     * @param {string} gameId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    userMergedWith(gameId, options) {
        return (0, exports.UserApiFp)(this.configuration).userMergedWith(gameId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserApi = UserApi;
/**
 * UserConnectionApi - axios parameter creator
 * @export
 */
const UserConnectionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {CreateUserConnectionRequest} createUserConnectionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectSocial: (createUserConnectionRequest_1, ...args_1) => __awaiter(this, [createUserConnectionRequest_1, ...args_1], void 0, function* (createUserConnectionRequest, options = {}) {
            // verify required parameter 'createUserConnectionRequest' is not null or undefined
            (0, common_1.assertParamExists)('connectSocial', 'createUserConnectionRequest', createUserConnectionRequest);
            const localVarPath = `/user-connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createUserConnectionRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {Array<ConnectionType>} connectionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserConnections: (connectionTypes_1, ...args_1) => __awaiter(this, [connectionTypes_1, ...args_1], void 0, function* (connectionTypes, options = {}) {
            // verify required parameter 'connectionTypes' is not null or undefined
            (0, common_1.assertParamExists)('getUserConnections', 'connectionTypes', connectionTypes);
            const localVarPath = `/user-connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (connectionTypes) {
                localVarQueryParameter['connectionTypes'] = connectionTypes;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {ConnectionType} connectionType
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeConnectedSocial: (connectionType_1, userId_1, ...args_1) => __awaiter(this, [connectionType_1, userId_1, ...args_1], void 0, function* (connectionType, userId, options = {}) {
            // verify required parameter 'connectionType' is not null or undefined
            (0, common_1.assertParamExists)('removeConnectedSocial', 'connectionType', connectionType);
            const localVarPath = `/user-connection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            if (connectionType !== undefined) {
                localVarQueryParameter['connectionType'] = connectionType;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UserConnectionApiAxiosParamCreator = UserConnectionApiAxiosParamCreator;
/**
 * UserConnectionApi - functional programming interface
 * @export
 */
const UserConnectionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UserConnectionApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {CreateUserConnectionRequest} createUserConnectionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectSocial(createUserConnectionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.connectSocial(createUserConnectionRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserConnectionApi.connectSocial']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {Array<ConnectionType>} connectionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserConnections(connectionTypes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserConnections(connectionTypes, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserConnectionApi.getUserConnections']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {ConnectionType} connectionType
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeConnectedSocial(connectionType, userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.removeConnectedSocial(connectionType, userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserConnectionApi.removeConnectedSocial']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.UserConnectionApiFp = UserConnectionApiFp;
/**
 * UserConnectionApi - factory interface
 * @export
 */
const UserConnectionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UserConnectionApiFp)(configuration);
    return {
        /**
         *
         * @param {CreateUserConnectionRequest} createUserConnectionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectSocial(createUserConnectionRequest, options) {
            return localVarFp.connectSocial(createUserConnectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Array<ConnectionType>} connectionTypes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserConnections(connectionTypes, options) {
            return localVarFp.getUserConnections(connectionTypes, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {ConnectionType} connectionType
         * @param {string} [userId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeConnectedSocial(connectionType, userId, options) {
            return localVarFp.removeConnectedSocial(connectionType, userId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserConnectionApiFactory = UserConnectionApiFactory;
/**
 * UserConnectionApi - object-oriented interface
 * @export
 * @class UserConnectionApi
 * @extends {BaseAPI}
 */
class UserConnectionApi extends base_1.BaseAPI {
    /**
     *
     * @param {CreateUserConnectionRequest} createUserConnectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserConnectionApi
     */
    connectSocial(createUserConnectionRequest, options) {
        return (0, exports.UserConnectionApiFp)(this.configuration).connectSocial(createUserConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {Array<ConnectionType>} connectionTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserConnectionApi
     */
    getUserConnections(connectionTypes, options) {
        return (0, exports.UserConnectionApiFp)(this.configuration).getUserConnections(connectionTypes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {ConnectionType} connectionType
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserConnectionApi
     */
    removeConnectedSocial(connectionType, userId, options) {
        return (0, exports.UserConnectionApiFp)(this.configuration).removeConnectedSocial(connectionType, userId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserConnectionApi = UserConnectionApi;
/**
 * UserWalletApi - axios parameter creator
 * @export
 */
const UserWalletApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/user-wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeSolanaUserWalletToDB: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/user-wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {UpdateUserWalletRequest} updateUserWalletRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserWallet: (updateUserWalletRequest_1, ...args_1) => __awaiter(this, [updateUserWalletRequest_1, ...args_1], void 0, function* (updateUserWalletRequest, options = {}) {
            // verify required parameter 'updateUserWalletRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateUserWallet', 'updateUserWalletRequest', updateUserWalletRequest);
            const localVarPath = `/user-wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "access_token", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateUserWalletRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UserWalletApiAxiosParamCreator = UserWalletApiAxiosParamCreator;
/**
 * UserWalletApi - functional programming interface
 * @export
 */
const UserWalletApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UserWalletApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserWallets(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserWalletApi.getUserWallets']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeSolanaUserWalletToDB(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.storeSolanaUserWalletToDB(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserWalletApi.storeSolanaUserWalletToDB']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @param {UpdateUserWalletRequest} updateUserWalletRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserWallet(updateUserWalletRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserWallet(updateUserWalletRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UserWalletApi.updateUserWallet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.UserWalletApiFp = UserWalletApiFp;
/**
 * UserWalletApi - factory interface
 * @export
 */
const UserWalletApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UserWalletApiFp)(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWallets(options) {
            return localVarFp.getUserWallets(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeSolanaUserWalletToDB(options) {
            return localVarFp.storeSolanaUserWalletToDB(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UpdateUserWalletRequest} updateUserWalletRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserWallet(updateUserWalletRequest, options) {
            return localVarFp.updateUserWallet(updateUserWalletRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserWalletApiFactory = UserWalletApiFactory;
/**
 * UserWalletApi - object-oriented interface
 * @export
 * @class UserWalletApi
 * @extends {BaseAPI}
 */
class UserWalletApi extends base_1.BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletApi
     */
    getUserWallets(options) {
        return (0, exports.UserWalletApiFp)(this.configuration).getUserWallets(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletApi
     */
    storeSolanaUserWalletToDB(options) {
        return (0, exports.UserWalletApiFp)(this.configuration).storeSolanaUserWalletToDB(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {UpdateUserWalletRequest} updateUserWalletRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserWalletApi
     */
    updateUserWallet(updateUserWalletRequest, options) {
        return (0, exports.UserWalletApiFp)(this.configuration).updateUserWallet(updateUserWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserWalletApi = UserWalletApi;
/**
 * UtilityApi - axios parameter creator
 * @export
 */
const UtilityApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Does sanity checks and returns 200 OK if everything is working as expected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/utility/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UtilityApiAxiosParamCreator = UtilityApiAxiosParamCreator;
/**
 * UtilityApi - functional programming interface
 * @export
 */
const UtilityApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UtilityApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Does sanity checks and returns 200 OK if everything is working as expected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.healthCheck(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['UtilityApi.healthCheck']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.UtilityApiFp = UtilityApiFp;
/**
 * UtilityApi - factory interface
 * @export
 */
const UtilityApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UtilityApiFp)(configuration);
    return {
        /**
         *
         * @summary Does sanity checks and returns 200 OK if everything is working as expected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options) {
            return localVarFp.healthCheck(options).then((request) => request(axios, basePath));
        },
    };
};
exports.UtilityApiFactory = UtilityApiFactory;
/**
 * UtilityApi - object-oriented interface
 * @export
 * @class UtilityApi
 * @extends {BaseAPI}
 */
class UtilityApi extends base_1.BaseAPI {
    /**
     *
     * @summary Does sanity checks and returns 200 OK if everything is working as expected.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilityApi
     */
    healthCheck(options) {
        return (0, exports.UtilityApiFp)(this.configuration).healthCheck(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UtilityApi = UtilityApi;
